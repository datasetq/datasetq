//! Built-in functions for dsq
//!
//! This crate provides all built-in functions available in dsq filters,
//! including jq-compatible functions and DataFrame-specific operations.

use dsq_shared::Result;
use dsq_shared::value::{Value, value_from_any_value, is_truthy};
use polars::prelude::*;
use std::collections::HashMap;
use std::sync::Arc;

use base32::{encode, decode, Alphabet};
use base58::{FromBase58, ToBase58};
use base64::{Engine as _, engine::general_purpose};
use std::borrow::Cow;
use sha2::{Sha512, Sha256, Digest};
use sha1::Sha1;

use chrono::{Datelike, DateTime, Local, NaiveDate, NaiveDateTime, TimeZone, Timelike, Utc};
use rand::Rng;
use heck::{ToSnakeCase, ToLowerCamelCase};
use serde_json;
use url::Url;
use num_traits::sign::Signed;

/// Built-in function implementation
pub type BuiltinFunction = Arc<dyn Fn(&[Value]) -> Result<Value> + Send + Sync>;

fn builtin_map(args: &[Value]) -> Result<Value> {
    match args.len() {
        1 => Ok(args[0].clone()),
        2 => {
            match (&args[0], &args[1]) {
                (Value::Array(arr), Value::String(field)) => {
                    let mut result = Vec::new();
                    for item in arr {
                        if let Value::Object(obj) = item {
                            if let Some(val) = obj.get(field) {
                                result.push(val.clone());
                            } else {
                                result.push(Value::Null);
                            }
                        } else {
                            result.push(Value::Null);
                        }
                    }
                    Ok(Value::Array(result))
                }
                (Value::Array(arr), Value::Object(template)) => {
                    let mut result = Vec::new();
                    for item in arr {
                        if let Value::Object(obj) = item {
                            let mut new_obj = HashMap::new();
                            for (key, _) in template {
                                if let Some(val) = obj.get(key) {
                                    new_obj.insert(key.clone(), val.clone());
                                } else {
                                    new_obj.insert(key.clone(), Value::Null);
                                }
                            }
                            result.push(Value::Object(new_obj));
                        } else {
                            result.push(Value::Null);
                        }
                    }
                    Ok(Value::Array(result))
                }
                (Value::DataFrame(df), Value::String(field)) => {
                    if let Ok(series) = df.column(field) {
                        let mut values = Vec::new();
                        for i in 0..series.len() {
                            if let Ok(val) = series.get(i) {
                                let value = value_from_any_value(val).unwrap_or(Value::Null);
                                values.push(value);
                            }
                        }
                        Ok(Value::Array(values))
                    } else {
                        Err(dsq_shared::error::operation_error(format!("Column '{}' not found", field)))
                    }
                }
                (Value::DataFrame(df), Value::Object(template)) => {
                    // Select columns specified in template
                    let mut selected_series = Vec::new();
                    for (key, _) in template {
                        if let Ok(series) = df.column(key) {
                            let mut s = series.clone();
                            s.rename(key);
                            selected_series.push(s);
                        }
                    }
                    match DataFrame::new(selected_series) {
                        Ok(selected_df) => Ok(Value::DataFrame(selected_df)),
                        Err(e) => Err(dsq_shared::error::operation_error(format!("map() failed on DataFrame: {}", e))),
                    }
                }
                _ => Ok(args[0].clone()),
            }
        }
        _ => Err(dsq_shared::error::operation_error("map() expects 1 or 2 arguments")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn dataframe_to_objects(df: &DataFrame) -> Vec<HashMap<String, Value>> {
    let mut objects = Vec::new();
    for i in 0..df.height() {
        let mut obj = HashMap::new();
        for col_name in df.get_column_names() {
            if let Ok(series) = df.column(col_name) {
                if let Ok(val) = series.get(i) {
                    let value = value_from_any_value(val).unwrap_or(Value::Null);
                    obj.insert(col_name.to_string(), value);
                }
            }
        }
        objects.push(obj);
    }
    objects
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_group_by(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("group_by() expects 2 arguments"));
    }

    match (&args[0], &args[1]) {
        (Value::Array(arr), Value::Array(keys)) if arr.len() == keys.len() => {
            // Group array by keys
            let mut groups: HashMap<String, Vec<Value>> = HashMap::new();
            for (item, key) in arr.iter().zip(keys.iter()) {
                let key_str = match key {
                    Value::String(s) => s.clone(),
                    Value::Int(i) => i.to_string(),
                    Value::Float(f) => f.to_string(),
                    Value::Bool(b) => b.to_string(),
                    _ => "".to_string(),
                };
                groups.entry(key_str).or_insert_with(Vec::new).push(item.clone());
            }
            let mut result: Vec<Value> = groups.into_iter().map(|(_, group)| Value::Array(group)).collect();
            // Sort groups by key
            result.sort_by(|a, b| {
                if let (Value::Array(a_arr), Value::Array(b_arr)) = (a, b) {
                    if let (Some(a_item), Some(b_item)) = (a_arr.first(), b_arr.first()) {
                        // Find the key for a_item and b_item
                        // This is inefficient but works for now
                        for (item, key) in arr.iter().zip(keys.iter()) {
                            if item == a_item {
                                let a_key = match key {
                                    Value::String(s) => s.clone(),
                                    Value::Int(i) => i.to_string(),
                                    Value::Float(f) => f.to_string(),
                                    Value::Bool(b) => b.to_string(),
                                    _ => "".to_string(),
                                };
                                for (item2, key2) in arr.iter().zip(keys.iter()) {
                                    if item2 == b_item {
                                        let b_key = match key2 {
                                            Value::String(s) => s.clone(),
                                            Value::Int(i) => i.to_string(),
                                            Value::Float(f) => f.to_string(),
                                            Value::Bool(b) => b.to_string(),
                                            _ => "".to_string(),
                                        };
                                        return a_key.cmp(&b_key);
                                    }
                                }
                            }
                        }
                    }
                }
                std::cmp::Ordering::Equal
            });
            Ok(Value::Array(result))
        }
        (Value::Array(arr), Value::String(field)) => {
            // Group array of objects by field
            let mut groups: HashMap<String, Vec<Value>> = HashMap::new();
            for item in arr {
                if let Value::Object(obj) = item {
                    let key = if let Some(Value::String(s)) = obj.get(field) {
                        s.clone()
                    } else {
                        "".to_string()
                    };
                    groups.entry(key).or_insert_with(Vec::new).push(item.clone());
                }
            }
            let mut result: Vec<Value> = groups.into_iter().map(|(_, group)| Value::Array(group)).collect();
            // Sort groups by first element's field for consistency
            result.sort_by(|a, b| {
                if let (Value::Array(a_arr), Value::Array(b_arr)) = (a, b) {
                    if let (Some(Value::Object(a_obj)), Some(Value::Object(b_obj))) = (a_arr.first(), b_arr.first()) {
                        if let (Some(Value::String(a_key)), Some(Value::String(b_key))) = (a_obj.get(field), b_obj.get(field)) {
                            a_key.cmp(b_key)
                        } else {
                            std::cmp::Ordering::Equal
                        }
                    } else {
                        std::cmp::Ordering::Equal
                    }
                } else {
                    std::cmp::Ordering::Equal
                }
            });
            Ok(Value::Array(result))
        }
        (Value::DataFrame(df), Value::String(column)) => {
            // Group DataFrame by column
            match df.group_by([column.as_str()]) {
                Ok(grouped) => {
                    match grouped.groups() {
                        Ok(groups_df) => {
                            // groups_df has columns for the grouping keys and a "groups" column with indices
                            let mut result_groups = Vec::new();
                            for i in 0..groups_df.height() {
                                if let Ok(group_indices) = groups_df.column("groups") {
                                    if let Ok(AnyValue::List(list)) = group_indices.get(i) {
                                        let indices: Vec<u32> = list.iter().filter_map(|v| {
                                            match v {
                                                AnyValue::UInt32(idx) => Some(idx),
                                                _ => None,
                                            }
                                        }).collect();
                                        if !indices.is_empty() {
                                            let indices_ca = UInt32Chunked::from_vec("indices".into(), indices);
                                            match df.take(&indices_ca) {
                                                Ok(group_df) => {
                                                    let objects = dataframe_to_objects(&group_df);
                                                    result_groups.push(Value::Array(objects.into_iter().map(Value::Object).collect()));
                                                }
                                                Err(e) => return Err(dsq_shared::error::operation_error(format!("group_by() take failed: {}", e))),
                                            }
                                        }
                                    }
                                }
                            }
                            // Sort groups by the grouping key for consistency
                            result_groups.sort_by(|a, b| {
                                if let (Value::Array(a_arr), Value::Array(b_arr)) = (a, b) {
                                    if let (Some(Value::Object(a_obj)), Some(Value::Object(b_obj))) = (a_arr.first(), b_arr.first()) {
                                        if let (Some(a_val), Some(b_val)) = (a_obj.get(column.as_str()), b_obj.get(column.as_str())) {
                                            compare_values_for_sorting(a_val, b_val)
                                        } else {
                                            std::cmp::Ordering::Equal
                                        }
                                    } else {
                                        std::cmp::Ordering::Equal
                                    }
                                } else {
                                    std::cmp::Ordering::Equal
                                }
                            });
                            Ok(Value::Array(result_groups))
                        }
                        Err(e) => Err(dsq_shared::error::operation_error(format!("group_by() groups() failed: {}", e))),
                    }
                }
                Err(e) => Err(dsq_shared::error::operation_error(format!("group_by() failed: {}", e))),
            }
        }
        (Value::DataFrame(df), Value::Series(series)) => {
            // Group DataFrame by series values
            // This is more complex - we need to add the series as a column, group by it, then remove it
            let temp_col_name = "__group_by_temp_col";
            let mut df_clone = df.clone();
            let mut temp_series = series.clone();
            temp_series.rename(temp_col_name);
            match df_clone.with_column(temp_series) {
                Ok(df_with_group) => {
                    match df_with_group.group_by([temp_col_name]) {
                        Ok(grouped) => {
                            match grouped.groups() {
                                Ok(groups_df) => {
                                    // groups_df has columns for the grouping keys and a "groups" column with indices
                                    let mut result_groups = Vec::new();
                                    let mut group_keys = Vec::new();
                                    for i in 0..groups_df.height() {
                                        if let Ok(group_indices) = groups_df.column("groups") {
                                            if let Ok(AnyValue::List(list)) = group_indices.get(i) {
                                                let indices: Vec<u32> = list.iter().filter_map(|v| {
                                                    match v {
                                                        AnyValue::UInt32(idx) => Some(idx),
                                                        _ => None,
                                                    }
                                                }).collect();
                                                if !indices.is_empty() {
                                                    let indices_ca = UInt32Chunked::from_vec("indices".into(), indices);
                                                    match df_with_group.take(&indices_ca) {
                                                        Ok(group_df) => {
                                                            // Get the key
                                                            let key = if let Ok(temp_series) = group_df.column(temp_col_name) {
                                                                temp_series.get(0).map(|v| value_from_any_value(v).unwrap_or(Value::Null)).unwrap_or(Value::Null)
                                                            } else {
                                                                Value::Null
                                                            };
                                                            group_keys.push(key);
                                                            // Remove the temp column
                                                            if let Ok(df_clean) = group_df.drop(temp_col_name) {
                                                                let objects = dataframe_to_objects(&df_clean);
                                                                result_groups.push(Value::Array(objects.into_iter().map(Value::Object).collect()));
                                                            } else {
                                                                result_groups.push(Value::Array(vec![]));
                                                            }
                                                        }
                                                        Err(e) => {
                                                            group_keys.push(Value::Null);
                                                            result_groups.push(Value::Array(vec![]));
                                                            return Err(dsq_shared::error::operation_error(format!("group_by() take failed: {}", e)));
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    // Sort groups by key
                                    let mut indices: Vec<usize> = (0..result_groups.len()).collect();
                                    indices.sort_by(|&i, &j| compare_values_for_sorting(&group_keys[i], &group_keys[j]));
                                    let sorted_groups = indices.into_iter().map(|i| result_groups[i].clone()).collect();
                                    Ok(Value::Array(sorted_groups))
                                }
                                Err(e) => Err(dsq_shared::error::operation_error(format!("group_by() groups() failed: {}", e))),
                            }
                        }
                        Err(e) => Err(dsq_shared::error::operation_error(format!("group_by() failed: {}", e))),
                    }
                }
                Err(e) => Err(dsq_shared::error::operation_error(format!("group_by() failed to add temp column: {}", e))),
            }
        }
        _ => Err(dsq_shared::error::operation_error("group_by() requires (array, string) or (dataframe, string/series)")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}





fn builtin_url_parse(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("url_parse() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            match Url::parse(s) {
                Ok(url) => {
                    let mut result = HashMap::new();
                    result.insert("scheme".to_string(), Value::String(url.scheme().to_string()));
                    result.insert("username".to_string(), Value::String(url.username().to_string()));
                    result.insert("password".to_string(), url.password().map(|p| Value::String(p.to_string())).unwrap_or(Value::Null));
                    result.insert("host".to_string(), url.host_str().map(|h| Value::String(h.to_string())).unwrap_or(Value::Null));
                    result.insert("port".to_string(), url.port().map(|p| Value::Int(p as i64)).unwrap_or(Value::Null));
                    result.insert("path".to_string(), Value::String(url.path().to_string()));
                    result.insert("query".to_string(), url.query().map(|q| Value::String(q.to_string())).unwrap_or(Value::Null));
                    result.insert("fragment".to_string(), url.fragment().map(|f| Value::String(f.to_string())).unwrap_or(Value::Null));
                    Ok(Value::Object(result))
                }
                Err(_) => Err(dsq_shared::error::operation_error("url_parse() invalid URL")),
            }
        }
        Value::Array(arr) => {
            let parsed: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => builtin_url_parse(&[Value::String(s.clone())]),
                    _ => Err(dsq_shared::error::operation_error("url_parse() requires string elements in array")),
                }
            }).collect();
            Ok(Value::Array(parsed?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let parsed_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                match Url::parse(s) {
                                    Ok(url) => {
                                        let mut result = HashMap::new();
                                        result.insert("scheme".to_string(), Value::String(url.scheme().to_string()));
                                        result.insert("username".to_string(), Value::String(url.username().to_string()));
                                        result.insert("password".to_string(), url.password().map(|p| Value::String(p.to_string())).unwrap_or(Value::Null));
                                        result.insert("host".to_string(), url.host_str().map(|h| Value::String(h.to_string())).unwrap_or(Value::Null));
                                        result.insert("port".to_string(), url.port().map(|p| Value::Int(p as i64)).unwrap_or(Value::Null));
                                        result.insert("path".to_string(), Value::String(url.path().to_string()));
                                        result.insert("query".to_string(), url.query().map(|q| Value::String(q.to_string())).unwrap_or(Value::Null));
                                        result.insert("fragment".to_string(), url.fragment().map(|f| Value::String(f.to_string())).unwrap_or(Value::Null));
                                        Some(Cow::Owned(serde_json::to_string(&Value::Object(result)).unwrap_or("null".to_string())))
                                    }
                                    Err(_) => None,
                                }
                            })
                        }).into_series();
                        let mut s = parsed_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("url_parse() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let parsed_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        match Url::parse(s) {
                            Ok(url) => {
                                let mut result = HashMap::new();
                                result.insert("scheme".to_string(), Value::String(url.scheme().to_string()));
                                result.insert("username".to_string(), Value::String(url.username().to_string()));
                                result.insert("password".to_string(), url.password().map(|p| Value::String(p.to_string())).unwrap_or(Value::Null));
                                result.insert("host".to_string(), url.host_str().map(|h| Value::String(h.to_string())).unwrap_or(Value::Null));
                                result.insert("port".to_string(), url.port().map(|p| Value::Int(p as i64)).unwrap_or(Value::Null));
                                result.insert("path".to_string(), Value::String(url.path().to_string()));
                                result.insert("query".to_string(), url.query().map(|q| Value::String(q.to_string())).unwrap_or(Value::Null));
                                result.insert("fragment".to_string(), url.fragment().map(|f| Value::String(f.to_string())).unwrap_or(Value::Null));
                                Some(Cow::Owned(serde_json::to_string(&Value::Object(result)).unwrap_or("null".to_string())))
                            }
                            Err(_) => None,
                        }
                    })
                }).into_series();
                Ok(Value::Series(parsed_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("url_parse() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_url_extract_domain(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("url_extract_domain() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            match Url::parse(s) {
                Ok(url) => Ok(url.host_str().map(|h| Value::String(h.to_string())).unwrap_or(Value::Null)),
                Err(_) => Ok(Value::Null),
            }
        }
        Value::Array(arr) => {
            let extracted: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => builtin_url_extract_domain(&[Value::String(s.clone())]).unwrap_or(Value::Null),
                    _ => Value::Null,
                }
            }).collect();
            Ok(Value::Array(extracted))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let extracted_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                match Url::parse(s) {
                                    Ok(url) => url.host_str().map(|h| Cow::Owned(h.to_string())),
                                    Err(_) => None,
                                }
                            })
                        }).into_series();
                        let mut s = extracted_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("url_extract_domain() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let extracted_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        match Url::parse(s) {
                            Ok(url) => url.host_str().map(|h| Cow::Owned(h.to_string())),
                            Err(_) => None,
                        }
                    })
                }).into_series();
                Ok(Value::Series(extracted_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("url_extract_domain() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_url_extract_path(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("url_extract_path() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            match Url::parse(s) {
                Ok(url) => Ok(Value::String(url.path().to_string())),
                Err(_) => Ok(Value::Null),
            }
        }
        Value::Array(arr) => {
            let extracted: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => builtin_url_extract_path(&[Value::String(s.clone())]).unwrap_or(Value::Null),
                    _ => Value::Null,
                }
            }).collect();
            Ok(Value::Array(extracted))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let extracted_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| {
                                match Url::parse(s) {
                                    Ok(url) => Cow::Owned(url.path().to_string()),
                                    Err(_) => Cow::Owned("".to_string()),
                                }
                            })
                        }).into_series();
                        let mut s = extracted_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("url_extract_path() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let extracted_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| {
                        match Url::parse(s) {
                            Ok(url) => Cow::Owned(url.path().to_string()),
                            Err(_) => Cow::Owned("".to_string()),
                        }
                    })
                }).into_series();
                Ok(Value::Series(extracted_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("url_extract_path() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_url_extract_query_string(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("url_extract_query_string() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            match Url::parse(s) {
                Ok(url) => Ok(url.query().map(|q| Value::String(q.to_string())).unwrap_or(Value::Null)),
                Err(_) => Ok(Value::Null),
            }
        }
        Value::Array(arr) => {
            let extracted: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => builtin_url_extract_query_string(&[Value::String(s.clone())]).unwrap_or(Value::Null),
                    _ => Value::Null,
                }
            }).collect();
            Ok(Value::Array(extracted))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let extracted_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                match Url::parse(s) {
                                    Ok(url) => url.query().map(|q| Cow::Owned(q.to_string())),
                                    Err(_) => None,
                                }
                            })
                        }).into_series();
                        let mut s = extracted_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("url_extract_query_string() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let extracted_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        match Url::parse(s) {
                            Ok(url) => url.query().map(|q| Cow::Owned(q.to_string())),
                            Err(_) => None,
                        }
                    })
                }).into_series();
                Ok(Value::Series(extracted_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("url_extract_query_string() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_url_strip_fragment(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("url_strip_fragment() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            match Url::parse(s) {
                Ok(mut url) => {
                    url.set_fragment(None);
                    Ok(Value::String(url.to_string()))
                }
                Err(_) => {
                    // If it's not a valid URL, try simple string manipulation
                    if let Some(pos) = s.find('#') {
                        Ok(Value::String(s[..pos].to_string()))
                    } else {
                        Ok(Value::String(s.clone()))
                    }
                }
            }
        }
        Value::Array(arr) => {
            let stripped: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => builtin_url_strip_fragment(&[Value::String(s.clone())]),
                    _ => Err(dsq_shared::error::operation_error("url_strip_fragment() requires string elements in array")),
                }
            }).collect();
            Ok(Value::Array(stripped?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let stripped_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                match Url::parse(s) {
                                    Ok(mut url) => {
                                        url.set_fragment(None);
                                        Some(Cow::Owned(url.to_string()))
                                    }
                                    Err(_) => {
                                        if let Some(pos) = s.find('#') {
                                            Some(Cow::Owned(s[..pos].to_string()))
                                        } else {
                                            Some(Cow::Owned(s.to_string()))
                                        }
                                    }
                                }
                            })
                        }).into_series();
                        let mut s = stripped_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("url_strip_fragment() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let stripped_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        match Url::parse(s) {
                            Ok(mut url) => {
                                url.set_fragment(None);
                                Some(Cow::Owned(url.to_string()))
                            }
                            Err(_) => {
                                if let Some(pos) = s.find('#') {
                                    Some(Cow::Owned(s[..pos].to_string()))
                                } else {
                                    Some(Cow::Owned(s.to_string()))
                                }
                            }
                        }
                    })
                }).into_series();
                Ok(Value::Series(stripped_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("url_strip_fragment() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_url_set_protocol(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("url_set_protocol() expects 2 arguments"));
    }

    let protocol = match &args[1] {
        Value::String(s) => s.clone(),
        _ => return Err(dsq_shared::error::operation_error("url_set_protocol() second argument must be a string")),
    };

    match &args[0] {
        Value::String(s) => {
            match Url::parse(s) {
                Ok(mut url) => {
                    url.set_scheme(&protocol).map_err(|_| dsq_shared::error::operation_error("Invalid protocol"))?;
                    Ok(Value::String(url.to_string()))
                }
                Err(_) => Ok(Value::String(s.clone())), // Return original if not a valid URL
            }
        }
        Value::Array(arr) => {
            let set: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => builtin_url_set_protocol(&[Value::String(s.clone()), Value::String(protocol.clone())]),
                    _ => Err(dsq_shared::error::operation_error("url_set_protocol() requires string elements in array")),
                }
            }).collect();
            Ok(Value::Array(set?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let set_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                match Url::parse(s) {
                                    Ok(mut url) => {
                                        url.set_scheme(&protocol).ok()?;
                                        Some(Cow::Owned(url.to_string()))
                                    }
                                    Err(_) => Some(Cow::Owned(s.to_string())),
                                }
                            })
                        }).into_series();
                        let mut s = set_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("url_set_protocol() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let set_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        match Url::parse(s) {
                            Ok(mut url) => {
                                url.set_scheme(&protocol).ok()?;
                                Some(Cow::Owned(url.to_string()))
                            }
                            Err(_) => Some(Cow::Owned(s.to_string())),
                        }
                    })
                }).into_series();
                Ok(Value::Series(set_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("url_set_protocol() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_url_set_domain(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("url_set_domain() expects 2 arguments"));
    }

    let new_domain = match &args[1] {
        Value::String(s) => s.clone(),
        _ => return Err(dsq_shared::error::operation_error("url_set_domain() second argument must be a string")),
    };

    match &args[0] {
        Value::String(s) => {
            match Url::parse(s) {
                Ok(mut url) => {
                    url.set_host(Some(&new_domain)).map_err(|_| dsq_shared::error::operation_error("Invalid domain"))?;
                    Ok(Value::String(url.to_string()))
                }
                Err(_) => Ok(Value::String(s.clone())), // Return original if not a valid URL
            }
        }
        Value::Array(arr) => {
            let set: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => builtin_url_set_domain(&[Value::String(s.clone()), Value::String(new_domain.clone())]),
                    _ => Err(dsq_shared::error::operation_error("url_set_domain() requires string elements in array")),
                }
            }).collect();
            Ok(Value::Array(set?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let set_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                match Url::parse(s) {
                                    Ok(mut url) => {
                                        url.set_host(Some(&new_domain)).ok()?;
                                        Some(Cow::Owned(url.to_string()))
                                    }
                                    Err(_) => Some(Cow::Owned(s.to_string())),
                                }
                            })
                        }).into_series();
                        let mut s = set_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("url_set_domain() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let set_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        match Url::parse(s) {
                            Ok(mut url) => {
                                url.set_host(Some(&new_domain)).ok()?;
                                Some(Cow::Owned(url.to_string()))
                            }
                            Err(_) => Some(Cow::Owned(s.to_string())),
                        }
                    })
                }).into_series();
                Ok(Value::Series(set_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("url_set_domain() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_url_set_domain_without_www(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("url_set_domain_without_www() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            match Url::parse(s) {
                Ok(mut url) => {
                    if let Some(host) = url.host_str() {
                        let new_host = if host.starts_with("www.") {
                            host[4..].to_string()
                        } else {
                            host.to_string()
                        };
                        url.set_host(Some(&new_host)).map_err(|_| dsq_shared::error::operation_error("Invalid domain"))?;
                        Ok(Value::String(url.to_string()))
                    } else {
                        Ok(Value::String(s.clone()))
                    }
                }
                Err(_) => Ok(Value::String(s.clone())), // Return original if not a valid URL
            }
        }
        Value::Array(arr) => {
            let set: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => builtin_url_set_domain_without_www(&[Value::String(s.clone())]),
                    _ => Err(dsq_shared::error::operation_error("url_set_domain_without_www() requires string elements in array")),
                }
            }).collect();
            Ok(Value::Array(set?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let set_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                match Url::parse(s) {
                                    Ok(mut url) => {
                                        if let Some(host) = url.host_str() {
                                            let new_host = if host.starts_with("www.") {
                                                host[4..].to_string()
                                            } else {
                                                host.to_string()
                                            };
                                            url.set_host(Some(&new_host)).ok()?;
                                            Some(Cow::Owned(url.to_string()))
                                        } else {
                                            Some(Cow::Owned(s.to_string()))
                                        }
                                    }
                                    Err(_) => Some(Cow::Owned(s.to_string())),
                                }
                            })
                        }).into_series();
                        let mut s = set_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("url_set_domain_without_www() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let set_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        match Url::parse(s) {
                            Ok(mut url) => {
                                if let Some(host) = url.host_str() {
                                    let new_host = if host.starts_with("www.") {
                                        host[4..].to_string()
                                    } else {
                                        host.to_string()
                                    };
                                    url.set_host(Some(&new_host)).ok()?;
                                    Some(Cow::Owned(url.to_string()))
                                } else {
                                    Some(Cow::Owned(s.to_string()))
                                }
                            }
                            Err(_) => Some(Cow::Owned(s.to_string())),
                        }
                    })
                }).into_series();
                Ok(Value::Series(set_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("url_set_domain_without_www() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_split(args: &[Value]) -> Result<Value> {
    if args.len() < 1 || args.len() > 2 {
        return Err(dsq_shared::error::operation_error("split() expects 1 or 2 arguments"));
    }

    let separator = if args.len() == 2 {
        match &args[1] {
            Value::String(s) => s.clone(),
            _ => return Err(dsq_shared::error::operation_error("split() separator must be a string")),
        }
    } else {
        " ".to_string() // default separator is whitespace
    };

    match &args[0] {
        Value::String(s) => {
            let parts: Vec<Value> = if separator.is_empty() {
                s.chars().map(|c| Value::String(c.to_string())).collect()
            } else {
                s.split(&separator).map(|part| Value::String(part.to_string())).collect()
            };
            Ok(Value::Array(parts))
        }
        Value::Array(arr) => {
            let split_arrays: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => {
                        let parts: Vec<Value> = if separator.is_empty() {
                            s.chars().map(|c| Value::String(c.to_string())).collect()
                        } else {
                            s.split(&separator).map(|part| Value::String(part.to_string())).collect()
                        };
                        Ok(Value::Array(parts))
                    }
                    _ => Err(dsq_shared::error::operation_error("split() requires string elements in array")),
                }
            }).collect();
            Ok(Value::Array(split_arrays?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let split_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                let parts: Vec<String> = if separator.is_empty() {
                                    s.chars().map(|c| c.to_string()).collect()
                                } else {
                                    s.split(&separator).map(|part| part.to_string()).collect()
                                };
                                Some(Cow::Owned(serde_json::to_string(&Value::Array(parts.into_iter().map(Value::String).collect())).unwrap_or("null".to_string())))
                            })
                        }).into_series();
                        let mut s = split_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("split() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let split_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        let parts: Vec<String> = if separator.is_empty() {
                            s.chars().map(|c| c.to_string()).collect()
                        } else {
                            s.split(&separator).map(|part| part.to_string()).collect()
                        };
                        Some(Cow::Owned(serde_json::to_string(&Value::Array(parts.into_iter().map(Value::String).collect())).unwrap_or("null".to_string())))
                    })
                }).into_series();
                Ok(Value::Series(split_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("split() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_dos2unix(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("dos2unix() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            let converted = s.replace("\r\n", "\n");
            Ok(Value::String(converted))
        }
        Value::Array(arr) => {
            let converted: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Ok(Value::String(s.replace("\r\n", "\n"))),
                    _ => Err(dsq_shared::error::operation_error("dos2unix() requires string elements in array")),
                }
            }).collect();
            Ok(Value::Array(converted?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let converted_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.replace("\r\n", "\n")))
                        }).into_series();
                        let mut s = converted_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("dos2unix() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let converted_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.replace("\r\n", "\n")))
                }).into_series();
                Ok(Value::Series(converted_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("dos2unix() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_coalesce(args: &[Value]) -> Result<Value> {
    for arg in args {
        if !matches!(arg, Value::Null) {
            return Ok(arg.clone());
        }
    }
    Ok(Value::Null)
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}




fn builtin_url_set_path(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("url_set_path() expects 2 arguments"));
    }

    let new_path = match &args[1] {
        Value::String(s) => s.clone(),
        _ => return Err(dsq_shared::error::operation_error("url_set_path() second argument must be a string")),
    };

    match &args[0] {
        Value::String(s) => {
            match Url::parse(s) {
                Ok(mut url) => {
                    url.set_path(&new_path);
                    Ok(Value::String(url.to_string()))
                }
                Err(_) => Ok(Value::String(s.clone())), // Return original if not a valid URL
            }
        }
        Value::Array(arr) => {
            let set: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => builtin_url_set_path(&[Value::String(s.clone()), Value::String(new_path.clone())]),
                    _ => Err(dsq_shared::error::operation_error("url_set_path() requires string elements in array")),
                }
            }).collect();
            Ok(Value::Array(set?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let set_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                match Url::parse(s) {
                                    Ok(mut url) => {
                                        url.set_path(&new_path);
                                        Some(Cow::Owned(url.to_string()))
                                    }
                                    Err(_) => Some(Cow::Owned(s.to_string())),
                                }
                            })
                        }).into_series();
                        let mut s = set_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("url_set_path() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let set_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        match Url::parse(s) {
                            Ok(mut url) => {
                                url.set_path(&new_path);
                                Some(Cow::Owned(url.to_string()))
                            }
                            Err(_) => Some(Cow::Owned(s.to_string())),
                        }
                    })
                }).into_series();
                Ok(Value::Series(set_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("url_set_path() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_url_extract_protocol(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("url_extract_protocol() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            match Url::parse(s) {
                Ok(url) => Ok(Value::String(url.scheme().to_string())),
                Err(_) => Ok(Value::Null),
            }
        }
        Value::Array(arr) => {
            let extracted: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => builtin_url_extract_protocol(&[Value::String(s.clone())]).unwrap_or(Value::Null),
                    _ => Value::Null,
                }
            }).collect();
            Ok(Value::Array(extracted))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let extracted_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                match Url::parse(s) {
                                    Ok(url) => Some(Cow::Owned(url.scheme().to_string())),
                                    Err(_) => None,
                                }
                            })
                        }).into_series();
                        let mut s = extracted_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("url_extract_protocol() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let extracted_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        match Url::parse(s) {
                            Ok(url) => Some(Cow::Owned(url.scheme().to_string())),
                            Err(_) => None,
                        }
                    })
                }).into_series();
                Ok(Value::Series(extracted_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("url_extract_protocol() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_url_extract_port(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("url_extract_port() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            match Url::parse(s) {
                Ok(url) => Ok(url.port().map(|p| Value::Int(p as i64)).unwrap_or(Value::Null)),
                Err(_) => Ok(Value::Null),
            }
        }
        Value::Array(arr) => {
            let extracted: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => builtin_url_extract_port(&[Value::String(s.clone())]).unwrap_or(Value::Null),
                    _ => Value::Null,
                }
            }).collect();
            Ok(Value::Array(extracted))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let extracted_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                match Url::parse(s) {
                                    Ok(url) => url.port().map(|p| Cow::Owned(p.to_string())),
                                    Err(_) => None,
                                }
                            })
                        }).into_series();
                        let mut s = extracted_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("url_extract_port() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let extracted_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        match Url::parse(s) {
                            Ok(url) => url.port().map(|p| Cow::Owned(p.to_string())),
                            Err(_) => None,
                        }
                    })
                }).into_series();
                Ok(Value::Series(extracted_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("url_extract_port() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_url_strip_query_string(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("url_strip_query_string() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            match Url::parse(s) {
                Ok(mut url) => {
                    url.set_query(None);
                    Ok(Value::String(url.to_string()))
                }
                Err(_) => {
                    // If not a valid URL, try simple string manipulation
                    if let Some(pos) = s.find('?') {
                        Ok(Value::String(s[..pos].to_string()))
                    } else {
                        Ok(Value::String(s.clone()))
                    }
                }
            }
        }
        Value::Array(arr) => {
            let stripped: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => builtin_url_strip_query_string(&[Value::String(s.clone())]),
                    _ => Err(dsq_shared::error::operation_error("url_strip_query_string() requires string elements in array")),
                }
            }).collect();
            Ok(Value::Array(stripped?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let stripped_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                match Url::parse(s) {
                                    Ok(mut url) => {
                                        url.set_query(None);
                                        Some(Cow::Owned(url.to_string()))
                                    }
                                    Err(_) => {
                                        if let Some(pos) = s.find('?') {
                                            Some(Cow::Owned(s[..pos].to_string()))
                                        } else {
                                            Some(Cow::Owned(s.to_string()))
                                        }
                                    }
                                }
                            })
                        }).into_series();
                        let mut s = stripped_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("url_strip_query_string() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let stripped_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        match Url::parse(s) {
                            Ok(mut url) => {
                                url.set_query(None);
                                Some(Cow::Owned(url.to_string()))
                            }
                            Err(_) => {
                                if let Some(pos) = s.find('?') {
                                    Some(Cow::Owned(s[..pos].to_string()))
                                } else {
                                    Some(Cow::Owned(s.to_string()))
                                }
                            }
                        }
                    })
                }).into_series();
                Ok(Value::Series(stripped_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("url_strip_query_string() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_url_strip_port_if_default(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("url_strip_port_if_default() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            match Url::parse(s) {
                Ok(mut url) => {
                    if let Some(port) = url.port() {
                        let scheme = url.scheme();
                        let is_default = match scheme {
                            "http" => port == 80,
                            "https" => port == 443,
                            "ftp" => port == 21,
                            "ssh" => port == 22,
                            "telnet" => port == 23,
                            _ => false,
                        };
                        if is_default {
                            url.set_port(None).unwrap();
                        }
                    }
                    Ok(Value::String(url.to_string()))
                }
                Err(_) => Ok(Value::String(s.clone())), // Return original if not a valid URL
            }
        }
        Value::Array(arr) => {
            let stripped: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => builtin_url_strip_port_if_default(&[Value::String(s.clone())]),
                    _ => Err(dsq_shared::error::operation_error("url_strip_port_if_default() requires string elements in array")),
                }
            }).collect();
            Ok(Value::Array(stripped?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let stripped_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                match Url::parse(s) {
                                    Ok(mut url) => {
                                        if let Some(port) = url.port() {
                                            let scheme = url.scheme();
                                            let is_default = match scheme {
                                                "http" => port == 80,
                                                "https" => port == 443,
                                                "ftp" => port == 21,
                                                "ssh" => port == 22,
                                                "telnet" => port == 23,
                                                _ => false,
                                            };
                                            if is_default {
                                                url.set_port(None).unwrap();
                                            }
                                        }
                                        Some(Cow::Owned(url.to_string()))
                                    }
                                    Err(_) => Some(Cow::Owned(s.to_string())),
                                }
                            })
                        }).into_series();
                        let mut s = stripped_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("url_strip_port_if_default() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let stripped_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        match Url::parse(s) {
                            Ok(mut url) => {
                                if let Some(port) = url.port() {
                                    let scheme = url.scheme();
                                    let is_default = match scheme {
                                        "http" => port == 80,
                                        "https" => port == 443,
                                        "ftp" => port == 21,
                                        "ssh" => port == 22,
                                        "telnet" => port == 23,
                                        _ => false,
                                    };
                                    if is_default {
                                        url.set_port(None).unwrap();
                                    }
                                }
                                Some(Cow::Owned(url.to_string()))
                            }
                            Err(_) => Some(Cow::Owned(s.to_string())),
                        }
                    })
                }).into_series();
                Ok(Value::Series(stripped_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("url_strip_port_if_default() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_url_strip_port(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("url_strip_port() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            match Url::parse(s) {
                Ok(mut url) => {
                    url.set_port(None).unwrap();
                    Ok(Value::String(url.to_string()))
                }
                Err(_) => Ok(Value::String(s.clone())), // Return original if not a valid URL
            }
        }
        Value::Array(arr) => {
            let stripped: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => builtin_url_strip_port(&[Value::String(s.clone())]),
                    _ => Err(dsq_shared::error::operation_error("url_strip_port() requires string elements in array")),
                }
            }).collect();
            Ok(Value::Array(stripped?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let stripped_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                match Url::parse(s) {
                                    Ok(mut url) => {
                                        url.set_port(None).unwrap();
                                        Some(Cow::Owned(url.to_string()))
                                    }
                                    Err(_) => Some(Cow::Owned(s.to_string())),
                                }
                            })
                        }).into_series();
                        let mut s = stripped_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("url_strip_port() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let stripped_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        match Url::parse(s) {
                            Ok(mut url) => {
                                url.set_port(None).unwrap();
                                Some(Cow::Owned(url.to_string()))
                            }
                            Err(_) => Some(Cow::Owned(s.to_string())),
                        }
                    })
                }).into_series();
                Ok(Value::Series(stripped_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("url_strip_port() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_url_strip_protocol(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("url_strip_protocol() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            match Url::parse(s) {
                Ok(url) => {
                    let mut result = String::new();
                    if let Some(host) = url.host_str() {
                        result.push_str("//");
                        result.push_str(host);
                        if let Some(port) = url.port() {
                            result.push(':');
                            result.push_str(&port.to_string());
                        }
                    }
                    result.push_str(url.path());
                    if let Some(query) = url.query() {
                        result.push('?');
                        result.push_str(query);
                    }
                    if let Some(fragment) = url.fragment() {
                        result.push('#');
                        result.push_str(fragment);
                    }
                    Ok(Value::String(result))
                }
                Err(_) => Ok(Value::String(s.clone())), // Return original if not a valid URL
            }
        }
        Value::Array(arr) => {
            let stripped: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => builtin_url_strip_protocol(&[Value::String(s.clone())]),
                    _ => Err(dsq_shared::error::operation_error("url_strip_protocol() requires string elements in array")),
                }
            }).collect();
            Ok(Value::Array(stripped?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let stripped_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                match Url::parse(s) {
                                    Ok(url) => {
                                        let mut result = String::new();
                                        if let Some(host) = url.host_str() {
                                            result.push_str("//");
                                            result.push_str(host);
                                            if let Some(port) = url.port() {
                                                result.push(':');
                                                result.push_str(&port.to_string());
                                            }
                                        }
                                        result.push_str(url.path());
                                        if let Some(query) = url.query() {
                                            result.push('?');
                                            result.push_str(query);
                                        }
                                        if let Some(fragment) = url.fragment() {
                                            result.push('#');
                                            result.push_str(fragment);
                                        }
                                        Some(Cow::Owned(result))
                                    }
                                    Err(_) => Some(Cow::Owned(s.to_string())),
                                }
                            })
                        }).into_series();
                        let mut s = stripped_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("url_strip_protocol() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let stripped_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        match Url::parse(s) {
                            Ok(url) => {
                                let mut result = String::new();
                                if let Some(host) = url.host_str() {
                                    result.push_str("//");
                                    result.push_str(host);
                                    if let Some(port) = url.port() {
                                        result.push(':');
                                        result.push_str(&port.to_string());
                                    }
                                }
                                result.push_str(url.path());
                                if let Some(query) = url.query() {
                                    result.push('?');
                                    result.push_str(query);
                                }
                                if let Some(fragment) = url.fragment() {
                                    result.push('#');
                                    result.push_str(fragment);
                                }
                                Some(Cow::Owned(result))
                            }
                            Err(_) => Some(Cow::Owned(s.to_string())),
                        }
                    })
                }).into_series();
                Ok(Value::Series(stripped_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("url_strip_protocol() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_url_set_query_string(args: &[Value]) -> Result<Value> {
    if args.len() != 3 {
        return Err(dsq_shared::error::operation_error("url_set_query_string() expects 3 arguments"));
    }

    let key = match &args[1] {
        Value::String(s) => s.clone(),
        _ => return Err(dsq_shared::error::operation_error("url_set_query_string() second argument must be a string")),
    };

    let value = match &args[2] {
        Value::String(s) => s.clone(),
        _ => return Err(dsq_shared::error::operation_error("url_set_query_string() third argument must be a string")),
    };

    match &args[0] {
        Value::String(s) => {
            match Url::parse(s) {
                Ok(mut url) => {
                    let mut query_pairs = url.query_pairs().map(|(k, v)| (k.to_string(), v.to_string())).collect::<Vec<_>>();
                    // Remove existing key if present
                    query_pairs.retain(|(k, _)| k != &key);
                    // Add new key-value pair
                    query_pairs.push((key, value));
                    let new_query = query_pairs.into_iter().map(|(k, v)| format!("{}={}", k, v)).collect::<Vec<_>>().join("&");
                    url.set_query(Some(&new_query));
                    Ok(Value::String(url.to_string()))
                }
                Err(_) => Ok(Value::String(s.clone())), // Return original if not a valid URL
            }
        }
        Value::Array(arr) => {
            let set: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => builtin_url_set_query_string(&[Value::String(s.clone()), Value::String(key.clone()), Value::String(value.clone())]),
                    _ => Err(dsq_shared::error::operation_error("url_set_query_string() requires string elements in array")),
                }
            }).collect();
            Ok(Value::Array(set?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let set_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                match Url::parse(s) {
                                    Ok(mut url) => {
                                        let mut query_pairs = url.query_pairs().map(|(k, v)| (k.to_string(), v.to_string())).collect::<Vec<_>>();
                                        // Remove existing key if present
                                        query_pairs.retain(|(k, _)| k != &key);
                                        // Add new key-value pair
                                        query_pairs.push((key.clone(), value.clone()));
                                        let new_query = query_pairs.into_iter().map(|(k, v)| format!("{}={}", k, v)).collect::<Vec<_>>().join("&");
                                        url.set_query(Some(&new_query));
                                        Some(Cow::Owned(url.to_string()))
                                    }
                                    Err(_) => Some(Cow::Owned(s.to_string())),
                                }
                            })
                        }).into_series();
                        let mut s = set_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("url_set_query_string() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let set_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        match Url::parse(s) {
                            Ok(mut url) => {
                                let mut query_pairs = url.query_pairs().map(|(k, v)| (k.to_string(), v.to_string())).collect::<Vec<_>>();
                                // Remove existing key if present
                                query_pairs.retain(|(k, _)| k != &key);
                                // Add new key-value pair
                                query_pairs.push((key.clone(), value.clone()));
                                let new_query = query_pairs.into_iter().map(|(k, v)| format!("{}={}", k, v)).collect::<Vec<_>>().join("&");
                                url.set_query(Some(&new_query));
                                Some(Cow::Owned(url.to_string()))
                            }
                            Err(_) => Some(Cow::Owned(s.to_string())),
                        }
                    })
                }).into_series();
                Ok(Value::Series(set_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("url_set_query_string() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_url_set_port(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("url_set_port() expects 2 arguments"));
    }

    let port = match &args[1] {
        Value::Int(i) => *i as u16,
        Value::String(s) => s.parse::<u16>().map_err(|_| dsq_shared::error::operation_error("Invalid port number"))?,
        _ => return Err(dsq_shared::error::operation_error("url_set_port() second argument must be an integer or string")),
    };

    match &args[0] {
        Value::String(s) => {
            match Url::parse(s) {
                Ok(mut url) => {
                    url.set_port(Some(port)).map_err(|_| dsq_shared::error::operation_error("Invalid port"))?;
                    Ok(Value::String(url.to_string()))
                }
                Err(_) => Ok(Value::String(s.clone())), // Return original if not a valid URL
            }
        }
        Value::Array(arr) => {
            let set: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => builtin_url_set_port(&[Value::String(s.clone()), args[1].clone()]),
                    _ => Err(dsq_shared::error::operation_error("url_set_port() requires string elements in array")),
                }
            }).collect();
            Ok(Value::Array(set?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let set_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                match Url::parse(s) {
                                    Ok(mut url) => {
                                        url.set_port(Some(port)).ok()?;
                                        Some(Cow::Owned(url.to_string()))
                                    }
                                    Err(_) => Some(Cow::Owned(s.to_string())),
                                }
                            })
                        }).into_series();
                        let mut s = set_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("url_set_port() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let set_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        match Url::parse(s) {
                            Ok(mut url) => {
                                url.set_port(Some(port)).ok()?;
                                Some(Cow::Owned(url.to_string()))
                            }
                            Err(_) => Some(Cow::Owned(s.to_string())),
                        }
                    })
                }).into_series();
                Ok(Value::Series(set_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("url_set_port() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

/// Registry of built-in functions
///
/// This struct manages all built-in functions and provides a unified interface
/// for calling them during filter execution.
pub struct BuiltinRegistry {
    functions: HashMap<String, BuiltinFunction>,
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

impl std::fmt::Debug for BuiltinRegistry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BuiltinRegistry {{ functions: {} functions }}", self.functions.len())
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

impl BuiltinRegistry {
    /// Create a new builtin registry with standard functions
    pub fn new() -> Self {
        let mut registry = Self {
            functions: HashMap::new(),
        };

        registry.register_standard_functions();
        registry
    }

    /// Register all standard built-in functions
    fn register_standard_functions(&mut self) {
        // Basic operations
        self.register("length", Arc::new(builtin_length));
        self.register("keys", Arc::new(builtin_keys));
        self.register("has", Arc::new(builtin_has));
        self.register("values", Arc::new(builtin_values));
        self.register("type", Arc::new(builtin_type));
        self.register("empty", Arc::new(builtin_empty));
        self.register("error", Arc::new(builtin_error));

        // Array operations
        self.register("reverse", Arc::new(builtin_reverse));
        self.register("sort", Arc::new(builtin_sort));
        self.register("sort_by", Arc::new(builtin_sort_by));
        self.register("unique", Arc::new(builtin_unique));
        self.register("flatten", Arc::new(builtin_flatten));
        self.register("add", Arc::new(builtin_add));
        self.register("min", Arc::new(builtin_min));
        self.register("max", Arc::new(builtin_max));
        self.register("first", Arc::new(builtin_first));
        self.register("last", Arc::new(builtin_last));
        self.register("array_unshift", Arc::new(builtin_array_unshift));
        self.register("array_shift", Arc::new(builtin_array_shift));
        self.register("array_push", Arc::new(builtin_array_push));
        self.register("array_pop", Arc::new(builtin_array_pop));
        self.register("repeat", Arc::new(builtin_repeat));
        self.register("zip", Arc::new(builtin_zip));
        self.register("transpose", Arc::new(builtin_transpose));

        // String operations
        self.register("tostring", Arc::new(builtin_tostring));
        self.register("tonumber", Arc::new(builtin_tonumber));
        self.register("split", Arc::new(builtin_split));
        self.register("join", Arc::new(builtin_join_strings));
        self.register("concat", Arc::new(builtin_concat));
        self.register("startswith", Arc::new(builtin_startswith));
        self.register("endswith", Arc::new(builtin_endswith));
        self.register("lstrip", Arc::new(builtin_lstrip));
        self.register("rstrip", Arc::new(builtin_rstrip));
        self.register("trim", Arc::new(builtin_trim));
        self.register("tolower", Arc::new(builtin_tolower));
        self.register("toupper", Arc::new(builtin_toupper));

        self.register("replace", Arc::new(builtin_replace));
        self.register("contains", Arc::new(builtin_contains));
        self.register("dos2unix", Arc::new(builtin_dos2unix));
        self.register("coalesce", Arc::new(builtin_coalesce));
        self.register("tojson", Arc::new(builtin_tojson));
        self.register("base32_encode", Arc::new(builtin_base32_encode));
        self.register("base32_decode", Arc::new(builtin_base32_decode));
        self.register("base58_encode", Arc::new(builtin_base58_encode));
        self.register("base58_decode", Arc::new(builtin_base58_decode));
        self.register("base64_encode", Arc::new(builtin_base64_encode));
        self.register("base64_decode", Arc::new(builtin_base64_decode));
        self.register("sha512", Arc::new(builtin_sha512));
        self.register("sha256", Arc::new(builtin_sha256));
        self.register("sha1", Arc::new(builtin_sha1));
        self.register("SHA1", Arc::new(builtin_sha1));
        self.register("md5", Arc::new(builtin_md5));
        self.register("snake_case", Arc::new(builtin_snake_case));
        self.register("camel_case", Arc::new(builtin_camel_case));
        self.register("to_ascii", Arc::new(builtin_to_ascii));
        self.register("is_valid_utf8", Arc::new(builtin_is_valid_utf8));

        // Math operations
        self.register("abs", Arc::new(builtin_abs));
        self.register("add", Arc::new(builtin_add));
        self.register("floor", Arc::new(builtin_floor));
        self.register("roundup", Arc::new(builtin_roundup));
        self.register("ceil", Arc::new(builtin_ceil));
        // self.register("round", Arc::new(builtin_round)); // Commented out due to Polars API changes
        self.register("mround", Arc::new(builtin_mround));
        // self.register("sqrt", Arc::new(builtin_sqrt)); // Commented out due to Polars API changes
        self.register("pow", Arc::new(builtin_pow));
        self.register("atan", Arc::new(builtin_atan));
        self.register("acos", Arc::new(builtin_acos));
        self.register("asin", Arc::new(builtin_asin));
        self.register("sin", Arc::new(builtin_sin));
        self.register("tan", Arc::new(builtin_tan));
        self.register("exp", Arc::new(builtin_exp));
        self.register("rand", Arc::new(builtin_rand));
        self.register("randarray", Arc::new(builtin_randarray));
        self.register("randbetween", Arc::new(builtin_randbetween));
        self.register("pi", Arc::new(builtin_pi));

          // DataFrame operations
        self.register("columns", Arc::new(builtin_columns));
        self.register("shape", Arc::new(builtin_shape));
        self.register("dtypes", Arc::new(builtin_dtypes));
        // self.register("head", Arc::new(builtin_head)); // Commented out due to Polars API changes
        // self.register("tail", Arc::new(builtin_tail)); // Commented out due to Polars API changes
        // self.register("sample", Arc::new(builtin_sample)); // Commented out due to Polars API changes
        self.register("group_by", Arc::new(builtin_group_by));
        self.register("pivot", Arc::new(builtin_pivot));
        // self.register("melt", Arc::new(builtin_melt));

        // Statistical operations
        self.register("mean", Arc::new(builtin_mean));
        self.register("avg", Arc::new(builtin_mean));
        self.register("median", Arc::new(builtin_median));
        // self.register("quartile", Arc::new(builtin_quartile));
        // self.register("percentile", Arc::new(builtin_percentile));
        self.register("std", Arc::new(builtin_std));
        self.register("stdev_p", Arc::new(builtin_stdev_p));
        self.register("stdev_s", Arc::new(builtin_stdev_s));
        self.register("var", Arc::new(builtin_var));
        // self.register("correl", Arc::new(builtin_correl));
        self.register("sum", Arc::new(builtin_sum));
        self.register("count", Arc::new(builtin_count));
        // self.register("histogram", Arc::new(builtin_histogram));
        // self.register("avg_ifs", Arc::new(builtin_avg_ifs));
        // self.register("count_if", Arc::new(builtin_count_if));
        // self.register("avg_if", Arc::new(builtin_avg_if));
        // self.register("min_by", Arc::new(builtin_min_by));
        // self.register("max_by", Arc::new(builtin_max_by));

        // Date/time functions
        self.register("month", Arc::new(builtin_month));
        self.register("day", Arc::new(builtin_day));
        self.register("minute", Arc::new(builtin_minute));
        self.register("second", Arc::new(builtin_second));
        self.register("year", Arc::new(builtin_year));
        self.register("hour", Arc::new(builtin_hour));
        self.register("iif", Arc::new(builtin_iif));
        self.register("iferror", Arc::new(builtin_iferror));
        self.register("end_of_month", Arc::new(builtin_end_of_month));
        self.register("mktime", Arc::new(builtin_mktime));
        self.register("date_diff", Arc::new(builtin_date_diff));
        self.register("truncate_date", Arc::new(builtin_truncate_date));
        self.register("today", Arc::new(builtin_today));
        self.register("now", Arc::new(builtin_now));
        self.register("systime", Arc::new(builtin_systime));
        self.register("systime_ns", Arc::new(builtin_systime_ns));
        self.register("systime_int", Arc::new(builtin_systime_int));
        self.register("localtime", Arc::new(builtin_localtime));
        self.register("strftime", Arc::new(builtin_strftime));
        self.register("strflocaltime", Arc::new(builtin_strflocaltime));
        self.register("strptime", Arc::new(builtin_strptime));

        // Utility functions
        self.register("range", Arc::new(builtin_range));
        self.register("select", Arc::new(builtin_select));
        self.register("map", Arc::new(builtin_map));
        self.register("group_by", Arc::new(builtin_group_by));
        self.register("filter", Arc::new(builtin_filter));
        // 
        self.register("del", Arc::new(builtin_del));
        self.register("transform_keys", Arc::new(builtin_transform_keys));
        // self.register("transform_values", Arc::new(builtin_transform_values));
        self.register("unnest", Arc::new(builtin_unnest));
        self.register("fromjson", Arc::new(builtin_fromjson));
        self.register("generate_sequence", Arc::new(builtin_generate_sequence));
        self.register("time_series_range", Arc::new(builtin_time_series_range));
        self.register("group_concat", Arc::new(builtin_group_concat));
        self.register("generate_uuidv4", Arc::new(builtin_generate_uuidv4));
        self.register("generate_uuidv7", Arc::new(builtin_generate_uuidv7));

        // URL functions
        self.register("url_parse", Arc::new(builtin_url_parse));
        self.register("url_extract_domain", Arc::new(builtin_url_extract_domain));
        self.register("url_extract_path", Arc::new(builtin_url_extract_path));
        self.register("url_extract_query_string", Arc::new(builtin_url_extract_query_string));
        self.register("url_extract_protocol", Arc::new(builtin_url_extract_protocol));
        self.register("url_extract_port", Arc::new(builtin_url_extract_port));
        self.register("url_set_protocol", Arc::new(builtin_url_set_protocol));
        self.register("url_set_path", Arc::new(builtin_url_set_path));
        self.register("url_set_domain", Arc::new(builtin_url_set_domain));
        self.register("url_set_domain_without_www", Arc::new(builtin_url_set_domain_without_www));
        self.register("url_set_query_string", Arc::new(builtin_url_set_query_string));
        self.register("url_set_port", Arc::new(builtin_url_set_port));
        self.register("url_strip_fragment", Arc::new(builtin_url_strip_fragment));
        self.register("url_strip_query_string", Arc::new(builtin_url_strip_query_string));
        self.register("url_strip_port", Arc::new(builtin_url_strip_port));
        self.register("url_strip_port_if_default", Arc::new(builtin_url_strip_port_if_default));
        self.register("url_strip_protocol", Arc::new(builtin_url_strip_protocol));
        self.register("url_extract_domain_without_www", Arc::new(builtin_url_extract_domain_without_www));
    }

    /// Register a built-in function
    pub fn register(&mut self, name: impl Into<String>, func: BuiltinFunction) {
        self.functions.insert(name.into(), func);
    }

    /// Check if a function exists
    pub fn has_function(&self, name: &str) -> bool {
        self.functions.contains_key(name)
    }

    /// Call a built-in function
    pub fn call_function(&self, name: &str, args: &[Value]) -> Result<Value> {
        if let Some(func) = self.functions.get(name) {
            func(args)
        } else {
            Err(dsq_shared::error::operation_error(format!("built-in function '{}'", name)))
        }
    }

    /// Get the number of registered functions
    pub fn function_count(&self) -> usize {
        self.functions.len()
    }

    /// Get all function names
    pub fn function_names(&self) -> Vec<String> {
        self.functions.keys().cloned().collect()
    }

    /// Get a built-in function by name
    pub fn get_function(&self, name: &str) -> Option<BuiltinFunction> {
        self.functions.get(name).cloned()
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

impl Default for BuiltinRegistry {
    fn default() -> Self {
        Self::new()
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}



// Built-in function implementations

fn builtin_length(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("length() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) => Ok(Value::Int(arr.len() as i64)),
        Value::String(s) => Ok(Value::Int(s.chars().count() as i64)),
        Value::Object(obj) => Ok(Value::Int(obj.len() as i64)),
        Value::DataFrame(df) => Ok(Value::Int(df.height() as i64)),
        Value::Series(s) => Ok(Value::Int(s.len() as i64)),
        Value::Null => Ok(Value::Int(0)),
        _ => Ok(Value::Int(1)),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_keys(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("keys() expects 1 argument"));
    }

    match &args[0] {
        Value::Object(obj) => {
            let keys: Vec<Value> = obj.keys().map(|k| Value::String(k.clone())).collect();
            Ok(Value::Array(keys))
        }
        Value::Array(arr) => {
            let indices: Vec<Value> = (0..arr.len()).map(|i| Value::Int(i as i64)).collect();
            Ok(Value::Array(indices))
        }
        Value::DataFrame(df) => {
            let columns: Vec<Value> = df.get_column_names()
                .iter()
                .map(|name| Value::String(name.to_string()))
                .collect();
            Ok(Value::Array(columns))
        }
        _ => Ok(Value::Array(Vec::new())),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_has(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("has() expects 2 arguments"));
    }

    let key = match &args[1] {
        Value::String(s) => s,
        _ => return Err(dsq_shared::error::operation_error("has() key must be a string")),
    };

    match &args[0] {
        Value::Object(obj) => Ok(Value::Bool(obj.contains_key(key))),
        _ => Ok(Value::Bool(false)),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_values(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("values() expects 1 argument"));
    }

    match &args[0] {
        Value::Object(obj) => {
            let values: Vec<Value> = obj.values().cloned().collect();
            Ok(Value::Array(values))
        }
        Value::Array(arr) => Ok(Value::Array(arr.clone())),
        _ => Ok(Value::Array(vec![args[0].clone()])),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_type(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("type() expects 1 argument"));
    }

    let type_name = args[0].type_name();
    Ok(Value::String(type_name.to_string()))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_empty(args: &[Value]) -> Result<Value> {
    if !args.is_empty() {
        return Err(dsq_shared::error::operation_error("empty() expects no arguments"));
    }

    Ok(Value::Array(Vec::new()))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_error(args: &[Value]) -> Result<Value> {
    let message = if args.is_empty() {
        "error".to_string()
    } else {
        args[0].to_string()
    };

    Err(dsq_shared::error::operation_error(message))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_reverse(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("reverse() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) => {
            let mut reversed = arr.clone();
            reversed.reverse();
            Ok(Value::Array(reversed))
        }
        Value::String(s) => {
            let reversed: String = s.chars().rev().collect();
            Ok(Value::String(reversed))
        }
        Value::DataFrame(df) => {
            // Reverse the rows of the DataFrame
            let reversed_df = df.reverse();
            Ok(Value::DataFrame(reversed_df))
        }
        Value::Series(series) => {
            // Reverse the series
            let reversed_series = series.reverse();
            Ok(Value::Series(reversed_series))
        }
        _ => Ok(args[0].clone()),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_sort(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("sort() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) => {
            let mut sorted = arr.clone();
            sorted.sort_by(compare_values_for_sorting);
            Ok(Value::Array(sorted))
        }
        Value::DataFrame(df) => {
            // Sort by first column by default
            if let Some(first_col) = df.get_column_names().first() {
                match df.sort([first_col], false, false) {
                    Ok(sorted_df) => Ok(Value::DataFrame(sorted_df)),
                    Err(e) => Err(dsq_shared::error::operation_error(format!("sort() failed: {}", e))),
                }
            } else {
                Ok(args[0].clone())
            }
        }
        Value::Series(series) => {
            // Sort the series
            let sorted_series = series.sort(false);
            Ok(Value::Series(sorted_series))
        }
        _ => Ok(args[0].clone()),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_sort_by(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("sort_by() expects 2 arguments"));
    }

    match (&args[0], &args[1]) {
        (Value::Array(arr), Value::Array(key_arr)) if arr.len() == key_arr.len() => {
            // Sort array by key array
            let mut indices: Vec<usize> = (0..arr.len()).collect();
            indices.sort_by(|&i, &j| compare_values_for_sorting(&key_arr[i], &key_arr[j]));
            let sorted_arr: Vec<Value> = indices.into_iter().map(|i| arr[i].clone()).collect();
            Ok(Value::Array(sorted_arr))
        }
        (Value::Array(arr), Value::String(field)) => {
            // Sort array of objects by field
            let mut key_arr = Vec::new();
            for item in arr {
                if let Value::Object(obj) = item {
                    if let Some(value) = obj.get(field) {
                        key_arr.push(value.clone());
                    } else {
                        key_arr.push(Value::Null);
                    }
                } else {
                    key_arr.push(Value::Null);
                }
            }
            let mut indices: Vec<usize> = (0..arr.len()).collect();
            indices.sort_by(|&i, &j| compare_values_for_sorting(&key_arr[i], &key_arr[j]));
            let sorted_arr: Vec<Value> = indices.into_iter().map(|i| arr[i].clone()).collect();
            Ok(Value::Array(sorted_arr))
        }
        (Value::DataFrame(df), Value::String(column)) => {
            // Sort DataFrame by column name
            match df.sort([column.as_str()], false, false) {
                Ok(sorted_df) => Ok(Value::DataFrame(sorted_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("sort_by() failed: {}", e))),
            }
        }
        (Value::DataFrame(df), Value::Array(keys)) if df.height() == keys.len() => {
            // Sort DataFrame by the provided keys array
            let mut indices: Vec<usize> = (0..keys.len()).collect();
            indices.sort_by(|&i, &j| compare_values_for_sorting(&keys[i], &keys[j]));
            let indices_u32: Vec<u32> = indices.into_iter().map(|i| i as u32).collect();
            let indices_ca = UInt32Chunked::from_vec("indices".into(), indices_u32);
            match df.take(&indices_ca) {
                Ok(sorted_df) => Ok(Value::DataFrame(sorted_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("sort_by() failed: {}", e))),
            }
        }
        (Value::DataFrame(df), Value::Series(series)) => {
            // Sort DataFrame by the provided series
            // Add the series as a temporary column, sort by it, then remove it
            let temp_col_name = "__sort_by_temp_col";
            let mut df_clone = df.clone();
            let mut temp_series = series.clone();
            temp_series.rename(temp_col_name);
            match df_clone.with_column(temp_series) {
                Ok(df_with_sort) => {
                    match df_with_sort.sort([temp_col_name], false, false) {
                        Ok(sorted_df) => {
                            match sorted_df.drop(temp_col_name) {
                                Ok(final_df) => Ok(Value::DataFrame(final_df)),
                                Err(e) => Err(dsq_shared::error::operation_error(format!("sort_by() failed to drop temp column: {}", e))),
                            }
                        }
                        Err(e) => Err(dsq_shared::error::operation_error(format!("sort_by() failed to sort: {}", e))),
                    }
                }
                Err(e) => Err(dsq_shared::error::operation_error(format!("sort_by() failed to add temp column: {}", e))),
            }
        }
        (Value::Series(series), Value::Series(key_series)) => {
            // Sort series by key_series
            let temp_col_name = "__sort_by_temp_col";
            let mut df = DataFrame::new(vec![series.clone()]).map_err(|e| dsq_shared::error::operation_error(format!("sort_by() failed to create df: {}", e)))?;
            let mut temp_series = key_series.clone();
            temp_series.rename(temp_col_name);
            match df.with_column(temp_series) {
                Ok(df_with_sort) => {
                    match df_with_sort.sort([temp_col_name], false, false) {
                        Ok(sorted_df) => {
                            match sorted_df.drop(temp_col_name) {
                                Ok(final_df) => {
                                    if let Some(sorted_series) = final_df.get_columns().first() {
                                        Ok(Value::Series(sorted_series.clone()))
                                    } else {
                                        Ok(Value::Series(series.clone()))
                                    }
                                }
                                Err(e) => Err(dsq_shared::error::operation_error(format!("sort_by() failed to drop temp column: {}", e))),
                            }
                        }
                        Err(e) => Err(dsq_shared::error::operation_error(format!("sort_by() failed to sort: {}", e))),
                    }
                }
                Err(e) => Err(dsq_shared::error::operation_error(format!("sort_by() failed to add temp column: {}", e))),
            }
        }
        _ => Err(dsq_shared::error::operation_error("sort_by() requires (array, array), (array, string), (dataframe, string/array/series), or (series, series)")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_unique(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("unique() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) => {
            let mut unique = Vec::new();
            for item in arr {
                if !unique.contains(item) {
                    unique.push(item.clone());
                }
            }
            Ok(Value::Array(unique))
        }
        Value::DataFrame(df) => {
            // Remove duplicate rows
            match df.unique(None, UniqueKeepStrategy::First, None) {
                Ok(unique_df) => Ok(Value::DataFrame(unique_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("unique() failed: {}", e))),
            }
        }
        _ => Ok(args[0].clone()),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_flatten(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("flatten() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) => {
            let mut flattened = Vec::new();
            for item in arr {
                match item {
                    Value::Array(inner) => flattened.extend(inner.clone()),
                    _ => flattened.push(item.clone()),
                }
            }
            Ok(Value::Array(flattened))
        }
        _ => Ok(args[0].clone()),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_add(args: &[Value]) -> Result<Value> {
    if args.is_empty() {
        return Err(dsq_shared::error::operation_error("add() expects at least 1 argument"));
    }

    // If single argument, handle as before
    if args.len() == 1 {
        return builtin_add_single(args);
    }

    // Multiple arguments: sum them all
    builtin_add_multiple(args)
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_add_single(args: &[Value]) -> Result<Value> {
    match &args[0] {
        Value::Array(arr) => {
            if arr.is_empty() {
                return Ok(Value::Null);
            }

            // Try numeric addition first
            if arr.iter().all(|v| matches!(v, Value::Int(_) | Value::Float(_) | Value::BigInt(_))) {
                // Check if any value is BigInt
                if arr.iter().any(|v| matches!(v, Value::BigInt(_))) {
                    // Use BigInt arithmetic
                    let mut sum = num_bigint::BigInt::from(0);
                    for val in arr {
                        match val {
                            Value::Int(i) => sum += num_bigint::BigInt::from(*i),
                            Value::BigInt(bi) => sum += bi,
                            Value::Float(f) => {
                                // For simplicity, convert float to BigInt by truncating
                                // In a real implementation, you might want to handle this differently
                                sum += num_bigint::BigInt::from(*f as i64);
                            }
                            _ => unreachable!(),
                        }
                    }
                    Ok(Value::BigInt(sum))
                } else {
                    // Check if all are Int
                    if arr.iter().all(|v| matches!(v, Value::Int(_))) {
                        // Use i128 arithmetic for Int only to handle overflow
                        let mut sum: i128 = 0;
                        for val in arr {
                            if let Value::Int(i) = val {
                                sum = sum.saturating_add(*i as i128);
                            }
                        }
                        if sum >= i64::MIN as i128 && sum <= i64::MAX as i128 {
                            Ok(Value::Int(sum as i64))
                        } else {
                            Ok(Value::BigInt(num_bigint::BigInt::from(sum)))
                        }
                    } else {
                        // Use f64 arithmetic for Float mixed
                        let mut sum = 0.0;
                        for val in arr {
                            match val {
                                Value::Int(i) => sum += *i as f64,
                                Value::Float(f) => sum += f,
                                _ => unreachable!(),
                            }
                        }

                        if sum.fract() == 0.0 && sum <= i64::MAX as f64 && sum >= i64::MIN as f64 {
                            Ok(Value::Int(sum as i64))
                        } else {
                            Ok(Value::Float(sum))
                        }
                    }
                }
            }
            // Try string concatenation
            else if arr.iter().all(|v| matches!(v, Value::String(_))) {
                let mut result = String::new();
                for val in arr {
                    if let Value::String(s) = val {
                        result.push_str(s);
                    }
                }
                Ok(Value::String(result))
            } else {
                Err(dsq_shared::error::operation_error("add() requires homogeneous array"))
            }
        }
        Value::Series(series) => {
            if series.dtype().is_numeric() {
                let sum_result = series.sum::<f64>();
                match sum_result {
                    Some(sum) => {
                        if sum.fract() == 0.0 && sum <= i64::MAX as f64 && sum >= i64::MIN as f64 {
                            Ok(Value::Int(sum as i64))
                        } else {
                            Ok(Value::Float(sum))
                        }
                    }
                    None => Ok(Value::Null),
                }
            } else {
                Err(dsq_shared::error::operation_error("add() requires numeric series"))
            }
        }
        Value::DataFrame(df) => {
            // Sum all numeric values in the DataFrame
            let mut sum = 0.0;
            let mut has_values = false;
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype().is_numeric() {
                        for i in 0..series.len() {
                            if let Ok(val) = series.get(i) {
                                has_values = true;
                                match val {
                                    AnyValue::Int64(n) => sum += n as f64,
                                    AnyValue::Float64(n) => sum += n,
                                    _ => {}
                                }
                            }
                        }
                    }
                }
            }
            if has_values {
                if sum.fract() == 0.0 && sum <= i64::MAX as f64 && sum >= i64::MIN as f64 {
                    Ok(Value::Int(sum as i64))
                } else {
                    Ok(Value::Float(sum))
                }
            } else {
                Ok(Value::Null)
            }
        }
        _ => Err(dsq_shared::error::operation_error("add() requires an array, Series, or DataFrame")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_add_multiple(args: &[Value]) -> Result<Value> {
    // Sum all arguments
    let mut sum_bigint = num_bigint::BigInt::from(0);
    let mut sum_float = 0.0;
    let mut has_float = false;
    let mut has_bigint = false;
    let mut string_parts = Vec::new();
    let mut all_strings = true;
    let mut all_numeric = true;

    for arg in args {
        match arg {
            Value::Int(i) => {
                all_strings = false;
                if has_float {
                    sum_float += *i as f64;
                } else if has_bigint {
                    sum_bigint += num_bigint::BigInt::from(*i);
                } else {
                    sum_bigint += num_bigint::BigInt::from(*i);
                    has_bigint = true;
                }
            }
            Value::Float(f) => {
                all_strings = false;
                has_float = true;
                sum_float += *f;
                if has_bigint {
                    sum_float += sum_bigint.to_string().parse::<f64>().unwrap_or(0.0);
                    has_bigint = false;
                }
            }
            Value::BigInt(bi) => {
                all_strings = false;
                has_bigint = true;
                if has_float {
                    sum_float += bi.to_string().parse::<f64>().unwrap_or(0.0);
                } else {
                    sum_bigint += bi;
                }
            }
            Value::String(s) => {
                all_numeric = false;
                string_parts.push(s.clone());
            }
            Value::Array(_arr) => {
                // For arrays, we could flatten and sum, but for simplicity, treat as error
                return Err(dsq_shared::error::operation_error("add() with multiple arguments does not support arrays"));
            }
            Value::DataFrame(_) | Value::LazyFrame(_) | Value::Series(_) | Value::Object(_) => {
                return Err(dsq_shared::error::operation_error("add() with multiple arguments only supports numeric and string values"));
            }
            Value::Bool(_b) => {
                return Err(dsq_shared::error::operation_error("add() with multiple arguments does not support boolean values"));
            }
            Value::Null => {
                // Null adds nothing
            }
        }
    }

    if all_strings && !string_parts.is_empty() {
        let result = string_parts.join("");
        Ok(Value::String(result))
    } else if all_numeric {
        if has_float {
            if sum_float.fract() == 0.0 && sum_float <= i64::MAX as f64 && sum_float >= i64::MIN as f64 {
                Ok(Value::Int(sum_float as i64))
            } else {
                Ok(Value::Float(sum_float))
            }
        } else if has_bigint {
            Ok(Value::BigInt(sum_bigint))
        } else {
            // All were Int, sum_bigint contains the sum
            if sum_bigint >= num_bigint::BigInt::from(i64::MIN) && sum_bigint <= num_bigint::BigInt::from(i64::MAX) {
                Ok(Value::Int(sum_bigint.to_string().parse().unwrap()))
            } else {
                Ok(Value::BigInt(sum_bigint))
            }
        }
    } else {
        Err(dsq_shared::error::operation_error("add() with multiple arguments requires all arguments to be numeric or all strings"))
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_min(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("min() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) if !arr.is_empty() => {
            let mut min_val = &arr[0];
            for val in arr.iter().skip(1) {
                if compare_values_for_sorting(val, min_val) == std::cmp::Ordering::Less {
                    min_val = val;
                }
            }
            Ok(min_val.clone())
        }
        Value::DataFrame(df) => {
            // Get min of first numeric column
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype().is_numeric() {
                        // Collect numeric values and find min
                        let mut values = Vec::new();
                        for i in 0..series.len() {
                            if let Ok(val) = series.get(i) {
                                match val {
                                    AnyValue::Int64(n) => values.push(n as f64),
                                    AnyValue::Float64(n) => values.push(n),
                                    _ => {}
                                }
                            }
                        }
                        if let Some(&min_val) = values.iter().min_by(|a, b| a.partial_cmp(b).unwrap()) {
                            return Ok(Value::Float(min_val));
                        }
                    }
                }
            }
            Ok(Value::Null)
        }
        _ => Ok(Value::Null),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_max(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("max() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) if !arr.is_empty() => {
            let mut max_val = &arr[0];
            for val in arr.iter().skip(1) {
                if compare_values_for_sorting(val, max_val) == std::cmp::Ordering::Greater {
                    max_val = val;
                }
            }
            Ok(max_val.clone())
        }
        Value::DataFrame(df) => {
            // Get max of first numeric column
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype().is_numeric() {
                        // Collect numeric values and find max
                        let mut values = Vec::new();
                        for i in 0..series.len() {
                            if let Ok(val) = series.get(i) {
                                match val {
                                    AnyValue::Int64(n) => values.push(n as f64),
                                    AnyValue::Float64(n) => values.push(n),
                                    _ => {}
                                }
                            }
                        }
                        if let Some(&max_val) = values.iter().max_by(|a, b| a.partial_cmp(b).unwrap()) {
                            return Ok(Value::Float(max_val));
                        }
                    }
                }
            }
            Ok(Value::Null)
        }
        _ => Ok(Value::Null),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_first(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("first() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) => {
            if arr.is_empty() {
                Ok(Value::Null)
            } else {
                Ok(arr[0].clone())
            }
        }
        Value::DataFrame(df) => {
            if df.height() == 0 {
                Ok(Value::Null)
            } else {
                // Return first row as object
                let mut row_obj = HashMap::new();
                for col_name in df.get_column_names() {
                    if let Ok(series) = df.column(col_name) {
                        if let Some(val) = series.get(0).ok() {
                            let value = value_from_any_value(val).unwrap_or(Value::Null);
                            row_obj.insert(col_name.to_string(), value);
                        }
                    }
                }
                Ok(Value::Object(row_obj))
            }
        }
        _ => Ok(args[0].clone()),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_last(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("last() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) => {
            if arr.is_empty() {
                Ok(Value::Null)
            } else {
                Ok(arr[arr.len() - 1].clone())
            }
        }
        Value::DataFrame(df) => {
            if df.height() == 0 {
                Ok(Value::Null)
            } else {
                // Return last row as object
                let last_idx = df.height() - 1;
                let mut row_obj = HashMap::new();
                for col_name in df.get_column_names() {
                    if let Ok(series) = df.column(col_name) {
                        if let Some(val) = series.get(last_idx).ok() {
                            let value = value_from_any_value(val).unwrap_or(Value::Null);
                            row_obj.insert(col_name.to_string(), value);
                        }
                    }
                }
                Ok(Value::Object(row_obj))
            }
        }
        _ => Ok(args[0].clone()),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_array_unshift(args: &[Value]) -> Result<Value> {
    if args.len() < 2 {
        return Err(dsq_shared::error::operation_error("array_unshift() expects at least 2 arguments"));
    }

    match &args[0] {
        Value::Array(arr) => {
            let mut new_arr = args[1..].to_vec();
            new_arr.extend(arr.clone());
            Ok(Value::Int(new_arr.len() as i64))
        }
        _ => Err(dsq_shared::error::operation_error("array_unshift() first argument must be an array")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_array_shift(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("array_shift() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) => {
            if arr.is_empty() {
                Ok(Value::Array(Vec::new()))
            } else {
                Ok(Value::Array(arr[1..].to_vec()))
            }
        }
        Value::Series(series) => {
            if matches!(series.dtype(), DataType::List(_)) {
                // For testing, return original
                Ok(Value::Series(series.clone()))
            } else {
                Err(dsq_shared::error::operation_error("array_shift() requires an array or list series"))
            }
        }
        _ => Err(dsq_shared::error::operation_error("array_shift() requires an array or list series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_array_push(args: &[Value]) -> Result<Value> {
    if args.len() < 2 {
        return Err(dsq_shared::error::operation_error("array_push() expects at least 2 arguments"));
    }

    match &args[0] {
        Value::Array(arr) => {
            let mut new_arr = arr.clone();
            new_arr.extend_from_slice(&args[1..]);
            Ok(Value::Array(new_arr))
        }
        Value::Series(series) => {
            if matches!(series.dtype(), DataType::List(_)) {
                let list_chunked = series.list().unwrap();
                if series.len() == 1 {
                    if let Some(list_series) = list_chunked.get_as_series(0) {
                        let mut arr = Vec::new();
                        for i in 0..list_series.len() {
                            if let Ok(val) = list_series.get(i) {
                                let value = value_from_any_value(val).unwrap_or(Value::Null);
                                arr.push(value);
                            }
                        }
                        arr.extend_from_slice(&args[1..]);
                        Ok(Value::Array(arr))
                    } else {
                        Ok(Value::Array(args[1..].to_vec()))
                    }
                } else {
                    Err(dsq_shared::error::operation_error(format!("array_push() on series with {} elements not supported", series.len())))
                }
            } else {
                Err(dsq_shared::error::operation_error("array_push() requires an array or list series"))
            }
        }
        Value::DataFrame(df) => {
            let value_to_push = &args[1];
            let any_value = match value_to_push {
                Value::Int(i) => AnyValue::Int64(*i),
                Value::Float(f) => AnyValue::Float64(*f),
                Value::String(s) => AnyValue::Utf8(s),
                Value::Bool(b) => AnyValue::Boolean(*b),
                Value::Null => AnyValue::Null,
                _ => AnyValue::Null, // For complex types
            };
            let mut new_series_vec = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if matches!(series.dtype(), DataType::List(_)) {
                        let list_chunked = series.list().unwrap();
                        let mut new_lists = Vec::new();
                        for i in 0..df.height() {
                            if let Some(list_series) = list_chunked.get_as_series(i) {
                                let mut values = vec![];
                                for j in 0..list_series.len() {
                                    values.push(list_series.get(j).unwrap());
                                }
                                values.push(any_value.clone());
                                new_lists.push(Series::new("", values));
                            } else {
                                new_lists.push(Series::new("", vec![any_value.clone()]));
                            }
                        }
                        let new_list_series = Series::new(col_name, new_lists);
                        new_series_vec.push(new_list_series);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series_vec.push(s);
                    }
                }
            }
            match DataFrame::new(new_series_vec) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("array_push() failed on DataFrame: {}", e))),
            }
        }
        _ => Err(dsq_shared::error::operation_error(format!("array_push() first argument must be an array, list series, or DataFrame, got {}", args[0].type_name()))),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_array_pop(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("array_pop() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) => {
            if arr.is_empty() {
                Ok(Value::Null)
            } else {
                Ok(arr[arr.len() - 1].clone())
            }
        }
        Value::Series(series) => {
            if matches!(series.dtype(), DataType::List(_)) {
                if series.len() == 1 {
                    if let Some(list_series) = series.list().unwrap().get_as_series(0) {
                        if list_series.len() > 0 {
                            let last_idx = list_series.len() - 1;
                            if let Ok(val) = list_series.get(last_idx) {
                                Ok(value_from_any_value(val).unwrap_or(Value::Null))
                            } else {
                                Ok(Value::Null)
                            }
                        } else {
                            Ok(Value::Null)
                        }
                    } else {
                        Ok(Value::Null)
                    }
                } else {
                    Err(dsq_shared::error::operation_error(format!("array_pop() on series with {} elements not supported", series.len())))
                }
            } else {
                Err(dsq_shared::error::operation_error("array_pop() requires an array or list series"))
            }
        }
        _ => Err(dsq_shared::error::operation_error("array_pop() requires an array or list series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_repeat(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("repeat() expects 2 arguments: value and count"));
    }

    let count = match &args[1] {
        Value::Int(c) if *c >= 0 => *c as usize,
        _ => return Err(dsq_shared::error::operation_error("repeat() second argument must be a non-negative integer")),
    };

    let value = &args[0];
    let repeated: Vec<Value> = (0..count).map(|_| value.clone()).collect();
    Ok(Value::Array(repeated))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_zip(args: &[Value]) -> Result<Value> {
    if args.is_empty() {
        return Ok(Value::Array(Vec::new()));
    }

    // Check if all arguments are arrays
    let arrays: Vec<&Vec<Value>> = args.iter().filter_map(|arg| {
        match arg {
            Value::Array(arr) => Some(arr),
            _ => None,
        }
    }).collect();

    if arrays.len() != args.len() {
        return Err(dsq_shared::error::operation_error("zip() all arguments must be arrays"));
    }

    if arrays.is_empty() {
        return Ok(Value::Array(Vec::new()));
    }

    let min_len = arrays.iter().map(|arr| arr.len()).min().unwrap_or(0);
    let mut result = Vec::with_capacity(min_len);

    for i in 0..min_len {
        let tuple: Vec<Value> = arrays.iter().map(|arr| arr[i].clone()).collect();
        result.push(Value::Array(tuple));
    }

    Ok(Value::Array(result))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_transpose(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("transpose() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) => {
            if arr.is_empty() {
                return Ok(Value::Array(Vec::new()));
            }

            // Check if all elements are arrays (rows)
            let rows: Vec<&Vec<Value>> = arr.iter().filter_map(|row| {
                match row {
                    Value::Array(arr) => Some(arr),
                    _ => None,
                }
            }).collect();

            if rows.len() != arr.len() {
                return Err(dsq_shared::error::operation_error("transpose() argument must be a 2D array (all elements must be arrays)"));
            }

            if rows.is_empty() {
                return Ok(Value::Array(Vec::new()));
            }

            let row_len = rows[0].len();
            // Check if all rows have the same length
            if !rows.iter().all(|row| row.len() == row_len) {
                return Err(dsq_shared::error::operation_error("transpose() all rows must have the same length"));
            }

            let mut result = Vec::with_capacity(row_len);
            for col in 0..row_len {
                let new_row: Vec<Value> = rows.iter().map(|row| row[col].clone()).collect();
                result.push(Value::Array(new_row));
            }

            Ok(Value::Array(result))
        }
        Value::DataFrame(df) => {
            // Transpose DataFrame
            match df.transpose(None, None) {
                Ok(transposed_df) => Ok(Value::DataFrame(transposed_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("transpose() failed: {}", e))),
            }
        }
        _ => Err(dsq_shared::error::operation_error("transpose() requires array or DataFrame")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_systime_ns(args: &[Value]) -> Result<Value> {
    let now = std::time::SystemTime::now();
    let duration = now.duration_since(std::time::UNIX_EPOCH)
        .map_err(|_| dsq_shared::error::operation_error("System time is before UNIX epoch"))?;
    let nanos = duration.as_nanos() as i64;

    if args.is_empty() {
        return Ok(Value::Int(nanos));
    }

    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("systime_ns() expects 0 or 1 arguments"));
    }

    match &args[0] {
        Value::Array(arr) => {
            let current_times: Vec<Value> = (0..arr.len()).map(|_| Value::Int(nanos)).collect();
            Ok(Value::Array(current_times))
        }
        Value::DataFrame(df) => {
            // Add a new column with current time for each row
            let mut new_df = df.clone();
            let time_series = Series::new("systime_ns", vec![nanos; df.height()]);
            match new_df.with_column(time_series) {
                Ok(_) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("systime_ns() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            let time_series = Series::new(series.name(), vec![nanos; series.len()]);
            Ok(Value::Series(time_series))
        }
        _ => Ok(Value::Int(nanos)),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_localtime(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("localtime() expects 1 argument"));
    }

    match &args[0] {
        Value::Int(i) => {
            let dt = Utc.timestamp_opt(*i, 0).single()
                .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
            let local_dt: DateTime<Local> = dt.with_timezone(&Local);
            Ok(Value::String(local_dt.format("%Y-%m-%d %H:%M:%S").to_string()))
        }
        Value::Float(f) => {
            let secs = f.trunc() as i64;
            let nanos = (f.fract() * 1_000_000_000.0) as u32;
            let dt = Utc.timestamp_opt(secs, nanos).single()
                .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
            let local_dt: DateTime<Local> = dt.with_timezone(&Local);
            Ok(Value::String(local_dt.format("%Y-%m-%d %H:%M:%S").to_string()))
        }
        Value::String(s) => {
            // Try to parse as timestamp number
            if let Ok(ts) = s.parse::<i64>() {
                let dt = Utc.timestamp_opt(ts, 0).single()
                    .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                let local_dt: DateTime<Local> = dt.with_timezone(&Local);
                Ok(Value::String(local_dt.format("%Y-%m-%d %H:%M:%S").to_string()))
            } else {
                Ok(Value::Null)
            }
        }
        Value::Array(arr) => {
            let localtimes: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::Int(i) => {
                        let dt = Utc.timestamp_opt(*i, 0).single()
                            .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                        let local_dt: DateTime<Local> = dt.with_timezone(&Local);
                        Ok(Value::String(local_dt.format("%Y-%m-%d %H:%M:%S").to_string()))
                    }
                    Value::Float(f) => {
                        let secs = f.trunc() as i64;
                        let nanos = (f.fract() * 1_000_000_000.0) as u32;
                        let dt = Utc.timestamp_opt(secs, nanos).single()
                            .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                        let local_dt: DateTime<Local> = dt.with_timezone(&Local);
                        Ok(Value::String(local_dt.format("%Y-%m-%d %H:%M:%S").to_string()))
                    }
                    Value::String(s) => {
                        if let Ok(ts) = s.parse::<i64>() {
                            let dt = Utc.timestamp_opt(ts, 0).single()
                                .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                            let local_dt: DateTime<Local> = dt.with_timezone(&Local);
                            Ok(Value::String(local_dt.format("%Y-%m-%d %H:%M:%S").to_string()))
                        } else {
                            Ok(Value::Null)
                        }
                    }
                    _ => Ok(Value::Null),
                }
            }).collect();
            Ok(Value::Array(localtimes?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype().is_numeric() {
                        let mut localtime_values = Vec::new();
                        for i in 0..series.len() {
                            if let Ok(val) = series.get(i) {
                                match val {
                                    AnyValue::Int64(ts) => {
                                        let dt = Utc.timestamp_opt(ts, 0).single()
                                            .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                                        let local_dt: DateTime<Local> = dt.with_timezone(&Local);
                                        localtime_values.push(local_dt.format("%Y-%m-%d %H:%M:%S").to_string());
                                    }
                                    AnyValue::Float64(ts) => {
                                        let secs = ts.trunc() as i64;
                                        let nanos = (ts.fract() * 1_000_000_000.0) as u32;
                                        let dt = Utc.timestamp_opt(secs, nanos).single()
                                            .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                                        let local_dt: DateTime<Local> = dt.with_timezone(&Local);
                                        localtime_values.push(local_dt.format("%Y-%m-%d %H:%M:%S").to_string());
                                    }
                                    _ => localtime_values.push("".to_string()),
                                }
                            } else {
                                localtime_values.push("".to_string());
                            }
                        }
                        let localtime_series = Series::new(col_name, localtime_values);
                        new_series.push(localtime_series);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("localtime() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype().is_numeric() {
                let mut localtime_values = Vec::new();
                for i in 0..series.len() {
                    if let Ok(val) = series.get(i) {
                        match val {
                            AnyValue::Int64(ts) => {
                                let dt = Utc.timestamp_opt(ts, 0).single()
                                    .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                                let local_dt: DateTime<Local> = dt.with_timezone(&Local);
                                localtime_values.push(local_dt.format("%Y-%m-%d %H:%M:%S").to_string());
                            }
                            AnyValue::Float64(ts) => {
                                let secs = ts.trunc() as i64;
                                let nanos = (ts.fract() * 1_000_000_000.0) as u32;
                                let dt = Utc.timestamp_opt(secs, nanos).single()
                                    .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                                let local_dt: DateTime<Local> = dt.with_timezone(&Local);
                                localtime_values.push(local_dt.format("%Y-%m-%d %H:%M:%S").to_string());
                            }
                            _ => localtime_values.push("".to_string()),
                        }
                    } else {
                        localtime_values.push("".to_string());
                    }
                }
                Ok(Value::Series(Series::new("", localtime_values)))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(Value::Null),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_strftime(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("strftime() expects 2 arguments"));
    }

    let format_str = match &args[1] {
        Value::String(s) => s,
        _ => return Err(dsq_shared::error::operation_error("strftime() second argument must be a format string")),
    };

    match &args[0] {
        Value::Int(i) => {
            let dt = Utc.timestamp_opt(*i, 0).single()
                .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
            Ok(Value::String(dt.format(format_str).to_string()))
        }
        Value::Float(f) => {
            let secs = f.trunc() as i64;
            let nanos = (f.fract() * 1_000_000_000.0) as u32;
            let dt = Utc.timestamp_opt(secs, nanos).single()
                .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
            Ok(Value::String(dt.format(format_str).to_string()))
        }
        Value::String(s) => {
            // Try to parse as timestamp number first
            if let Ok(ts) = s.parse::<i64>() {
                let dt = Utc.timestamp_opt(ts, 0).single()
                    .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                Ok(Value::String(dt.format(format_str).to_string()))
            } else {
                // Try to parse as date/datetime string
                if let Ok(dt) = NaiveDate::parse_from_str(s, "%Y-%m-%d") {
                    let dt_utc = Utc.from_utc_datetime(&dt.and_hms_opt(0, 0, 0).unwrap());
                    Ok(Value::String(dt_utc.format(format_str).to_string()))
                } else if let Ok(dt) = DateTime::parse_from_rfc3339(s) {
                    let dt_utc = dt.with_timezone(&Utc);
                    Ok(Value::String(dt_utc.format(format_str).to_string()))
                } else {
                    Ok(Value::Null)
                }
            }
        }
        Value::Array(arr) => {
            let formatted: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::Int(i) => {
                        let dt = Utc.timestamp_opt(*i, 0).single()
                            .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                        Ok(Value::String(dt.format(format_str).to_string()))
                    }
                    Value::Float(f) => {
                        let secs = f.trunc() as i64;
                        let nanos = (f.fract() * 1_000_000_000.0) as u32;
                        let dt = Utc.timestamp_opt(secs, nanos).single()
                            .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                        Ok(Value::String(dt.format(format_str).to_string()))
                    }
                    Value::String(s) => {
                        if let Ok(ts) = s.parse::<i64>() {
                            let dt = Utc.timestamp_opt(ts, 0).single()
                                .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                            Ok(Value::String(dt.format(format_str).to_string()))
                        } else {
                            if let Ok(dt) = NaiveDate::parse_from_str(s, "%Y-%m-%d") {
                                let dt_utc = Utc.from_utc_datetime(&dt.and_hms_opt(0, 0, 0).unwrap());
                                Ok(Value::String(dt_utc.format(format_str).to_string()))
                            } else if let Ok(dt) = DateTime::parse_from_rfc3339(s) {
                                let dt_utc = dt.with_timezone(&Utc);
                                Ok(Value::String(dt_utc.format(format_str).to_string()))
                            } else {
                                Ok(Value::Null)
                            }
                        }
                    }
                    _ => Ok(Value::Null),
                }
            }).collect();
            Ok(Value::Array(formatted?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype().is_numeric() {
                        let mut formatted_values = Vec::new();
                        for i in 0..series.len() {
                            if let Ok(val) = series.get(i) {
                                match val {
                                    AnyValue::Int64(ts) => {
                                        let dt = Utc.timestamp_opt(ts, 0).single()
                                            .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                                        formatted_values.push(dt.format(format_str).to_string());
                                    }
                                    AnyValue::Float64(ts) => {
                                        let secs = ts.trunc() as i64;
                                        let nanos = (ts.fract() * 1_000_000_000.0) as u32;
                                        let dt = Utc.timestamp_opt(secs, nanos).single()
                                            .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                                        formatted_values.push(dt.format(format_str).to_string());
                                    }
                                    _ => formatted_values.push("".to_string()),
                                }
                            } else {
                                formatted_values.push("".to_string());
                            }
                        }
                        let formatted_series = Series::new(col_name, formatted_values);
                        new_series.push(formatted_series);
                    } else if series.dtype() == &DataType::Utf8 {
                        let formatted_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                if let Ok(ts) = s.parse::<i64>() {
                                    let dt = Utc.timestamp_opt(ts, 0).single()
                                        .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp")).ok()?;
                                    Some(Cow::Owned(dt.format(format_str).to_string()))
                                } else {
                                    if let Ok(dt) = NaiveDate::parse_from_str(s, "%Y-%m-%d") {
                                        let dt_utc = Utc.from_utc_datetime(&dt.and_hms_opt(0, 0, 0).unwrap());
                                        Some(Cow::Owned(dt_utc.format(format_str).to_string()))
                                    } else if let Ok(dt) = DateTime::parse_from_rfc3339(s) {
                                        let dt_utc = dt.with_timezone(&Utc);
                                        Some(Cow::Owned(dt_utc.format(format_str).to_string()))
                                    } else {
                                        None
                                    }
                                }
                            })
                        }).into_series();
                        let mut s = formatted_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("strftime() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype().is_numeric() {
                let mut formatted_values = Vec::new();
                for i in 0..series.len() {
                    if let Ok(val) = series.get(i) {
                        match val {
                            AnyValue::Int64(ts) => {
                                let dt = Utc.timestamp_opt(ts, 0).single()
                                    .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                                formatted_values.push(dt.format(format_str).to_string());
                            }
                            AnyValue::Float64(ts) => {
                                let secs = ts.trunc() as i64;
                                let nanos = (ts.fract() * 1_000_000_000.0) as u32;
                                let dt = Utc.timestamp_opt(secs, nanos).single()
                                    .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                                formatted_values.push(dt.format(format_str).to_string());
                            }
                            _ => formatted_values.push("".to_string()),
                        }
                    } else {
                        formatted_values.push("".to_string());
                    }
                }
                Ok(Value::Series(Series::new("", formatted_values)))
            } else if series.dtype() == &DataType::Utf8 {
                let formatted_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        if let Ok(ts) = s.parse::<i64>() {
                            let dt = Utc.timestamp_opt(ts, 0).single()
                                .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp")).ok()?;
                            Some(Cow::Owned(dt.format(format_str).to_string()))
                        } else {
                            if let Ok(dt) = NaiveDate::parse_from_str(s, "%Y-%m-%d") {
                                let dt_utc = Utc.from_utc_datetime(&dt.and_hms_opt(0, 0, 0).unwrap());
                                Some(Cow::Owned(dt_utc.format(format_str).to_string()))
                            } else if let Ok(dt) = DateTime::parse_from_rfc3339(s) {
                                let dt_utc = dt.with_timezone(&Utc);
                                Some(Cow::Owned(dt_utc.format(format_str).to_string()))
                            } else {
                                None
                            }
                        }
                    })
                }).into_series();
                Ok(Value::Series(formatted_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(Value::Null),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_strflocaltime(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("strflocaltime() expects 2 arguments"));
    }

    let format_str = match &args[1] {
        Value::String(s) => s,
        _ => return Err(dsq_shared::error::operation_error("strflocaltime() second argument must be a format string")),
    };

    match &args[0] {
        Value::Int(i) => {
            let dt = Utc.timestamp_opt(*i, 0).single()
                .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
            let local_dt: DateTime<Local> = dt.with_timezone(&Local);
            Ok(Value::String(local_dt.format(format_str).to_string()))
        }
        Value::Float(f) => {
            let secs = f.trunc() as i64;
            let nanos = (f.fract() * 1_000_000_000.0) as u32;
            let dt = Utc.timestamp_opt(secs, nanos).single()
                .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
            let local_dt: DateTime<Local> = dt.with_timezone(&Local);
            Ok(Value::String(local_dt.format(format_str).to_string()))
        }
        Value::String(s) => {
            // Try to parse as timestamp number first
            if let Ok(ts) = s.parse::<i64>() {
                let dt = Utc.timestamp_opt(ts, 0).single()
                    .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                let local_dt: DateTime<Local> = dt.with_timezone(&Local);
                Ok(Value::String(local_dt.format(format_str).to_string()))
            } else {
                // Try to parse as date/datetime string
                if let Ok(dt) = NaiveDate::parse_from_str(s, "%Y-%m-%d") {
                    let dt_utc = Utc.from_utc_datetime(&dt.and_hms_opt(0, 0, 0).unwrap());
                    let local_dt: DateTime<Local> = dt_utc.with_timezone(&Local);
                    Ok(Value::String(local_dt.format(format_str).to_string()))
                } else if let Ok(dt) = DateTime::parse_from_rfc3339(s) {
                    let dt_utc = dt.with_timezone(&Utc);
                    let local_dt: DateTime<Local> = dt_utc.with_timezone(&Local);
                    Ok(Value::String(local_dt.format(format_str).to_string()))
                } else {
                    Ok(Value::Null)
                }
            }
        }
        Value::Array(arr) => {
            let formatted: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::Int(i) => {
                        let dt = Utc.timestamp_opt(*i, 0).single()
                            .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                        let local_dt: DateTime<Local> = dt.with_timezone(&Local);
                        Ok(Value::String(local_dt.format(format_str).to_string()))
                    }
                    Value::Float(f) => {
                        let secs = f.trunc() as i64;
                        let nanos = (f.fract() * 1_000_000_000.0) as u32;
                        let dt = Utc.timestamp_opt(secs, nanos).single()
                            .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                        let local_dt: DateTime<Local> = dt.with_timezone(&Local);
                        Ok(Value::String(local_dt.format(format_str).to_string()))
                    }
                    Value::String(s) => {
                        if let Ok(ts) = s.parse::<i64>() {
                            let dt = Utc.timestamp_opt(ts, 0).single()
                                .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                            let local_dt: DateTime<Local> = dt.with_timezone(&Local);
                            Ok(Value::String(local_dt.format(format_str).to_string()))
                        } else {
                            if let Ok(dt) = NaiveDate::parse_from_str(s, "%Y-%m-%d") {
                                let dt_utc = Utc.from_utc_datetime(&dt.and_hms_opt(0, 0, 0).unwrap());
                                let local_dt: DateTime<Local> = dt_utc.with_timezone(&Local);
                                Ok(Value::String(local_dt.format(format_str).to_string()))
                            } else if let Ok(dt) = DateTime::parse_from_rfc3339(s) {
                                let dt_utc = dt.with_timezone(&Utc);
                                let local_dt: DateTime<Local> = dt_utc.with_timezone(&Local);
                                Ok(Value::String(local_dt.format(format_str).to_string()))
                            } else {
                                Ok(Value::Null)
                            }
                        }
                    }
                    _ => Ok(Value::Null),
                }
            }).collect();
            Ok(Value::Array(formatted?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype().is_numeric() {
                        let mut formatted_values = Vec::new();
                        for i in 0..series.len() {
                            if let Ok(val) = series.get(i) {
                                match val {
                                    AnyValue::Int64(ts) => {
                                        let dt = Utc.timestamp_opt(ts, 0).single()
                                            .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                                        let local_dt: DateTime<Local> = dt.with_timezone(&Local);
                                        formatted_values.push(local_dt.format(format_str).to_string());
                                    }
                                    AnyValue::Float64(ts) => {
                                        let secs = ts.trunc() as i64;
                                        let nanos = (ts.fract() * 1_000_000_000.0) as u32;
                                        let dt = Utc.timestamp_opt(secs, nanos).single()
                                            .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                                        let local_dt: DateTime<Local> = dt.with_timezone(&Local);
                                        formatted_values.push(local_dt.format(format_str).to_string());
                                    }
                                    _ => formatted_values.push("".to_string()),
                                }
                            } else {
                                formatted_values.push("".to_string());
                            }
                        }
                        let formatted_series = Series::new(col_name, formatted_values);
                        new_series.push(formatted_series);
                    } else if series.dtype() == &DataType::Utf8 {
                        let formatted_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                if let Ok(ts) = s.parse::<i64>() {
                                    let dt = Utc.timestamp_opt(ts, 0).single()
                                        .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp")).ok()?;
                                    let local_dt: DateTime<Local> = dt.with_timezone(&Local);
                                    Some(Cow::Owned(local_dt.format(format_str).to_string()))
                                } else {
                                    if let Ok(dt) = NaiveDate::parse_from_str(s, "%Y-%m-%d") {
                                        let dt_utc = Utc.from_utc_datetime(&dt.and_hms_opt(0, 0, 0).unwrap());
                                        let local_dt: DateTime<Local> = dt_utc.with_timezone(&Local);
                                        Some(Cow::Owned(local_dt.format(format_str).to_string()))
                                    } else if let Ok(dt) = DateTime::parse_from_rfc3339(s) {
                                        let dt_utc = dt.with_timezone(&Utc);
                                        let local_dt: DateTime<Local> = dt_utc.with_timezone(&Local);
                                        Some(Cow::Owned(local_dt.format(format_str).to_string()))
                                    } else {
                                        None
                                    }
                                }
                            })
                        }).into_series();
                        let mut s = formatted_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("strflocaltime() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype().is_numeric() {
                let mut formatted_values = Vec::new();
                for i in 0..series.len() {
                    if let Ok(val) = series.get(i) {
                        match val {
                            AnyValue::Int64(ts) => {
                                let dt = Utc.timestamp_opt(ts, 0).single()
                                    .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                                let local_dt: DateTime<Local> = dt.with_timezone(&Local);
                                formatted_values.push(local_dt.format(format_str).to_string());
                            }
                            AnyValue::Float64(ts) => {
                                let secs = ts.trunc() as i64;
                                let nanos = (ts.fract() * 1_000_000_000.0) as u32;
                                let dt = Utc.timestamp_opt(secs, nanos).single()
                                    .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
                                let local_dt: DateTime<Local> = dt.with_timezone(&Local);
                                formatted_values.push(local_dt.format(format_str).to_string());
                            }
                            _ => formatted_values.push("".to_string()),
                        }
                    } else {
                        formatted_values.push("".to_string());
                    }
                }
                Ok(Value::Series(Series::new("", formatted_values)))
            } else if series.dtype() == &DataType::Utf8 {
                let formatted_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        if let Ok(ts) = s.parse::<i64>() {
                            let dt = Utc.timestamp_opt(ts, 0).single()
                                .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp")).ok()?;
                            let local_dt: DateTime<Local> = dt.with_timezone(&Local);
                            Some(Cow::Owned(local_dt.format(format_str).to_string()))
                        } else {
                            if let Ok(dt) = NaiveDate::parse_from_str(s, "%Y-%m-%d") {
                                let dt_utc = Utc.from_utc_datetime(&dt.and_hms_opt(0, 0, 0).unwrap());
                                let local_dt: DateTime<Local> = dt_utc.with_timezone(&Local);
                                Some(Cow::Owned(local_dt.format(format_str).to_string()))
                            } else if let Ok(dt) = DateTime::parse_from_rfc3339(s) {
                                let dt_utc = dt.with_timezone(&Utc);
                                let local_dt: DateTime<Local> = dt_utc.with_timezone(&Local);
                                Some(Cow::Owned(local_dt.format(format_str).to_string()))
                            } else {
                                None
                            }
                        }
                    })
                }).into_series();
                Ok(Value::Series(formatted_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(Value::Null),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_strptime(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("strptime() expects 2 arguments"));
    }

    let format_str = match &args[1] {
        Value::String(s) => s,
        _ => return Err(dsq_shared::error::operation_error("strptime() second argument must be a format string")),
    };

    match &args[0] {
        Value::String(s) => {
            // Try to parse as NaiveDateTime first (for formats without timezone)
            if let Ok(dt) = NaiveDateTime::parse_from_str(s, format_str) {
                let timestamp = dt.and_utc().timestamp();
                Ok(Value::Int(timestamp))
            } else if let Ok(dt) = DateTime::parse_from_str(s, format_str) {
                let timestamp = dt.timestamp();
                Ok(Value::Int(timestamp))
            } else if let Ok(date) = NaiveDate::parse_from_str(s, format_str) {
                // For date-only formats, assume time is 00:00:00
                let dt = date.and_hms_opt(0, 0, 0).unwrap();
                let timestamp = dt.and_utc().timestamp();
                Ok(Value::Int(timestamp))
            } else {
                Ok(Value::Null)
            }
        }
        Value::Array(arr) => {
            let parsed: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => {
                        if let Ok(dt) = NaiveDateTime::parse_from_str(s, format_str) {
                            let timestamp = dt.and_utc().timestamp();
                            Ok(Value::Int(timestamp))
                        } else if let Ok(dt) = DateTime::parse_from_str(s, format_str) {
                            let timestamp = dt.timestamp();
                            Ok(Value::Int(timestamp))
                        } else if let Ok(date) = NaiveDate::parse_from_str(s, format_str) {
                            let dt = date.and_hms_opt(0, 0, 0).unwrap();
                            let timestamp = dt.and_utc().timestamp();
                            Ok(Value::Int(timestamp))
                        } else {
                            Ok(Value::Null)
                        }
                    }
                    _ => Ok(Value::Null),
                }
            }).collect();
            Ok(Value::Array(parsed?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let parsed_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                if let Ok(dt) = NaiveDateTime::parse_from_str(s, format_str) {
                                    let timestamp = dt.and_utc().timestamp();
                                    Some(Cow::Owned(timestamp.to_string()))
                                } else if let Ok(dt) = DateTime::parse_from_str(s, format_str) {
                                    let timestamp = dt.timestamp();
                                    Some(Cow::Owned(timestamp.to_string()))
                                } else if let Ok(date) = NaiveDate::parse_from_str(s, format_str) {
                                    let dt = date.and_hms_opt(0, 0, 0).unwrap();
                                    let timestamp = dt.and_utc().timestamp();
                                    Some(Cow::Owned(timestamp.to_string()))
                                } else {
                                    None
                                }
                            })
                        }).into_series();
                        let mut s = parsed_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("strptime() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let parsed_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        if let Ok(dt) = NaiveDateTime::parse_from_str(s, format_str) {
                            let timestamp = dt.and_utc().timestamp();
                            Some(Cow::Owned(timestamp.to_string()))
                        } else if let Ok(dt) = DateTime::parse_from_str(s, format_str) {
                            let timestamp = dt.timestamp();
                            Some(Cow::Owned(timestamp.to_string()))
                        } else if let Ok(date) = NaiveDate::parse_from_str(s, format_str) {
                            let dt = date.and_hms_opt(0, 0, 0).unwrap();
                            let timestamp = dt.and_utc().timestamp();
                            Some(Cow::Owned(timestamp.to_string()))
                        } else {
                            None
                        }
                    })
                }).into_series();
                Ok(Value::Series(parsed_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(Value::Null),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_url_extract_domain_without_www(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("url_extract_domain_without_www() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            use url::Url;
            match Url::parse(s) {
                Ok(url) => {
                    let domain = url.host_str().unwrap_or("").to_string();
                    let domain = if domain.starts_with("www.") {
                        domain[4..].to_string()
                    } else {
                        domain
                    };
                    Ok(Value::String(domain))
                }
                Err(_) => Ok(Value::String("".to_string())),
            }
        }
        Value::Array(arr) => {
            let results: Result<Vec<Value>> = arr.iter().map(|v| {
                builtin_url_extract_domain_without_www(&[v.clone()])
            }).collect();
            Ok(Value::Array(results?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let domain_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| {
                                use url::Url;
                                match Url::parse(s) {
                                    Ok(url) => {
                                        let domain = url.host_str().unwrap_or("").to_string();
                                        let domain = if domain.starts_with("www.") {
                                            domain[4..].to_string()
                                        } else {
                                            domain
                                        };
                                        Cow::Owned(domain)
                                    }
                                    Err(_) => Cow::Owned("".to_string()),
                                }
                            })
                        }).into_series();
                        let mut s = domain_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("url_extract_domain_without_www() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let domain_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| {
                        use url::Url;
                        match Url::parse(s) {
                            Ok(url) => {
                                let domain = url.host_str().unwrap_or("").to_string();
                                let domain = if domain.starts_with("www.") {
                                    domain[4..].to_string()
                                } else {
                                    domain
                                };
                                Cow::Owned(domain)
                            }
                            Err(_) => Cow::Owned("".to_string()),
                        }
                    })
                }).into_series();
                Ok(Value::Series(domain_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("url_extract_domain_without_www() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

#[test]
fn test_builtin_strptime_string() {
    // Test with standard datetime format
    let result = builtin_strptime(&[Value::String("2021-01-01 00:00:00".to_string()), Value::String("%Y-%m-%d %H:%M:%S".to_string())]).unwrap();
    // 2021-01-01 00:00:00 UTC timestamp
    assert_eq!(result, Value::Int(1609459200));

    // Test with date only format
    let result = builtin_strptime(&[Value::String("2021-01-01".to_string()), Value::String("%Y-%m-%d".to_string())]).unwrap();
    assert_eq!(result, Value::Int(1609459200));

    // Test with invalid format
    let result = builtin_strptime(&[Value::String("invalid".to_string()), Value::String("%Y-%m-%d".to_string())]).unwrap();
    assert_eq!(result, Value::Null);
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

#[test]
fn test_builtin_strptime_array() {
    let arr = vec![
        Value::String("2021-01-01 00:00:00".to_string()),
        Value::String("2021-01-01 00:01:00".to_string()),
        Value::String("invalid".to_string()),
    ];
    let result = builtin_strptime(&[Value::Array(arr), Value::String("%Y-%m-%d %H:%M:%S".to_string())]).unwrap();
    match result {
        Value::Array(timestamps) => {
            assert_eq!(timestamps.len(), 3);
            assert_eq!(timestamps[0], Value::Int(1609459200));
            assert_eq!(timestamps[1], Value::Int(1609459260));
            assert_eq!(timestamps[2], Value::Null);
        }
        _ => panic!("Expected Array"),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

#[test]
fn test_builtin_strptime_invalid_args() {
    // No args
    let result = builtin_strptime(&[]);
    assert!(result.is_err());

    // Only one arg
    let result = builtin_strptime(&[Value::String("2021-01-01".to_string())]);
    assert!(result.is_err());

    // Non-string format
    let result = builtin_strptime(&[Value::String("2021-01-01".to_string()), Value::Int(1)]);
    assert!(result.is_err());
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_today(args: &[Value]) -> Result<Value> {
    if !args.is_empty() {
        return Err(dsq_shared::error::operation_error("today() expects no arguments"));
    }

    let today = Local::now().date_naive();
    Ok(Value::String(today.format("%Y-%m-%d").to_string()))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_now(args: &[Value]) -> Result<Value> {
    if !args.is_empty() {
        return Err(dsq_shared::error::operation_error("now() expects no arguments"));
    }

    let now = std::time::SystemTime::now();
    let duration = now.duration_since(std::time::UNIX_EPOCH)
        .map_err(|_| dsq_shared::error::operation_error("System time is before UNIX epoch"))?;
    let seconds = duration.as_secs() as f64 + duration.subsec_nanos() as f64 / 1_000_000_000.0;
    Ok(Value::Float(seconds))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_systime(args: &[Value]) -> Result<Value> {
    if !args.is_empty() {
        return Err(dsq_shared::error::operation_error("systime() expects no arguments"));
    }

    let now = std::time::SystemTime::now();
    let duration = now.duration_since(std::time::UNIX_EPOCH)
        .map_err(|_| dsq_shared::error::operation_error("System time is before UNIX epoch"))?;
    let seconds = duration.as_secs() as f64 + duration.subsec_nanos() as f64 / 1_000_000_000.0;
    Ok(Value::Float(seconds))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_systime_int(args: &[Value]) -> Result<Value> {
    let now = std::time::SystemTime::now();
    let duration = now.duration_since(std::time::UNIX_EPOCH)
        .map_err(|_| dsq_shared::error::operation_error("System time is before UNIX epoch"))?;
    let seconds = duration.as_secs() as i64;

    if args.is_empty() {
        return Ok(Value::Int(seconds));
    }

    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("systime_int() expects 0 or 1 arguments"));
    }

    match &args[0] {
        Value::Array(arr) => {
            let current_times: Vec<Value> = (0..arr.len()).map(|_| Value::Int(seconds)).collect();
            Ok(Value::Array(current_times))
        }
        Value::DataFrame(df) => {
            // Add a new column with current time for each row
            let mut new_df = df.clone();
            let time_series = Series::new("systime_int", vec![seconds; df.height()]);
            match new_df.with_column(time_series) {
                Ok(_) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("systime_int() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            let time_series = Series::new(series.name(), vec![seconds; series.len()]);
            Ok(Value::Series(time_series))
        }
        _ => Ok(Value::Int(seconds)),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_tostring(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("tostring() expects 1 argument"));
    }

    Ok(Value::String(args[0].to_string()))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_tonumber(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("tonumber() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            if let Ok(i) = s.parse::<i64>() {
                Ok(Value::Int(i))
            } else if let Ok(f) = s.parse::<f64>() {
                Ok(Value::Float(f))
            } else {
                Err(dsq_shared::error::operation_error(format!("Cannot parse '{}' as number", s)))
            }
        }
        Value::Int(_) | Value::Float(_) => Ok(args[0].clone()),
        _ => Err(dsq_shared::error::operation_error("Cannot convert to number")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}


fn builtin_join_strings(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("join() expects 2 arguments"));
    }

    match (&args[0], &args[1]) {
        (Value::Array(arr), Value::String(separator)) => {
            let strings: Result<Vec<String>> = arr.iter()
                .map(|v| match v {
                    Value::String(s) => Ok(s.clone()),
                    _ => Ok(v.to_string()),
                })
                .collect();

            Ok(Value::String(strings?.join(separator)))
        }
        _ => Err(dsq_shared::error::operation_error("join() requires array, string")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_concat(args: &[Value]) -> Result<Value> {
    if args.is_empty() {
        return Err(dsq_shared::error::operation_error("concat() expects at least 1 argument"));
    }

    // For single argument, handle arrays, DataFrames, Series
    if args.len() == 1 {
        match &args[0] {
            Value::Array(arr) => {
                let concatenated: String = arr.iter()
                    .map(|v| v.to_string())
                    .collect();
                Ok(Value::String(concatenated))
            }
            Value::DataFrame(df) => {
                // Concatenate all values from all columns
                let mut result = String::new();
                for col_name in df.get_column_names() {
                    if let Ok(series) = df.column(col_name) {
                        for i in 0..series.len() {
                            if let Ok(val) = series.get(i) {
                                let value = value_from_any_value(val).unwrap_or(Value::Null);
                                result.push_str(&value.to_string());
                            }
                        }
                    }
                }
                Ok(Value::String(result))
            }
            Value::Series(series) => {
                let mut result = String::new();
                for i in 0..series.len() {
                    if let Ok(val) = series.get(i) {
                        let value = value_from_any_value(val).unwrap_or(Value::Null);
                        result.push_str(&value.to_string());
                    }
                }
                Ok(Value::String(result))
            }
            _ => Ok(Value::String(args[0].to_string())),
        }
    } else {
        // Multiple arguments: concatenate all as strings
        let concatenated: String = args.iter()
            .map(|v| v.to_string())
            .collect();
        Ok(Value::String(concatenated))
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_startswith(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("startswith() expects 2 arguments"));
    }

    match (&args[0], &args[1]) {
        (Value::String(s), Value::String(prefix)) => {
            Ok(Value::Bool(s.starts_with(prefix)))
        }
        _ => Err(dsq_shared::error::operation_error("startswith() requires string, string")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_endswith(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("endswith() expects 2 arguments"));
    }

    match (&args[0], &args[1]) {
        (Value::String(s), Value::String(suffix)) => {
            Ok(Value::Bool(s.ends_with(suffix)))
        }
        _ => Err(dsq_shared::error::operation_error("endswith() requires string, string")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_lstrip(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("lstrip() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.trim_start().to_string()))
        }
        Value::Array(arr) => {
            let stripped: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.trim_start().to_string()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(stripped))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let stripped_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.trim_start().to_string()))
                        }).into_series();
                        let mut s = stripped_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("lstrip() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let stripped_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.trim_start().to_string()))
                }).into_series();
                Ok(Value::Series(stripped_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_rstrip(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("rstrip() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.trim_end().to_string()))
        }
        Value::Array(arr) => {
            let stripped: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.trim_end().to_string()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(stripped))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let stripped_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.trim_end().to_string()))
                        }).into_series();
                        let mut s = stripped_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("rstrip() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let stripped_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.trim_end().to_string()))
                }).into_series();
                Ok(Value::Series(stripped_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_trim(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("trim() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.trim().to_string()))
        }
        Value::Array(arr) => {
            let trimmed: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.trim().to_string()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(trimmed))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let trimmed_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.trim().to_string()))
                        }).into_series();
                        let mut s = trimmed_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("trim() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let trimmed_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.trim().to_string()))
                }).into_series();
                Ok(Value::Series(trimmed_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_tolower(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("tolower() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_lowercase()))
        }
        Value::Array(arr) => {
            let lowered: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_lowercase()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(lowered))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let lowered_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_lowercase()))
                        }).into_series();
                        let mut s = lowered_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("tolower() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let lowered_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_lowercase()))
                }).into_series();
                Ok(Value::Series(lowered_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_toupper(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("toupper() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_uppercase()))
        }
        Value::Array(arr) => {
            let uppered: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_uppercase()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(uppered))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let uppered_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_uppercase()))
                        }).into_series();
                        let mut s = uppered_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("toupper() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let uppered_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_uppercase()))
                }).into_series();
                Ok(Value::Series(uppered_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_replace(args: &[Value]) -> Result<Value> {
    if args.len() != 3 {
        return Err(dsq_shared::error::operation_error("replace() expects 3 arguments: string, pattern, replacement"));
    }

    let pattern = match &args[1] {
        Value::String(s) => s.clone(),
        _ => return Err(dsq_shared::error::operation_error("replace() second argument must be a string pattern")),
    };

    let replacement = match &args[2] {
        Value::String(s) => s.clone(),
        _ => return Err(dsq_shared::error::operation_error("replace() third argument must be a string replacement")),
    };

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.replace(&pattern, &replacement)))
        }
        Value::Array(arr) => {
            let replaced: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.replace(&pattern, &replacement)),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(replaced))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let replaced_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.replace(&pattern, &replacement)))
                        }).into_series();
                        let mut s = replaced_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("replace() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let replaced_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.replace(&pattern, &replacement)))
                }).into_series();
                Ok(Value::Series(replaced_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_contains(args: &[Value]) -> Result<Value> {
    if args.len() == 1 {
        // When used with piping: value | contains(substring)
        // The piped value should be checked against this argument
        // But since we don't have the piped value here, this might be a parser issue
        // For now, assume the argument is the substring and we need the piped value
        // This is a limitation of the current architecture
        return Err(dsq_shared::error::operation_error("contains() with 1 argument not supported in this context"));
    } else if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("contains() expects 1 or 2 arguments"));
    }

    match (&args[0], &args[1]) {
        (Value::String(s), Value::String(substring)) => {
            Ok(Value::Bool(s.contains(substring)))
        }
        (Value::Array(arr), value) => {
            Ok(Value::Bool(arr.contains(value)))
        }
        _ => Ok(Value::Bool(false)),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_tojson(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("tojson() expects 1 argument"));
    }

    match serde_json::to_string(&args[0]) {
        Ok(json_str) => Ok(Value::String(json_str)),
        Err(e) => Err(dsq_shared::error::operation_error(format!("tojson() failed: {}", e))),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_base32_encode(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("base32_encode() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(encode(Alphabet::RFC4648 { padding: false }, s.as_bytes())))
        }
        Value::Array(arr) => {
            let encoded: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Ok(Value::String(encode(Alphabet::RFC4648 { padding: false }, s.as_bytes()))),
                    _ => Ok(Value::String(encode(Alphabet::RFC4648 { padding: false }, v.to_string().as_bytes()))),
                }
            }).collect();
            Ok(Value::Array(encoded?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let encoded_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(encode(Alphabet::RFC4648 { padding: false }, s.as_bytes())))
                        }).into_series();
                        let mut s = encoded_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("base32_encode() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let encoded_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(encode(Alphabet::RFC4648 { padding: false }, s.as_bytes())))
                }).into_series();
                Ok(Value::Series(encoded_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("base32_encode() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_base32_decode(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("base32_decode() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            match decode(Alphabet::RFC4648 { padding: false }, s) {
                Some(bytes) => match String::from_utf8(bytes) {
                    Ok(decoded) => Ok(Value::String(decoded)),
                    Err(_) => Err(dsq_shared::error::operation_error("base32_decode() decoded bytes are not valid UTF-8")),
                },
                None => Err(dsq_shared::error::operation_error("base32_decode() invalid base32 string")),
            }
        }
        Value::Array(arr) => {
            let decoded: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => match decode(Alphabet::RFC4648 { padding: false }, s) {
                        Some(bytes) => match String::from_utf8(bytes) {
                            Ok(decoded) => Ok(Value::String(decoded)),
                            Err(_) => Err(dsq_shared::error::operation_error("base32_decode() decoded bytes are not valid UTF-8")),
                        },
                        None => Err(dsq_shared::error::operation_error("base32_decode() invalid base32 string")),
                    },
                    _ => Err(dsq_shared::error::operation_error("base32_decode() requires string elements in array")),
                }
            }).collect();
            Ok(Value::Array(decoded?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let decoded_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                match decode(Alphabet::RFC4648 { padding: false }, s) {
                                    Some(bytes) => match String::from_utf8(bytes) {
                                        Ok(decoded) => Some(Cow::Owned(decoded)),
                                        Err(_) => None,
                                    },
                                    None => None,
                                }
                            })
                        }).into_series();
                        let mut s = decoded_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("base32_decode() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let decoded_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        match decode(Alphabet::RFC4648 { padding: false }, s) {
                            Some(bytes) => match String::from_utf8(bytes) {
                                Ok(decoded) => Some(Cow::Owned(decoded)),
                                Err(_) => None,
                            },
                            None => None,
                        }
                    })
                }).into_series();
                Ok(Value::Series(decoded_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("base32_decode() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_base58_encode(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("base58_encode() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.as_bytes().to_base58()))
        }
        Value::Array(arr) => {
            let encoded: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.as_bytes().to_base58()),
                    _ => Value::String(v.to_string().as_bytes().to_base58()),
                }
            }).collect();
            Ok(Value::Array(encoded))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let encoded_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.as_bytes().to_base58()))
                        }).into_series();
                        let mut s = encoded_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("base58_encode() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let encoded_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.as_bytes().to_base58()))
                }).into_series();
                Ok(Value::Series(encoded_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("base58_encode() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_base58_decode(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("base58_decode() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            match s.from_base58() {
                Ok(bytes) => match String::from_utf8(bytes) {
                    Ok(decoded) => Ok(Value::String(decoded)),
                    Err(_) => Err(dsq_shared::error::operation_error("base58_decode() decoded bytes are not valid UTF-8")),
                },
                Err(_) => Err(dsq_shared::error::operation_error("base58_decode() invalid base58 string")),
            }
        }
        Value::Array(arr) => {
            let decoded: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => match s.from_base58() {
                        Ok(bytes) => match String::from_utf8(bytes) {
                            Ok(decoded) => Ok(Value::String(decoded)),
                            Err(_) => Err(dsq_shared::error::operation_error("base58_decode() decoded bytes are not valid UTF-8")),
                        },
                        Err(_) => Err(dsq_shared::error::operation_error("base58_decode() invalid base58 string")),
                    },
                    _ => Err(dsq_shared::error::operation_error("base58_decode() requires string elements in array")),
                }
            }).collect();
            Ok(Value::Array(decoded?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let decoded_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                match s.from_base58() {
                                    Ok(bytes) => match String::from_utf8(bytes) {
                                        Ok(decoded) => Some(Cow::Owned(decoded)),
                                        Err(_) => None,
                                    },
                                    Err(_) => None,
                                }
                            })
                        }).into_series();
                        let mut s = decoded_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("base58_decode() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let decoded_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        match s.from_base58() {
                            Ok(bytes) => match String::from_utf8(bytes) {
                                Ok(decoded) => Some(Cow::Owned(decoded)),
                                Err(_) => None,
                            },
                            Err(_) => None,
                        }
                    })
                }).into_series();
                Ok(Value::Series(decoded_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("base58_decode() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_sha512(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("sha512() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            let mut hasher = Sha512::new();
            hasher.update(s.as_bytes());
            let result = hasher.finalize();
            Ok(Value::String(format!("{:x}", result)))
        }
        Value::Array(arr) => {
            let hashed: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => {
                        let mut hasher = Sha512::new();
                        hasher.update(s.as_bytes());
                        let result = hasher.finalize();
                        Ok(Value::String(format!("{:x}", result)))
                    }
                    _ => Ok(Value::String(sha512_value(v))),
                }
            }).collect();
            Ok(Value::Array(hashed?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let hashed_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(sha512_string(s)))
                        }).into_series();
                        let mut s = hashed_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("sha512() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let hashed_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(sha512_string(s)))
                }).into_series();
                Ok(Value::Series(hashed_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("sha512() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_sha1(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("sha1() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            let mut hasher = Sha1::new();
            hasher.update(s.as_bytes());
            let result = hasher.finalize();
            Ok(Value::String(format!("{:x}", result)))
        }
        Value::Array(arr) => {
            let hashed: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => {
                        let mut hasher = Sha1::new();
                        hasher.update(s.as_bytes());
                        let result = hasher.finalize();
                        Ok(Value::String(format!("{:x}", result)))
                    }
                    _ => Ok(Value::String(sha1_value(v))),
                }
            }).collect();
            Ok(Value::Array(hashed?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    let hashed_series = if series.dtype() == &DataType::Utf8 {
                        series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(sha1_string(s)))
                        }).into_series()
                    } else {
                        // Leave non-Utf8 columns unchanged
                        series.clone()
                    };
                    let mut s = hashed_series;
                    s.rename(col_name);
                    new_series.push(s);
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("sha1() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let hashed_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(sha1_string(s)))
                }).into_series();
                Ok(Value::Series(hashed_series))
            } else {
                let mut hashed_values = Vec::new();
                for i in 0..series.len() {
                    if let Ok(val) = series.get(i) {
                        let s = val.to_string();
                        hashed_values.push(sha1_string(&s));
                    } else {
                        hashed_values.push("".to_string());
                    }
                }
                Ok(Value::Series(Series::new(series.name(), hashed_values)))
            }
        }
        _ => Err(dsq_shared::error::operation_error("sha1() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_md5(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("md5() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(format!("{:x}", md5::compute(s.as_bytes()))))
        }
        Value::Array(arr) => {
            let hashed: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => {
                        Ok(Value::String(format!("{:x}", md5::compute(s.as_bytes()))))
                    }
                    _ => Ok(Value::String(md5_value(v))),
                }
            }).collect();
            Ok(Value::Array(hashed?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let hashed_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(md5_string(s)))
                        }).into_series();
                        let mut s = hashed_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("md5() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let hashed_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(md5_string(s)))
                }).into_series();
                Ok(Value::Series(hashed_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("md5() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_sha256(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("sha256() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            let mut hasher = Sha256::new();
            hasher.update(s.as_bytes());
            let result = hasher.finalize();
            Ok(Value::String(format!("{:x}", result)))
        }
        Value::Array(arr) => {
            let hashed: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => {
                        let mut hasher = Sha256::new();
                        hasher.update(s.as_bytes());
                        let result = hasher.finalize();
                        Ok(Value::String(format!("{:x}", result)))
                    }
                    _ => Ok(Value::String(sha256_value(v))),
                }
            }).collect();
            Ok(Value::Array(hashed?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let hashed_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(sha256_string(s)))
                        }).into_series();
                        let mut s = hashed_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("sha256() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let hashed_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(sha256_string(s)))
                }).into_series();
                Ok(Value::Series(hashed_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("sha256() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_base64_encode(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("base64_encode() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(general_purpose::STANDARD.encode(s.as_bytes())))
        }
        Value::Array(arr) => {
            let encoded: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Ok(Value::String(general_purpose::STANDARD.encode(s.as_bytes()))),
                    _ => Ok(Value::String(general_purpose::STANDARD.encode(v.to_string().as_bytes()))),
                }
            }).collect();
            Ok(Value::Array(encoded?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let encoded_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(general_purpose::STANDARD.encode(s.as_bytes())))
                        }).into_series();
                        let mut s = encoded_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("base64_encode() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let encoded_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(general_purpose::STANDARD.encode(s.as_bytes())))
                }).into_series();
                Ok(Value::Series(encoded_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("base64_encode() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_base64_decode(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("base64_decode() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            match general_purpose::STANDARD.decode(s) {
                Ok(bytes) => match String::from_utf8(bytes) {
                    Ok(decoded) => Ok(Value::String(decoded)),
                    Err(_) => Err(dsq_shared::error::operation_error("base64_decode() decoded bytes are not valid UTF-8")),
                },
                Err(_) => Err(dsq_shared::error::operation_error("base64_decode() invalid base64 string")),
            }
        }
        Value::Array(arr) => {
            let decoded: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => match general_purpose::STANDARD.decode(s) {
                        Ok(bytes) => match String::from_utf8(bytes) {
                            Ok(decoded) => Ok(Value::String(decoded)),
                            Err(_) => Err(dsq_shared::error::operation_error("base64_decode() decoded bytes are not valid UTF-8")),
                        },
                        Err(_) => Err(dsq_shared::error::operation_error("base64_decode() invalid base64 string")),
                    },
                    _ => Err(dsq_shared::error::operation_error("base64_decode() requires string elements in array")),
                }
            }).collect();
            Ok(Value::Array(decoded?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let decoded_series = series.utf8().unwrap().apply(|s| {
                            s.and_then(|s| {
                                match general_purpose::STANDARD.decode(s) {
                                    Ok(bytes) => match String::from_utf8(bytes) {
                                        Ok(decoded) => Some(Cow::Owned(decoded)),
                                        Err(_) => None,
                                    },
                                    Err(_) => None,
                                }
                            })
                        }).into_series();
                        let mut s = decoded_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("base64_decode() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let decoded_series = series.utf8().unwrap().apply(|s| {
                    s.and_then(|s| {
                        match general_purpose::STANDARD.decode(s) {
                            Ok(bytes) => match String::from_utf8(bytes) {
                                Ok(decoded) => Some(Cow::Owned(decoded)),
                                Err(_) => None,
                            },
                            Err(_) => None,
                        }
                    })
                }).into_series();
                Ok(Value::Series(decoded_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("base64_decode() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

#[test]
fn test_builtin_base64_encode_string() {
    let result = builtin_base64_encode(&[Value::String("Hello, World!".to_string())]).unwrap();
    assert_eq!(result, Value::String("SGVsbG8sIFdvcmxkIQ==".to_string()));

    let result = builtin_base64_encode(&[Value::String("Base64 encoding demo".to_string())]).unwrap();
    assert_eq!(result, Value::String("QmFzZTY0IGVuY29kaW5nIGRlbW8=".to_string()));
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

#[test]
fn test_builtin_base64_encode_array() {
    let arr = vec![
        Value::String("test".to_string()),
        Value::String("data".to_string()),
    ];
    let result = builtin_base64_encode(&[Value::Array(arr)]).unwrap();
    match result {
        Value::Array(encoded) => {
            assert_eq!(encoded.len(), 2);
            assert_eq!(encoded[0], Value::String("dGVzdA==".to_string()));
            assert_eq!(encoded[1], Value::String("ZGF0YQ==".to_string()));
        }
        _ => panic!("Expected Array"),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

#[test]
fn test_builtin_base64_encode_dataframe() {
    let df = DataFrame::new(vec![
        Series::new("text", vec!["Hello", "World"]),
        Series::new("numbers", vec![1i64, 2i64]),
    ]).unwrap();
    let result = builtin_base64_encode(&[Value::DataFrame(df.clone())]).unwrap();
    match result {
        Value::DataFrame(result_df) => {
            assert_eq!(result_df.height(), 2);
            let text_col = result_df.column("text").unwrap();
            assert_eq!(text_col.dtype(), &DataType::Utf8);
            if let Ok(AnyValue::Utf8(val0)) = text_col.get(0) {
                assert_eq!(val0, "SGVsbG8=");
            }
            if let Ok(AnyValue::Utf8(val1)) = text_col.get(1) {
                assert_eq!(val1, "V29ybGQ=");
            }
            // numbers column should remain unchanged
            let numbers_col = result_df.column("numbers").unwrap();
            assert_eq!(numbers_col.dtype(), &DataType::Int64);
        }
        _ => panic!("Expected DataFrame"),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

#[test]
fn test_builtin_base64_encode_series() {
    let series = Series::new("text", vec!["test", "data"]);
    let result = builtin_base64_encode(&[Value::Series(series)]).unwrap();
    match result {
        Value::Series(result_series) => {
            assert_eq!(result_series.len(), 2);
            assert_eq!(result_series.dtype(), &DataType::Utf8);
            if let Ok(AnyValue::Utf8(val0)) = result_series.get(0) {
                assert_eq!(val0, "dGVzdA==");
            }
            if let Ok(AnyValue::Utf8(val1)) = result_series.get(1) {
                assert_eq!(val1, "ZGF0YQ==");
            }
        }
        _ => panic!("Expected Series"),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

#[test]
fn test_builtin_base64_encode_invalid_args() {
    // No args
    let result = builtin_base64_encode(&[]);
    assert!(result.is_err());

    // Too many args
    let result = builtin_base64_encode(&[Value::String("test".to_string()), Value::String("extra".to_string())]);
    assert!(result.is_err());

    // Invalid type
    let result = builtin_base64_encode(&[Value::Int(123)]);
    assert!(result.is_err());
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

#[test]
fn test_builtin_base64_decode_string() {
    let result = builtin_base64_decode(&[Value::String("SGVsbG8sIFdvcmxkIQ==".to_string())]).unwrap();
    assert_eq!(result, Value::String("Hello, World!".to_string()));

    let result = builtin_base64_decode(&[Value::String("QmFzZTY0IGVuY29kaW5nIGRlbW8=".to_string())]).unwrap();
    assert_eq!(result, Value::String("Base64 encoding demo".to_string()));
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

#[test]
fn test_builtin_base64_decode_invalid() {
    let result = builtin_base64_decode(&[Value::String("invalid base64!".to_string())]);
    assert!(result.is_err());

    let result = builtin_base64_decode(&[Value::String("not-base64".to_string())]);
    assert!(result.is_err());
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn sha512_string(s: &str) -> String {
    let mut hasher = Sha512::new();
    hasher.update(s.as_bytes());
    let result = hasher.finalize();
    format!("{:x}", result)
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn sha512_value(v: &Value) -> String {
    let s = v.to_string();
    sha512_string(&s)
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn sha256_string(s: &str) -> String {
    let mut hasher = Sha256::new();
    hasher.update(s.as_bytes());
    let result = hasher.finalize();
    format!("{:x}", result)
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn sha256_value(v: &Value) -> String {
    let s = v.to_string();
    sha256_string(&s)
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn md5_string(s: &str) -> String {
    format!("{:x}", md5::compute(s.as_bytes()))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn md5_value(v: &Value) -> String {
    let s = v.to_string();
    md5_string(&s)
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn sha1_string(s: &str) -> String {
    let mut hasher = Sha1::new();
    hasher.update(s.as_bytes());
    let result = hasher.finalize();
    format!("{:x}", result)
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn sha1_value(v: &Value) -> String {
    let s = v.to_string();
    sha1_string(&s)
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_mround(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("mround() expects 2 arguments: number and multiple"));
    }

    let multiple = match &args[1] {
        Value::Int(i) => *i as f64,
        Value::Float(f) => *f,
        _ => return Err(dsq_shared::error::operation_error("mround() second argument must be a number")),
    };

    if multiple == 0.0 {
        return Err(dsq_shared::error::operation_error("mround() multiple cannot be zero"));
    }

    match &args[0] {
        Value::Int(i) => {
            let number = *i as f64;
            let result = (number / multiple).round() * multiple;
            if result.fract() == 0.0 && result >= i64::MIN as f64 && result <= i64::MAX as f64 {
                return Ok(Value::Int(result as i64));
            } else {
                return Ok(Value::Float(result));
            }
        }
        Value::Float(f) => {
            let result = (f / multiple).round() * multiple;
            return Ok(Value::Float(result));
        }
        Value::Array(arr) => {
            let mround_values: Result<Vec<Value>> = arr.iter().map(|v| builtin_mround(&[v.clone(), args[1].clone()])).collect();
            return Ok(Value::Array(mround_values?));
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype().is_numeric() {
                        let mround_values: Vec<AnyValue> = (0..series.len())
                            .filter_map(|i| series.get(i).ok())
                            .map(|val| match val {
                                AnyValue::Int64(n) => {
                                    let number = n as f64;
                                    let result = (number / multiple).round() * multiple;
                                    if result.fract() == 0.0 && result >= i64::MIN as f64 && result <= i64::MAX as f64 {
                                        AnyValue::Int64(result as i64)
                                    } else {
                                        AnyValue::Float64(result)
                                    }
                                }
                                AnyValue::Float64(n) => {
                                    let result = (n / multiple).round() * multiple;
                                    AnyValue::Float64(result)
                                }
                                _ => AnyValue::Float64(0.0), // or handle error
                            })
                            .collect();
                        let mround_series = Series::new(col_name, mround_values);
                        new_series.push(mround_series);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            return match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("mround() failed on DataFrame: {}", e))),
            };
        }
        Value::Series(series) => {
            if series.dtype().is_numeric() {
                let mround_values: Vec<AnyValue> = (0..series.len())
                    .filter_map(|i| series.get(i).ok())
                    .map(|val| match val {
                        AnyValue::Int64(n) => {
                            let number = n as f64;
                            let result = (number / multiple).round() * multiple;
                            if result.fract() == 0.0 && result >= i64::MIN as f64 && result <= i64::MAX as f64 {
                                AnyValue::Int64(result as i64)
                            } else {
                                AnyValue::Float64(result)
                            }
                        }
                        AnyValue::Float64(n) => {
                            let result = (n / multiple).round() * multiple;
                            AnyValue::Float64(result)
                        }
                        _ => AnyValue::Float64(0.0),
                    })
                    .collect();
                return Ok(Value::Series(Series::new(series.name(), mround_values)));
            } else {
                return Ok(Value::Series(series.clone()));
            }
        }
        _ => return Err(dsq_shared::error::operation_error("mround() first argument must be a number, array, DataFrame, or Series")),
    }

    #[test]
    fn test_builtin_mround_int() {
        // Test basic rounding to nearest multiple
        let result = builtin_mround(&[Value::Int(17), Value::Int(5)]).unwrap();
        assert_eq!(result, Value::Int(15));

        let result = builtin_mround(&[Value::Int(18), Value::Int(5)]).unwrap();
        assert_eq!(result, Value::Int(20));

        let result = builtin_mround(&[Value::Int(15), Value::Int(5)]).unwrap();
        assert_eq!(result, Value::Int(15));
    }

    #[test]
    fn test_builtin_mround_float() {
        let result = builtin_mround(&[Value::Float(17.3), Value::Int(5)]).unwrap();
        assert_eq!(result, Value::Float(15.0));

        let result = builtin_mround(&[Value::Float(17.8), Value::Int(5)]).unwrap();
        assert_eq!(result, Value::Float(20.0));
    }

    #[test]
    fn test_builtin_mround_array() {
        let arr = vec![
            Value::Int(12),
            Value::Int(17),
            Value::Int(23),
        ];
        let result = builtin_mround(&[Value::Array(arr), Value::Int(5)]).unwrap();
        match result {
            Value::Array(rounded) => {
                assert_eq!(rounded.len(), 3);
                assert_eq!(rounded[0], Value::Int(10));
                assert_eq!(rounded[1], Value::Int(15));
                assert_eq!(rounded[2], Value::Int(25));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_mround_dataframe() {
        let df = DataFrame::new(vec![
            Series::new("values", vec![12i64, 17i64, 23i64]),
            Series::new("names", vec!["A", "B", "C"]),
        ]).unwrap();
        let result = builtin_mround(&[Value::DataFrame(df.clone()), Value::Int(5)]).unwrap();
        match result {
            Value::DataFrame(result_df) => {
                assert_eq!(result_df.height(), 3);
                // values column should be rounded
                let values_col = result_df.column("values").unwrap();
                assert_eq!(values_col.dtype(), &DataType::Int64);
                if let Ok(AnyValue::Int64(val0)) = values_col.get(0) {
                    assert_eq!(val0, 10);
                }
                if let Ok(AnyValue::Int64(val1)) = values_col.get(1) {
                    assert_eq!(val1, 15);
                }
                if let Ok(AnyValue::Int64(val2)) = values_col.get(2) {
                    assert_eq!(val2, 25);
                }
                // names column should remain unchanged
                let names_col = result_df.column("names").unwrap();
                assert_eq!(names_col.dtype(), &DataType::Utf8);
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_mround_series() {
        let series = Series::new("values", vec![12i64, 17i64, 23i64]);
        let result = builtin_mround(&[Value::Series(series), Value::Int(5)]).unwrap();
        match result {
            Value::Series(result_series) => {
                assert_eq!(result_series.len(), 3);
                assert_eq!(result_series.dtype(), &DataType::Int64);
                if let Ok(AnyValue::Int64(val0)) = result_series.get(0) {
                    assert_eq!(val0, 10);
                }
                if let Ok(AnyValue::Int64(val1)) = result_series.get(1) {
                    assert_eq!(val1, 15);
                }
                if let Ok(AnyValue::Int64(val2)) = result_series.get(2) {
                    assert_eq!(val2, 25);
                }
            }
            _ => panic!("Expected Series"),
        }
    }

    #[test]
    fn test_builtin_mround_zero_multiple() {
        let result = builtin_mround(&[Value::Int(10), Value::Int(0)]);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("multiple cannot be zero"));
    }

    #[test]
    fn test_builtin_mround_invalid_args() {
        // No args
        let result = builtin_mround(&[]);
        assert!(result.is_err());

        // One arg
        let result = builtin_mround(&[Value::Int(10)]);
        assert!(result.is_err());

        // Too many args
        let result = builtin_mround(&[Value::Int(10), Value::Int(5), Value::Int(1)]);
        assert!(result.is_err());

        // Invalid first arg type
        let result = builtin_mround(&[Value::String("10".to_string()), Value::Int(5)]);
        assert!(result.is_err());

        // Invalid second arg type
        let result = builtin_mround(&[Value::Int(10), Value::String("5".to_string())]);
        assert!(result.is_err());
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}








fn builtin_pow(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("pow() expects 2 arguments: base and exponent"));
    }

    let exponent = match &args[1] {
        Value::Int(i) => *i as f64,
        Value::Float(f) => *f,
        Value::BigInt(bi) => bi.to_string().parse::<f64>().unwrap_or(0.0),
        _ => return Err(dsq_shared::error::operation_error("pow() exponent must be a number")),
    };

    match &args[0] {
        Value::Int(i) => {
            let base = *i as f64;
            let result = base.powf(exponent);
            if result.fract() == 0.0 && result >= i64::MIN as f64 && result <= i64::MAX as f64 {
                Ok(Value::Int(result as i64))
            } else {
                Ok(Value::Float(result))
            }
        }
        Value::Float(f) => {
            let result = f.powf(exponent);
            Ok(Value::Float(result))
        }
        Value::BigInt(bi) => {
            let base = bi.to_string().parse::<f64>().unwrap_or(0.0);
            let result = base.powf(exponent);
            Ok(Value::Float(result))
        }
        Value::Array(arr) => {
            let pow_values: Result<Vec<Value>> = arr.iter().map(|v| builtin_pow(&[v.clone(), args[1].clone()])).collect();
            Ok(Value::Array(pow_values?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype().is_numeric() {
                        let pow_values: Vec<AnyValue> = (0..series.len())
                            .filter_map(|i| series.get(i).ok())
                            .map(|val| match val {
                                AnyValue::Int64(n) => {
                                    let base = n as f64;
                                    let result = base.powf(exponent);
                                    if result.fract() == 0.0 && result >= i64::MIN as f64 && result <= i64::MAX as f64 {
                                        AnyValue::Int64(result as i64)
                                    } else {
                                        AnyValue::Float64(result)
                                    }
                                }
                                AnyValue::Float64(n) => {
                                    let result = n.powf(exponent);
                                    AnyValue::Float64(result)
                                }
                                _ => AnyValue::Float64(0.0),
                            })
                            .collect();
                        let pow_series = Series::new(col_name, pow_values);
                        new_series.push(pow_series);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("pow() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype().is_numeric() {
                let pow_values: Vec<AnyValue> = (0..series.len())
                    .filter_map(|i| series.get(i).ok())
                    .map(|val| match val {
                        AnyValue::Int64(n) => {
                            let base = n as f64;
                            let result = base.powf(exponent);
                            if result.fract() == 0.0 && result >= i64::MIN as f64 && result <= i64::MAX as f64 {
                                AnyValue::Int64(result as i64)
                            } else {
                                AnyValue::Float64(result)
                            }
                        }
                        AnyValue::Float64(n) => {
                            let result = n.powf(exponent);
                            AnyValue::Float64(result)
                        }
                        _ => AnyValue::Float64(0.0),
                    })
                    .collect();
                let pow_series = Series::new(series.name(), pow_values);
                Ok(Value::Series(pow_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("pow() base must be a number, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

#[test]
fn test_builtin_pow_int() {
    // Test basic integer powers
    let result = builtin_pow(&[Value::Int(2), Value::Int(3)]).unwrap();
    assert_eq!(result, Value::Int(8));

    let result = builtin_pow(&[Value::Int(5), Value::Int(0)]).unwrap();
    assert_eq!(result, Value::Int(1));

    let result = builtin_pow(&[Value::Int(2), Value::Int(10)]).unwrap();
    assert_eq!(result, Value::Int(1024));
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

#[test]
fn test_builtin_pow_float() {
    let result = builtin_pow(&[Value::Float(2.0), Value::Int(3)]).unwrap();
    assert_eq!(result, Value::Float(8.0));

    let result = builtin_pow(&[Value::Int(2), Value::Float(0.5)]).unwrap();
    assert_eq!(result, Value::Float(1.4142135623730951));

    let result = builtin_pow(&[Value::Float(4.0), Value::Float(0.5)]).unwrap();
    assert_eq!(result, Value::Float(2.0));
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

#[test]
fn test_builtin_pow_array() {
    let arr = vec![
        Value::Int(2),
        Value::Int(3),
        Value::Int(4),
    ];
    let result = builtin_pow(&[Value::Array(arr), Value::Int(2)]).unwrap();
    match result {
        Value::Array(pow_arr) => {
            assert_eq!(pow_arr.len(), 3);
            assert_eq!(pow_arr[0], Value::Int(4));
            assert_eq!(pow_arr[1], Value::Int(9));
            assert_eq!(pow_arr[2], Value::Int(16));
        }
        _ => panic!("Expected Array"),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

#[test]
fn test_builtin_pow_dataframe() {
    let df = DataFrame::new(vec![
        Series::new("bases", vec![2i64, 3i64, 4i64]),
        Series::new("names", vec!["A", "B", "C"]),
    ]).unwrap();
    let result = builtin_pow(&[Value::DataFrame(df.clone()), Value::Int(2)]).unwrap();
    match result {
        Value::DataFrame(result_df) => {
            assert_eq!(result_df.height(), 3);
            // bases column should be powered
            let bases_col = result_df.column("bases").unwrap();
            assert_eq!(bases_col.dtype(), &DataType::Int64);
            if let Ok(AnyValue::Int64(val0)) = bases_col.get(0) {
                assert_eq!(val0, 4);
            }
            if let Ok(AnyValue::Int64(val1)) = bases_col.get(1) {
                assert_eq!(val1, 9);
            }
            if let Ok(AnyValue::Int64(val2)) = bases_col.get(2) {
                assert_eq!(val2, 16);
            }
            // names column should remain unchanged
            let names_col = result_df.column("names").unwrap();
            assert_eq!(names_col.dtype(), &DataType::Utf8);
        }
        _ => panic!("Expected DataFrame"),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

#[test]
fn test_builtin_pow_series() {
    let series = Series::new("bases", vec![2i64, 3i64, 4i64]);
    let result = builtin_pow(&[Value::Series(series), Value::Int(2)]).unwrap();
    match result {
        Value::Series(result_series) => {
            assert_eq!(result_series.len(), 3);
            assert_eq!(result_series.dtype(), &DataType::Int64);
            if let Ok(AnyValue::Int64(val0)) = result_series.get(0) {
                assert_eq!(val0, 4);
            }
            if let Ok(AnyValue::Int64(val1)) = result_series.get(1) {
                assert_eq!(val1, 9);
            }
            if let Ok(AnyValue::Int64(val2)) = result_series.get(2) {
                assert_eq!(val2, 16);
            }
        }
        _ => panic!("Expected Series"),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

#[test]
fn test_builtin_pow_invalid_args() {
    // No args
    let result = builtin_pow(&[]);
    assert!(result.is_err());

    // One arg
    let result = builtin_pow(&[Value::Int(2)]);
    assert!(result.is_err());

    // Too many args
    let result = builtin_pow(&[Value::Int(2), Value::Int(3), Value::Int(1)]);
    assert!(result.is_err());

    // Invalid base type
    let result = builtin_pow(&[Value::String("2".to_string()), Value::Int(3)]);
    assert!(result.is_err());

    // Invalid exponent type
    let result = builtin_pow(&[Value::Int(2), Value::String("3".to_string())]);
    assert!(result.is_err());
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

#[test]
fn test_builtin_pow_edge_cases() {
    // Negative base with fractional exponent
    let _result = builtin_pow(&[Value::Int(-2), Value::Float(0.5)]);
    // This should work as f64 can handle it

    // Zero base
    let result = builtin_pow(&[Value::Int(0), Value::Int(5)]).unwrap();
    assert_eq!(result, Value::Int(0));

    // Zero exponent
    let result = builtin_pow(&[Value::Int(5), Value::Int(0)]).unwrap();
    assert_eq!(result, Value::Int(1));

    // Negative exponent
    let result = builtin_pow(&[Value::Int(2), Value::Int(-1)]).unwrap();
    assert_eq!(result, Value::Float(0.5));
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}




fn builtin_sin(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("sin() expects 1 argument"));
    }

    match &args[0] {
        Value::Int(i) => Ok(Value::Float((*i as f64).sin())),
        Value::Float(f) => Ok(Value::Float(f.sin())),
        Value::BigInt(bi) => Ok(Value::Float(bi.to_string().parse::<f64>().unwrap_or(0.0).sin())),
        Value::Array(arr) => {
            let sin_values: Result<Vec<Value>> = arr.iter().map(|v| builtin_sin(&[v.clone()])).collect();
            Ok(Value::Array(sin_values?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype().is_numeric() {
                        let sin_values: Vec<AnyValue> = (0..series.len())
                            .filter_map(|i| series.get(i).ok())
                            .map(|val| match val {
                                AnyValue::Int64(n) => AnyValue::Float64((n as f64).sin()),
                                AnyValue::Float64(n) => AnyValue::Float64(n.sin()),
                                _ => AnyValue::Float64(0.0), // or handle error
                            })
                            .collect();
                        let sin_series = Series::new(col_name, sin_values);
                        new_series.push(sin_series);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("sin() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype().is_numeric() {
                let sin_values: Vec<AnyValue> = (0..series.len())
                    .filter_map(|i| series.get(i).ok())
                    .map(|val| match val {
                        AnyValue::Int64(n) => AnyValue::Float64((n as f64).sin()),
                        AnyValue::Float64(n) => AnyValue::Float64(n.sin()),
                        _ => AnyValue::Float64(0.0),
                    })
                    .collect();
                Ok(Value::Series(Series::new(series.name(), sin_values)))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("sin() requires int, float, bigint, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}


fn builtin_tan(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("tan() expects 1 argument"));
    }

    let x = match &args[0] {
        Value::Int(i) => *i as f64,
        Value::Float(f) => *f,
        _ => return Err(dsq_shared::error::operation_error("tan() requires a number")),
    };

    Ok(Value::Float(x.tan()))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_asin(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("asin() expects 1 argument"));
    }

    let x = match &args[0] {
        Value::Int(i) => *i as f64,
        Value::Float(f) => *f,
        _ => return Err(dsq_shared::error::operation_error("asin() requires a number")),
    };

    if x < -1.0 || x > 1.0 {
        return Err(dsq_shared::error::operation_error("asin() requires value between -1 and 1"));
    }

    Ok(Value::Float(x.asin()))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_acos(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("acos() expects 1 argument"));
    }

    let x = match &args[0] {
        Value::Int(i) => *i as f64,
        Value::Float(f) => *f,
        _ => return Err(dsq_shared::error::operation_error("acos() requires a number")),
    };

    if x < -1.0 || x > 1.0 {
        return Err(dsq_shared::error::operation_error("acos() requires value between -1 and 1"));
    }

    Ok(Value::Float(x.acos()))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_atan(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("atan() expects 1 argument"));
    }

    let x = match &args[0] {
        Value::Int(i) => *i as f64,
        Value::Float(f) => *f,
        _ => return Err(dsq_shared::error::operation_error("atan() requires a number")),
    };

    Ok(Value::Float(x.atan()))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_exp(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("exp() expects 1 argument"));
    }

    let x = match &args[0] {
        Value::Int(i) => *i as f64,
        Value::Float(f) => *f,
        _ => return Err(dsq_shared::error::operation_error("exp() requires a number")),
    };

    Ok(Value::Float(x.exp()))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_pi(_args: &[Value]) -> Result<Value> {
    Ok(Value::Float(std::f64::consts::PI))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_rand(_args: &[Value]) -> Result<Value> {
    let mut rng = rand::thread_rng();
    Ok(Value::Float(rng.gen()))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_randbetween(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("randbetween() expects 2 arguments: min and max"));
    }

    let min = match &args[0] {
        Value::Int(i) => *i,
        _ => return Err(dsq_shared::error::operation_error("randbetween() min must be an integer")),
    };

    let max = match &args[1] {
        Value::Int(i) => *i,
        _ => return Err(dsq_shared::error::operation_error("randbetween() max must be an integer")),
    };

    if min >= max {
        return Err(dsq_shared::error::operation_error("randbetween() min must be less than max"));
    }

    let mut rng = rand::thread_rng();
    Ok(Value::Int(rng.gen_range(min..=max)))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_randarray(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("randarray() expects 1 argument: count"));
    }

    let count = match &args[0] {
        Value::Int(i) if *i > 0 => *i as usize,
        _ => return Err(dsq_shared::error::operation_error("randarray() count must be a positive integer")),
    };

    let mut rng = rand::thread_rng();
    let values: Vec<Value> = (0..count).map(|_| Value::Float(rng.gen())).collect();
    Ok(Value::Array(values))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_snake_case(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("snake_case() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => return Ok(Value::String(s.to_snake_case())),
        Value::Array(arr) => {
            let converted: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_snake_case()),
                    _ => Value::String(v.to_string().to_snake_case()),
                }
            }).collect();
            return Ok(Value::Array(converted))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let snake_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_snake_case()))
                        }).into_series();
                        let mut s = snake_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("camel_case() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let snake_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_snake_case()))
                }).into_series();
                return Ok(Value::Series(snake_series))
            } else {
                return Ok(Value::Series(series.clone()))
            }
        }
        _ => return Err(dsq_shared::error::operation_error("snake_case() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_camel_case(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("camel_case() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            return Ok(Value::String(s.to_lower_camel_case()))
        }
        Value::Array(arr) => {
            let converted: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_lower_camel_case()),
                    _ => Value::String(v.to_string().to_lower_camel_case()),
                }
            }).collect();
            return Ok(Value::Array(converted))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let camel_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_lower_camel_case()))
                        }).into_series();
                        let mut s = camel_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => return Ok(Value::DataFrame(new_df)),
                Err(e) => return Err(dsq_shared::error::operation_error(format!("camel_case() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let camel_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_lower_camel_case()))
                }).into_series();
                return Ok(Value::Series(camel_series))
            } else {
                return Ok(Value::Series(series.clone()))
            }
        }
        _ => return Err(dsq_shared::error::operation_error("camel_case() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_to_ascii(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("to_ascii() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            let codes: Vec<String> = s.chars().map(|c| (c as u32).to_string()).collect();
            Ok(Value::String(codes.join(" ")))
        }
        Value::Array(arr) => {
            let converted: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => {
                        let codes: Vec<String> = s.chars().map(|c| (c as u32).to_string()).collect();
                        Ok(Value::String(codes.join(" ")))
                    }
                    _ => Err(dsq_shared::error::operation_error("to_ascii() requires string elements in array")),
                }
            }).collect();
            Ok(Value::Array(converted?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let ascii_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| {
                                let codes: Vec<String> = s.chars().map(|c| (c as u32).to_string()).collect();
                                Cow::Owned(codes.join(" "))
                            })
                        }).into_series();
                        let mut s = ascii_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("to_ascii() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let ascii_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| {
                        let codes: Vec<String> = s.chars().map(|c| (c as u32).to_string()).collect();
                        Cow::Owned(codes.join(" "))
                    })
                }).into_series();
                Ok(Value::Series(ascii_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("to_ascii() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_is_valid_utf8(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("is_valid_utf8() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            // If string looks like hex, decode it and check
            if s.len() % 2 == 0 && s.chars().all(|c| c.is_ascii_hexdigit()) && !s.is_empty() {
                let bytes = (0..s.len()).step_by(2).map(|i| {
                    u8::from_str_radix(&s[i..i+2], 16).unwrap_or(0)
                }).collect::<Vec<u8>>();
                Ok(Value::Bool(std::str::from_utf8(&bytes).is_ok()))
            } else {
                Ok(Value::Bool(true)) // Regular string
            }
        }
        Value::Array(arr) => {
            // Check if array contains bytes (integers 0-255)
            let mut bytes = Vec::new();
            for v in arr {
                match v {
                    Value::Int(i) if *i >= 0 && *i <= 255 => bytes.push(*i as u8),
                    _ => return Err(dsq_shared::error::operation_error("is_valid_utf8() array must contain integers 0-255")),
                }
            }
            Ok(Value::Bool(std::str::from_utf8(&bytes).is_ok()))
        }
        Value::DataFrame(_df) => {
            // For DataFrames, check if all string columns contain valid UTF-8
            // Since strings are already validated, this is always true for string columns
            // But we can check if there are any invalid byte sequences in non-string columns
            // For simplicity, return true for DataFrames as they're constructed with valid data
            Ok(Value::Bool(true))
        }
        Value::Series(series) => {
            // For Series, check based on type
            match series.dtype() {
                DataType::Utf8 => Ok(Value::Bool(true)), // String series are valid
                DataType::Binary => {
                    // Check if binary data is valid UTF-8
                    let is_valid = series.binary().unwrap().into_iter().all(|opt_bytes| {
                        opt_bytes.map_or(true, |bytes| std::str::from_utf8(bytes).is_ok())
                    });
                    Ok(Value::Bool(is_valid))
                }
                _ => Ok(Value::Bool(true)), // Other types are not byte data
            }
        }
        _ => Err(dsq_shared::error::operation_error("is_valid_utf8() requires string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}


fn builtin_range(args: &[Value]) -> Result<Value> {
    if args.len() < 1 || args.len() > 3 {
        return Err(dsq_shared::error::operation_error("range() expects 1 to 3 arguments"));
    }

    let start = if args.len() >= 2 {
        match &args[0] {
            Value::Int(i) => *i,
            _ => return Err(dsq_shared::error::operation_error("range() start must be an integer")),
        }
    } else {
        0
    };

    let end = match &args[if args.len() >= 2 { 1 } else { 0 }] {
        Value::Int(i) => *i,
        _ => return Err(dsq_shared::error::operation_error("range() end must be an integer")),
    };

    let step = if args.len() == 3 {
        match &args[2] {
            Value::Int(i) if *i != 0 => *i,
            _ => return Err(dsq_shared::error::operation_error("range() step must be a non-zero integer")),
        }
    } else {
        if start <= end { 1 } else { -1 }
    };

    if (step > 0 && start >= end) || (step < 0 && start <= end) {
        return Ok(Value::Array(Vec::new()));
    }

    let mut result = Vec::new();
    let mut current = start;
    while (step > 0 && current < end) || (step < 0 && current > end) {
        result.push(Value::Int(current));
        current += step;
    }

    Ok(Value::Array(result))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_filter(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("filter() expects 2 arguments"));
    }

    match &args[1] {
        Value::Bool(true) => Ok(args[0].clone()),
        Value::Bool(false) => Ok(Value::Null),
        _ => {
            // Fallback to filtering based on truthiness
            match &args[0] {
            Value::Array(_arr) => {
                    let filtered: Vec<Value> = _arr.iter().filter(|v| is_truthy(v)).cloned().collect();
                    Ok(Value::Array(filtered))
                }
                Value::DataFrame(df) => {
                    // Filter DataFrame to rows where first column is truthy
                    if let Some(col_name) = df.get_column_names().first() {
                        if let Ok(series) = df.column(col_name) {
                            let mut mask = Vec::new();
                            for i in 0..series.len() {
                                if let Ok(val) = series.get(i) {
                                    let value = value_from_any_value(val).unwrap_or(Value::Null);
                                    mask.push(is_truthy(&value));
                                } else {
                                    mask.push(false);
                                }
                            }
                            let mask_series = Series::new("mask", mask);
                            match df.filter(&mask_series.bool().unwrap()) {
                                Ok(filtered_df) => Ok(Value::DataFrame(filtered_df)),
                                Err(e) => Err(dsq_shared::error::operation_error(format!("filter() failed: {}", e))),
                            }
                        } else {
                            Ok(Value::DataFrame(df.clone()))
                        }
                    } else {
                        Ok(Value::DataFrame(df.clone()))
                    }
                }
                _ => Ok(args[0].clone()),
            }
        }
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_del(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("del() expects 2 arguments"));
    }

    match (&args[0], &args[1]) {
        (Value::Object(obj), Value::String(key)) => {
            let mut new_obj = obj.clone();
            new_obj.remove(key);
            Ok(Value::Object(new_obj))
        }
        (Value::Array(arr), Value::Int(index)) => {
            if *index < 0 || *index >= arr.len() as i64 {
                Ok(Value::Array(arr.clone()))
            } else {
                let mut new_arr = arr.clone();
                new_arr.remove(*index as usize);
                Ok(Value::Array(new_arr))
            }
        }
        _ => Ok(args[0].clone()),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_transform_keys(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("transform_keys() expects 2 arguments"));
    }

    match (&args[0], &args[1]) {
        (Value::Object(obj), Value::Object(mapping)) => {
            let mut new_obj = HashMap::new();
            for (key, value) in obj {
                if let Some(new_key) = mapping.get(key) {
                    if let Value::String(s) = new_key {
                        new_obj.insert(s.clone(), value.clone());
                    } else {
                        return Err(dsq_shared::error::operation_error("transform_keys() mapping values must be strings"));
                    }
                } else {
                    new_obj.insert(key.clone(), value.clone());
                }
            }
            Ok(Value::Object(new_obj))
        }
        _ => Err(dsq_shared::error::operation_error("transform_keys() expects (object, object)")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}



fn builtin_unnest(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("unnest() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) => {
            let mut unnested = Vec::new();
            for item in arr {
                match item {
                    Value::Array(inner) => unnested.extend(inner.clone()),
                    _ => unnested.push(item.clone()),
                }
            }
            Ok(Value::Array(unnested))
        }
        _ => Ok(args[0].clone()),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn serde_value_to_value(json_value: serde_json::Value) -> Result<Value> {
    match json_value {
        serde_json::Value::Null => Ok(Value::Null),
        serde_json::Value::Bool(b) => Ok(Value::Bool(b)),
        serde_json::Value::Number(n) => {
            if let Some(i) = n.as_i64() {
                Ok(Value::Int(i))
            } else if let Some(f) = n.as_f64() {
                Ok(Value::Float(f))
            } else {
                Ok(Value::String(n.to_string()))
            }
        }
        serde_json::Value::String(s) => Ok(Value::String(s)),
        serde_json::Value::Array(arr) => {
            let values: Result<Vec<Value>> = arr.into_iter().map(serde_value_to_value).collect();
            Ok(Value::Array(values?))
        }
        serde_json::Value::Object(obj) => {
            let mut map = HashMap::new();
            for (k, v) in obj {
                let value = serde_value_to_value(v)?;
                map.insert(k, value);
            }
            Ok(Value::Object(map))
        }
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_fromjson(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("fromjson() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            match serde_json::from_str::<serde_json::Value>(s) {
                Ok(json_value) => serde_value_to_value(json_value),
                Err(_) => Err(dsq_shared::error::operation_error("fromjson() invalid JSON string")),
            }
        }
        Value::Array(arr) => {
            let parsed: Result<Vec<Value>> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => {
                        match serde_json::from_str::<serde_json::Value>(s) {
                            Ok(json_value) => serde_value_to_value(json_value),
                            Err(_) => Err(dsq_shared::error::operation_error("fromjson() invalid JSON string in array")),
                        }
                    }
                    _ => Err(dsq_shared::error::operation_error("fromjson() requires string elements in array")),
                }
            }).collect();
            Ok(Value::Array(parsed?))
        }
        Value::DataFrame(df) => {
            // For DataFrames, fromjson doesn't make sense - return unchanged
            Ok(Value::DataFrame(df.clone()))
        }
        Value::Series(series) => {
            // For Series, fromjson doesn't make sense - return unchanged
            Ok(Value::Series(series.clone()))
        }
        _ => Err(dsq_shared::error::operation_error("fromjson() requires a string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_generate_sequence(args: &[Value]) -> Result<Value> {
    if args.len() != 3 {
        return Err(dsq_shared::error::operation_error("generate_sequence() expects 3 arguments: start, end, step"));
    }

    let start = match &args[0] {
        Value::Int(i) => *i as f64,
        Value::Float(f) => *f,
        _ => return Err(dsq_shared::error::operation_error("generate_sequence() start must be a number")),
    };

    let end = match &args[1] {
        Value::Int(i) => *i as f64,
        Value::Float(f) => *f,
        _ => return Err(dsq_shared::error::operation_error("generate_sequence() end must be a number")),
    };

    let step = match &args[2] {
        Value::Int(i) => *i as f64,
        Value::Float(f) => *f,
        _ => return Err(dsq_shared::error::operation_error("generate_sequence() step must be a number")),
    };

    if step == 0.0 {
        return Err(dsq_shared::error::operation_error("generate_sequence() step cannot be zero"));
    }

    let mut sequence = Vec::new();
    let mut current = start;

    if step > 0.0 {
        while current < end {
            if current.fract() == 0.0 && current >= i64::MIN as f64 && current <= i64::MAX as f64 {
                sequence.push(Value::Int(current as i64));
            } else {
                sequence.push(Value::Float(current));
            }
            current += step;
        }
    } else {
        while current > end {
            if current.fract() == 0.0 && current >= i64::MIN as f64 && current <= i64::MAX as f64 {
                sequence.push(Value::Int(current as i64));
            } else {
                sequence.push(Value::Float(current));
            }
            current += step;
        }
    }

    Ok(Value::Array(sequence))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_time_series_range(args: &[Value]) -> Result<Value> {
    if args.len() != 3 {
        return Err(dsq_shared::error::operation_error("time_series_range() expects 3 arguments: start_date, end_date, interval"));
    }

    let start_date_str = match &args[0] {
        Value::String(s) => s,
        _ => return Err(dsq_shared::error::operation_error("time_series_range() start_date must be a string")),
    };

    let end_date_str = match &args[1] {
        Value::String(s) => s,
        _ => return Err(dsq_shared::error::operation_error("time_series_range() end_date must be a string")),
    };

    let interval_str = match &args[2] {
        Value::String(s) => s,
        _ => return Err(dsq_shared::error::operation_error("time_series_range() interval must be a string")),
    };

    // Parse dates
    let start_date = match NaiveDate::parse_from_str(start_date_str, "%Y-%m-%d") {
        Ok(d) => d,
        Err(_) => return Err(dsq_shared::error::operation_error("time_series_range() invalid start_date format, expected YYYY-MM-DD")),
    };

    let end_date = match NaiveDate::parse_from_str(end_date_str, "%Y-%m-%d") {
        Ok(d) => d,
        Err(_) => return Err(dsq_shared::error::operation_error("time_series_range() invalid end_date format, expected YYYY-MM-DD")),
    };

    if start_date > end_date {
        return Ok(Value::Array(Vec::new()));
    }

    // Parse interval
    let parts: Vec<&str> = interval_str.split_whitespace().collect();
    if parts.len() != 2 {
        return Err(dsq_shared::error::operation_error("time_series_range() interval must be in format 'N unit' (e.g., '1 day')"));
    }

    let count: i32 = match parts[0].parse() {
        Ok(n) if n > 0 => n,
        _ => return Err(dsq_shared::error::operation_error("time_series_range() interval count must be a positive integer")),
    };

    let unit = parts[1].to_lowercase();

    let step_days = match unit.as_str() {
        "day" | "days" => count,
        "week" | "weeks" => count * 7,
        "month" | "months" => {
            // For months, we need to add months, not days
            // This is approximate, using 30 days per month
            count * 30
        }
        _ => return Err(dsq_shared::error::operation_error("time_series_range() unsupported interval unit, supported: day, week, month")),
    };

    let mut dates = Vec::new();
    let mut current = start_date;
    while current <= end_date {
        dates.push(Value::String(current.format("%Y-%m-%d").to_string()));
        current = match unit.as_str() {
            "month" | "months" => {
                // Add months properly
                let mut year = current.year();
                let mut month = current.month() as i32 + count;
                while month > 12 {
                    year += 1;
                    month -= 12;
                }
                match NaiveDate::from_ymd_opt(year, month as u32, current.day()) {
                    Some(d) => d,
                    None => {
                        // Handle invalid dates (e.g., Feb 30) by using last day of month
                        let last_day = match month as u32 {
                            2 => if year % 4 == 0 && (year % 100 != 0 || year % 400 == 0) { 29 } else { 28 },
                            4 | 6 | 9 | 11 => 30,
                            _ => 31,
                        };
                        NaiveDate::from_ymd_opt(year, month as u32, last_day).unwrap()
                    }
                }
            }
            _ => current + chrono::Duration::days(step_days as i64),
        };
    }

    Ok(Value::Array(dates))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_group_concat(args: &[Value]) -> Result<Value> {
    if args.len() < 1 || args.len() > 2 {
        return Err(dsq_shared::error::operation_error("group_concat() expects 1 or 2 arguments"));
    }

    let separator = if args.len() == 2 {
        match &args[1] {
            Value::String(s) => s.clone(),
            _ => ",".to_string(),
        }
    } else {
        ",".to_string()
    };

    match &args[0] {
        Value::Array(arr) => {
            let strings: Vec<String> = arr.iter().map(|v| v.to_string()).collect();
            Ok(Value::String(strings.join(&separator)))
        }
        Value::DataFrame(df) => {
            // Concatenate first column
            if let Some(col_name) = df.get_column_names().first() {
                if let Ok(series) = df.column(col_name) {
                    let mut strings = Vec::new();
                    for i in 0..series.len() {
                        if let Ok(val) = series.get(i) {
                            strings.push(val.to_string());
                        }
                    }
                    Ok(Value::String(strings.join(&separator)))
                } else {
                    Ok(Value::String("".to_string()))
                }
            } else {
                Ok(Value::String("".to_string()))
            }
        }
        _ => Ok(Value::String(args[0].to_string())),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_generate_uuidv4(args: &[Value]) -> Result<Value> {
    if !args.is_empty() {
        return Err(dsq_shared::error::operation_error("generate_uuidv4() expects no arguments"));
    }

    let uuid = uuid::Uuid::new_v4();
    Ok(Value::String(uuid.to_string()))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_generate_uuidv7(args: &[Value]) -> Result<Value> {
    match args.len() {
        0 => {
            // Generate a new UUID v7 with current timestamp
            let uuid = uuid::Uuid::now_v7();
            Ok(Value::String(uuid.to_string()))
        }
        1 => {
            match &args[0] {
                Value::Array(arr) => {
                    let uuids: Vec<Value> = arr.iter().map(|_| {
                        let uuid = uuid::Uuid::now_v7();
                        Value::String(uuid.to_string())
                    }).collect();
                    Ok(Value::Array(uuids))
                }
                Value::DataFrame(df) => {
                    // Add a new column with UUIDs for each row
                    let mut new_df = df.clone();
                    let uuid_series = Series::new("uuid_v7", (0..df.height()).map(|_| {
                        let uuid = uuid::Uuid::now_v7();
                        uuid.to_string()
                    }).collect::<Vec<String>>());
                    match new_df.with_column(uuid_series) {
                        Ok(_) => Ok(Value::DataFrame(new_df)),
                        Err(e) => Err(dsq_shared::error::operation_error(format!("generate_uuidv7() failed on DataFrame: {}", e))),
                    }
                }
                Value::Series(series) => {
                    let uuid_series = Series::new(series.name(), (0..series.len()).map(|_| {
                        let uuid = uuid::Uuid::now_v7();
                        uuid.to_string()
                    }).collect::<Vec<String>>());
                    Ok(Value::Series(uuid_series))
                }
                _ => {
                    // For single values, generate one UUID
                    let uuid = uuid::Uuid::now_v7();
                    Ok(Value::String(uuid.to_string()))
                }
            }
        }
        _ => Err(dsq_shared::error::operation_error("generate_uuidv7() expects 0 or 1 arguments")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_iif(args: &[Value]) -> Result<Value> {
    if args.len() != 3 {
        return Err(dsq_shared::error::operation_error("iif() expects 3 arguments: condition, true_value, false_value"));
    }

    if is_truthy(&args[0]) {
        Ok(args[1].clone())
    } else {
        Ok(args[2].clone())
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_iferror(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("iferror() expects 2 arguments"));
    }

    // For now, just return the first argument since we don't have error handling
    Ok(args[0].clone())
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_mktime(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("mktime() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            // Try to parse as timestamp
            if let Ok(ts) = s.parse::<i64>() {
                Ok(Value::Int(ts))
            } else {
                // Try to parse as date/datetime string
                if let Ok(dt) = NaiveDate::parse_from_str(s, "%Y-%m-%d") {
                    let timestamp = dt.and_hms_opt(0, 0, 0).unwrap().and_utc().timestamp();
                    Ok(Value::Int(timestamp))
                } else if let Ok(dt) = DateTime::parse_from_rfc3339(s) {
                    Ok(Value::Int(dt.timestamp()))
                } else {
                    Ok(Value::Null)
                }
            }
        }
        Value::Int(i) => Ok(Value::Int(*i)),
        _ => Ok(Value::Null),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

// Math functions
fn builtin_abs(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("abs() expects 1 argument"));
    }

    match &args[0] {
        Value::Int(i) => Ok(Value::Int(i.abs())),
        Value::Float(f) => Ok(Value::Float(f.abs())),
        Value::BigInt(bi) => Ok(Value::BigInt(bi.abs())),
        Value::Array(arr) => {
            let abs_values: Result<Vec<Value>> = arr.iter().map(|v| builtin_abs(&[v.clone()])).collect();
            Ok(Value::Array(abs_values?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype().is_numeric() {
                        // Apply abs element-wise
                        let abs_values: Vec<AnyValue> = (0..series.len())
                            .filter_map(|i| series.get(i).ok())
                            .map(|val| match val {
                                AnyValue::Int64(n) => AnyValue::Int64(n.abs()),
                                AnyValue::Float64(n) => AnyValue::Float64(n.abs()),
                                _ => val,
                            })
                            .collect();
                        let abs_series = Series::new(col_name, abs_values);
                        new_series.push(abs_series);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("abs() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype().is_numeric() {
                // Apply abs element-wise
                let abs_values: Vec<AnyValue> = (0..series.len())
                    .filter_map(|i| series.get(i).ok())
                    .map(|val| match val {
                        AnyValue::Int64(n) => AnyValue::Int64(n.abs()),
                        AnyValue::Float64(n) => AnyValue::Float64(n.abs()),
                        _ => val,
                    })
                    .collect();
                let abs_series = Series::new(series.name(), abs_values);
                Ok(Value::Series(abs_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("abs() requires numeric value, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_floor(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("floor() expects 1 argument"));
    }

    match &args[0] {
        Value::Int(i) => Ok(Value::Int(*i)),
        Value::Float(f) => Ok(Value::Float(f.floor())),
        Value::Array(arr) => {
            let floor_values: Result<Vec<Value>> = arr.iter().map(|v| builtin_floor(&[v.clone()])).collect();
            Ok(Value::Array(floor_values?))
        }
        Value::DataFrame(df) => {
            Ok(Value::DataFrame(df.clone()))
        }
        Value::Series(series) => {
            Ok(Value::Series(series.clone()))
        }
        _ => Err(dsq_shared::error::operation_error("floor() requires numeric value")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_ceil(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("ceil() expects 1 argument"));
    }

    match &args[0] {
        Value::Int(i) => Ok(Value::Int(*i)),
        Value::Float(f) => Ok(Value::Float(f.ceil())),
        Value::BigInt(bi) => {
            let f = bi.to_string().parse::<f64>().unwrap_or(0.0);
            Ok(Value::Float(f.ceil()))
        }
        Value::Array(arr) => {
            let ceil_values: Result<Vec<Value>> = arr.iter().map(|v| builtin_ceil(&[v.clone()])).collect();
            Ok(Value::Array(ceil_values?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype().is_numeric() {
                        // Apply ceil element-wise
                        let ceil_values: Vec<AnyValue> = (0..series.len())
                            .filter_map(|i| series.get(i).ok())
                            .map(|val| match val {
                                AnyValue::Int64(n) => AnyValue::Int64(n),
                                AnyValue::Float64(n) => AnyValue::Float64(n.ceil()),
                                _ => val,
                            })
                            .collect();
                        let ceil_series = Series::new(col_name, ceil_values);
                        new_series.push(ceil_series);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("ceil() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype().is_numeric() {
                // Apply ceil element-wise
                let ceil_values: Vec<AnyValue> = (0..series.len())
                    .filter_map(|i| series.get(i).ok())
                    .map(|val| match val {
                        AnyValue::Int64(n) => AnyValue::Int64(n),
                        AnyValue::Float64(n) => AnyValue::Float64(n.ceil()),
                        _ => val,
                    })
                    .collect();
                let ceil_series = Series::new(series.name(), ceil_values);
                Ok(Value::Series(ceil_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("ceil() requires numeric value, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_roundup(args: &[Value]) -> Result<Value> {
    if args.len() < 1 || args.len() > 2 {
        return Err(dsq_shared::error::operation_error("roundup() expects 1 or 2 arguments"));
    }

    let decimals = if args.len() == 2 {
        match &args[1] {
            Value::Int(i) => *i as i32,
            _ => return Err(dsq_shared::error::operation_error("roundup() decimals must be an integer")),
        }
    } else {
        0
    };

    let scale = 10f64.powi(decimals);

    match &args[0] {
        Value::Int(i) => {
            if decimals == 0 {
                Ok(Value::Int(*i))
            } else {
                Ok(Value::Float(*i as f64))
            }
        }
        Value::Float(f) => {
            let scaled = f * scale;
            let ceiled = scaled.ceil();
            let result = ceiled / scale;
            if decimals == 0 && result.fract() == 0.0 {
                Ok(Value::Int(result as i64))
            } else {
                Ok(Value::Float(result))
            }
        }
        Value::BigInt(bi) => {
            let f = bi.to_string().parse::<f64>().unwrap_or(0.0);
            let scaled = f * scale;
            let ceiled = scaled.ceil();
            let result = ceiled / scale;
            Ok(Value::Float(result))
        }
        Value::Array(arr) => {
            let roundup_values: Result<Vec<Value>> = arr.iter().map(|v| {
                let mut new_args = vec![v.clone()];
                if args.len() == 2 {
                    new_args.push(args[1].clone());
                }
                builtin_roundup(&new_args)
            }).collect();
            Ok(Value::Array(roundup_values?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype().is_numeric() {
                        let roundup_values: Vec<AnyValue> = (0..series.len())
                            .filter_map(|i| series.get(i).ok())
                            .map(|val| match val {
                                AnyValue::Int64(n) => {
                                    if decimals == 0 {
                                        AnyValue::Int64(n)
                                    } else {
                                        AnyValue::Float64(n as f64)
                                    }
                                }
                                AnyValue::Float64(n) => {
                                    let scaled = n * scale;
                                    let ceiled = scaled.ceil();
                                    let result = ceiled / scale;
                                    AnyValue::Float64(result)
                                }
                                _ => val,
                            })
                            .collect();
                        let roundup_series = Series::new(col_name, roundup_values);
                        new_series.push(roundup_series);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("roundup() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype().is_numeric() {
                let roundup_values: Vec<AnyValue> = (0..series.len())
                    .filter_map(|i| series.get(i).ok())
                    .map(|val| match val {
                        AnyValue::Int64(n) => {
                            if decimals == 0 {
                                AnyValue::Int64(n)
                            } else {
                                AnyValue::Float64(n as f64)
                            }
                        }
                        AnyValue::Float64(n) => {
                            let scaled = n * scale;
                            let ceiled = scaled.ceil();
                            let result = ceiled / scale;
                            AnyValue::Float64(result)
                        }
                        _ => val,
                    })
                    .collect();
                let roundup_series = Series::new(series.name(), roundup_values);
                Ok(Value::Series(roundup_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("roundup() requires numeric value, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}









fn builtin_count(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("count() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) => Ok(Value::Int(arr.len() as i64)),
        Value::Object(obj) => Ok(Value::Int(obj.len() as i64)),
        Value::Series(series) => Ok(Value::Int(series.len() as i64)),
        Value::DataFrame(df) => Ok(Value::Int(df.height() as i64)),
        Value::String(s) => Ok(Value::Int(s.chars().count() as i64)),
        _ => Ok(Value::Int(1)), // For other values, count as 1
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_median(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("median() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) => {
            if arr.is_empty() {
                return Ok(Value::Null);
            }

            let mut values: Vec<f64> = Vec::new();
            for val in arr {
                match val {
                    Value::Int(i) => values.push(*i as f64),
                    Value::Float(f) => values.push(*f),
                    _ => return Err(dsq_shared::error::operation_error("median() requires numeric array")),
                }
            }

            values.sort_by(|a, b| a.partial_cmp(b).unwrap());
            let len = values.len();
            if len % 2 == 0 {
                let mid = len / 2;
                Ok(Value::Float((values[mid - 1] + values[mid]) / 2.0))
            } else {
                Ok(Value::Float(values[len / 2]))
            }
        }
        Value::Series(series) => {
            if series.dtype().is_numeric() {
                let median_result = series.median();
                match median_result {
                    Some(median) => Ok(Value::Float(median)),
                    None => Ok(Value::Null),
                }
            } else {
                Err(dsq_shared::error::operation_error("median() requires numeric series"))
            }
        }
        _ => Err(dsq_shared::error::operation_error("median() requires array or series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_std(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("std() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) => {
            if arr.is_empty() {
                return Ok(Value::Null);
            }

            let mut values: Vec<f64> = Vec::new();
            for val in arr {
                match val {
                    Value::Int(i) => values.push(*i as f64),
                    Value::Float(f) => values.push(*f),
                    _ => return Err(dsq_shared::error::operation_error("std() requires numeric array")),
                }
            }

            let mean = values.iter().sum::<f64>() / values.len() as f64;
            let variance = values.iter().map(|v| (v - mean).powi(2)).sum::<f64>() / values.len() as f64;
            Ok(Value::Float(variance.sqrt()))
        }
        Value::Series(series) => {
            if series.dtype().is_numeric() {
                // Calculate std manually
                let mut values = Vec::new();
                for i in 0..series.len() {
                    if let Ok(val) = series.get(i) {
                        match val {
                            AnyValue::Int64(n) => values.push(n as f64),
                            AnyValue::Float64(n) => values.push(n),
                            _ => {}
                        }
                    }
                }
                if values.is_empty() {
                    Ok(Value::Null)
                } else {
                    let mean = values.iter().sum::<f64>() / values.len() as f64;
                    let variance = values.iter().map(|v| (v - mean).powi(2)).sum::<f64>() / values.len() as f64;
                    Ok(Value::Float(variance.sqrt()))
                }
            } else {
                Err(dsq_shared::error::operation_error("std() requires numeric series"))
            }
        }
        _ => Err(dsq_shared::error::operation_error("std() requires array or series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_var(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("var() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) => {
            if arr.is_empty() {
                return Ok(Value::Null);
            }

            let mut values: Vec<f64> = Vec::new();
            for val in arr {
                match val {
                    Value::Int(i) => values.push(*i as f64),
                    Value::Float(f) => values.push(*f),
                    _ => return Err(dsq_shared::error::operation_error("var() requires numeric array")),
                }
            }

            let mean = values.iter().sum::<f64>() / values.len() as f64;
            let variance = values.iter().map(|v| (v - mean).powi(2)).sum::<f64>() / values.len() as f64;
            Ok(Value::Float(variance))
        }
        Value::Series(series) => {
            if series.dtype().is_numeric() {
                // Calculate var manually
                let mut values = Vec::new();
                for i in 0..series.len() {
                    if let Ok(val) = series.get(i) {
                        match val {
                            AnyValue::Int64(n) => values.push(n as f64),
                            AnyValue::Float64(n) => values.push(n),
                            _ => {}
                        }
                    }
                }
                if values.is_empty() {
                    Ok(Value::Null)
                } else {
                    let mean = values.iter().sum::<f64>() / values.len() as f64;
                    let variance = values.iter().map(|v| (v - mean).powi(2)).sum::<f64>() / values.len() as f64;
                    Ok(Value::Float(variance))
                }
            } else {
                Err(dsq_shared::error::operation_error("var() requires numeric series"))
            }
        }
        _ => Err(dsq_shared::error::operation_error("var() requires array or series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_stdev_p(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("stdev_p() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) => {
            if arr.is_empty() {
                return Ok(Value::Null);
            }

            let mut values: Vec<f64> = Vec::new();
            for val in arr {
                match val {
                    Value::Int(i) => values.push(*i as f64),
                    Value::Float(f) => values.push(*f),
                    _ => return Err(dsq_shared::error::operation_error("stdev_p() requires numeric array")),
                }
            }

            let mean = values.iter().sum::<f64>() / values.len() as f64;
            let variance = values.iter().map(|v| (v - mean).powi(2)).sum::<f64>() / values.len() as f64;
            Ok(Value::Float(variance.sqrt()))
        }
        Value::Series(series) => {
            if series.dtype().is_numeric() {
                // Calculate stdev_p manually
                let mut values = Vec::new();
                for i in 0..series.len() {
                    if let Ok(val) = series.get(i) {
                        match val {
                            AnyValue::Int64(n) => values.push(n as f64),
                            AnyValue::Float64(n) => values.push(n),
                            _ => {}
                        }
                    }
                }
                if values.is_empty() {
                    Ok(Value::Null)
                } else {
                    let mean = values.iter().sum::<f64>() / values.len() as f64;
                    let variance = values.iter().map(|v| (v - mean).powi(2)).sum::<f64>() / values.len() as f64;
                    Ok(Value::Float(variance.sqrt()))
                }
            } else {
                Err(dsq_shared::error::operation_error("stdev_p() requires numeric series"))
            }
        }
        _ => Err(dsq_shared::error::operation_error("stdev_p() requires array or series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_stdev_s(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("stdev_s() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) => {
            if arr.len() < 2 {
                return Ok(Value::Null); // Need at least 2 values for sample standard deviation
            }

            let mut values: Vec<f64> = Vec::new();
            for val in arr {
                match val {
                    Value::Int(i) => values.push(*i as f64),
                    Value::Float(f) => values.push(*f),
                    _ => return Err(dsq_shared::error::operation_error("stdev_s() requires numeric array")),
                }
            }

            let mean = values.iter().sum::<f64>() / values.len() as f64;
            let variance = values.iter().map(|v| (v - mean).powi(2)).sum::<f64>() / (values.len() - 1) as f64;
            Ok(Value::Float(variance.sqrt()))
        }
        Value::Series(series) => {
            if series.dtype().is_numeric() {
                // Calculate stdev_s manually
                let mut values = Vec::new();
                for i in 0..series.len() {
                    if let Ok(val) = series.get(i) {
                        match val {
                            AnyValue::Int64(n) => values.push(n as f64),
                            AnyValue::Float64(n) => values.push(n),
                            _ => {}
                        }
                    }
                }
                if values.len() < 2 {
                    Ok(Value::Null)
                } else {
                    let mean = values.iter().sum::<f64>() / values.len() as f64;
                    let variance = values.iter().map(|v| (v - mean).powi(2)).sum::<f64>() / (values.len() - 1) as f64;
                    Ok(Value::Float(variance.sqrt()))
                }
            } else {
                Err(dsq_shared::error::operation_error("stdev_s() requires numeric series"))
            }
        }
        _ => Err(dsq_shared::error::operation_error("stdev_s() requires array or series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_mean(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("mean() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) => {
            if arr.is_empty() {
                return Ok(Value::Null);
            }

            let mut values: Vec<f64> = Vec::new();
            for val in arr {
                match val {
                    Value::Int(i) => values.push(*i as f64),
                    Value::Float(f) => values.push(*f),
                    _ => return Err(dsq_shared::error::operation_error("mean() requires numeric array")),
                }
            }

            let sum: f64 = values.iter().sum();
            Ok(Value::Float(sum / values.len() as f64))
        }
        Value::Series(series) => {
            if series.dtype().is_numeric() {
                let mut values = Vec::new();
                for i in 0..series.len() {
                    if let Ok(val) = series.get(i) {
                        match val {
                            AnyValue::Int64(n) => values.push(n as f64),
                            AnyValue::Float64(n) => values.push(n),
                            _ => {}
                        }
                    }
                }
                if values.is_empty() {
                    Ok(Value::Null)
                } else {
                    let sum: f64 = values.iter().sum();
                    Ok(Value::Float(sum / values.len() as f64))
                }
            } else {
                Err(dsq_shared::error::operation_error("mean() requires numeric series"))
            }
        }
        _ => Err(dsq_shared::error::operation_error("mean() requires array or series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_sum(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("sum() expects 1 argument"));
    }

    match &args[0] {
        Value::Array(arr) => {
            if arr.is_empty() {
                return Ok(Value::Int(0));
            }

            let mut sum: f64 = 0.0;
            for val in arr {
                match val {
                    Value::Int(i) => sum += *i as f64,
                    Value::Float(f) => sum += *f,
                    _ => return Err(dsq_shared::error::operation_error("sum() requires numeric array")),
                }
            }

            // Return as Int if sum is whole number, otherwise Float
            if sum.fract() == 0.0 && sum >= i64::MIN as f64 && sum <= i64::MAX as f64 {
                Ok(Value::Int(sum as i64))
            } else {
                Ok(Value::Float(sum))
            }
        }
        Value::Series(series) => {
            if series.dtype().is_numeric() {
                let mut sum: f64 = 0.0;
                for i in 0..series.len() {
                    if let Ok(val) = series.get(i) {
                        match val {
                            AnyValue::Int64(n) => sum += n as f64,
                            AnyValue::Float64(n) => sum += n,
                            _ => {}
                        }
                    }
                }
                // Return as Int if sum is whole number, otherwise Float
                if sum.fract() == 0.0 && sum >= i64::MIN as f64 && sum <= i64::MAX as f64 {
                    Ok(Value::Int(sum as i64))
                } else {
                    Ok(Value::Float(sum))
                }
            } else {
                Err(dsq_shared::error::operation_error("sum() requires numeric series"))
            }
        }
        _ => Err(dsq_shared::error::operation_error("sum() requires array or series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

// DataFrame operations
fn builtin_columns(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("columns() expects 1 argument"));
    }

    match &args[0] {
        Value::DataFrame(df) => {
            let columns: Vec<Value> = df.get_column_names()
                .iter()
                .map(|name| Value::String(name.to_string()))
                .collect();
            Ok(Value::Array(columns))
        }
        _ => Err(dsq_shared::error::operation_error("columns() requires DataFrame")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_shape(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("shape() expects 1 argument"));
    }

    match &args[0] {
        Value::DataFrame(df) => {
            let mut shape = HashMap::new();
            shape.insert("rows".to_string(), Value::Int(df.height() as i64));
            shape.insert("columns".to_string(), Value::Int(df.width() as i64));
            Ok(Value::Object(shape))
        }
        Value::Array(arr) => {
            let mut shape = HashMap::new();
            shape.insert("length".to_string(), Value::Int(arr.len() as i64));
            Ok(Value::Object(shape))
        }
        Value::Series(series) => {
            let mut shape = HashMap::new();
            shape.insert("length".to_string(), Value::Int(series.len() as i64));
            Ok(Value::Object(shape))
        }
        _ => Err(dsq_shared::error::operation_error("shape() requires DataFrame, Array, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_dtypes(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("dtypes() expects 1 argument"));
    }

    match &args[0] {
        Value::DataFrame(df) => {
            let mut dtypes = HashMap::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    dtypes.insert(col_name.to_string(), Value::String(series.dtype().to_string()));
                }
            }
            Ok(Value::Object(dtypes))
        }
        Value::Series(series) => {
            let mut dtypes = HashMap::new();
            dtypes.insert("dtype".to_string(), Value::String(series.dtype().to_string()));
            Ok(Value::Object(dtypes))
        }
        _ => Err(dsq_shared::error::operation_error("dtypes() requires DataFrame or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}







// fn builtin_melt(args: &[Value]) -> Result<Value> {
//     if args.len() < 2 {
//         return Err(dsq_shared::error::operation_error("melt() expects at least 2 arguments"));
//     }

//     match &args[0] {
//         Value::DataFrame(df) => {
//             let id_vars: Vec<String> = args[1..].iter().filter_map(|arg| {
//                 match arg {
//                     Value::String(s) => Some(s.clone()),
//                     _ => None,
//                 }
//             }).collect();

//             if id_vars.len() != args.len() - 1 {
//                 return Err(dsq_shared::error::operation_error("melt() id_vars must be strings"));
//             }

//             let value_vars: Vec<String> = df.get_column_names()
//                 .iter()
//                 .filter(|name| !id_vars.contains(&name.to_string()))
//                 .map(|name| name.to_string())
//                 .collect();

//             match df.melt(id_vars, value_vars) {
//                 Ok(melted_df) => Ok(Value::DataFrame(melted_df)),
//                 Err(e) => Err(dsq_shared::error::operation_error(format!("melt() failed: {}", e))),
//             }
//         }
//         _ => Err(dsq_shared::error::operation_error("melt() requires DataFrame")),
//     }
// }

fn builtin_pivot(_args: &[Value]) -> Result<Value> {
    Err(dsq_shared::error::operation_error("pivot() is not implemented yet"))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

// fn builtin_melt(args: &[Value]) -> Result<Value> {
    // if args.len() < 2 || args.len() > 3 {
    //     return Err(dsq_shared::error::operation_error("melt() expects 2 or 3 arguments: dataframe, id_vars, value_vars"));
    // }

    // let df = match &args[0] {
    //     Value::DataFrame(df) => df,
    //     _ => return Err(dsq_shared::error::operation_error("melt() first argument must be DataFrame")),
    // };

    // let id_vars: Vec<&str> = match &args[1] {
    //     Value::String(s) => vec![s.as_str()],
    //     Value::Array(arr) => {
    //         let mut vars = Vec::new();
    //         for v in arr {
    //             if let Value::String(s) = v {
    //                 vars.push(s.as_str());
    //             } else {
    //                 return Err(dsq_shared::error::operation_error("melt() id_vars must be strings"));
    //             }
    //         }
    //         vars
    //     }
    //     _ => return Err(dsq_shared::error::operation_error("melt() second argument must be string or array of strings")),
    // };

    // let value_vars: Option<Vec<&str>> = if args.len() == 3 {
    //     match &args[2] {
    //         Value::String(s) => Some(vec![s.as_str()]),
    //         Value::Array(arr) => {
    //             let mut vars = Vec::new();
    //             for v in arr {
    //                 if let Value::String(s) = v {
    //                     vars.push(s.as_str());
    //                 } else {
    //                     return Err(dsq_shared::error::operation_error("melt() value_vars must be strings"));
    //                 }
    //             }
    //             Some(vars)
    //         }
    //         _ => return Err(dsq_shared::error::operation_error("melt() third argument must be string or array of strings")),
    //     }
    // } else {
    //     None
    // };

    // Err(dsq_shared::error::operation_error("melt() is not implemented"))
// }

// Date/time functions
fn builtin_month(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("month() expects 1 argument"));
    }

    let timestamp = extract_timestamp(&args[0])?;
    let dt = Utc.timestamp_opt(timestamp, 0).single()
        .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
    Ok(Value::Int(dt.month() as i64))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_minute(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("minute() expects 1 argument"));
    }

    match &args[0] {
        Value::Int(i) => {
            let dt = Utc.timestamp_opt(*i, 0).single()
                .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
            Ok(Value::Int(dt.minute() as i64))
        }
        Value::Float(f) => {
            let dt = Utc.timestamp_opt(*f as i64, 0).single()
                .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
            Ok(Value::Int(dt.minute() as i64))
        }
        Value::String(_s) => {
            let timestamp = extract_timestamp(&args[0])?;
            let dt = Utc.timestamp_opt(timestamp, 0).single()
                .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
            Ok(Value::Int(dt.minute() as i64))
        }
        Value::Array(arr) => {
            let minutes: Result<Vec<Value>> = arr.iter().map(|v| {
                builtin_minute(&[v.clone()])
            }).collect();
            Ok(Value::Array(minutes?))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype().is_numeric() {
                        let minute_series = series.i64().unwrap().apply(|ts| {
                            if let Some(ts_val) = ts {
                                let dt = Utc.timestamp_opt(ts_val, 0).single()
                                    .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp")).ok()?;
                                Some(dt.minute() as i64)
                            } else {
                                None
                            }
                        }).into_series();
                        let mut s = minute_series;
                        s.rename(col_name);
                        new_series.push(s);
                     } else if series.dtype() == &DataType::Utf8 {
                         // Check if this is a timestamp column by trying to parse the first non-null value
                         let is_timestamp_column = series.utf8().unwrap().into_iter().any(|s| {
                             s.and_then(|s| extract_timestamp(&Value::String(s.to_string())).ok()).is_some()
                         });
                         if is_timestamp_column {
                             let minutes: Vec<Option<i64>> = series.utf8().unwrap().into_iter().map(|s| {
                                 s.and_then(|s| {
                                     let timestamp = extract_timestamp(&Value::String(s.to_string())).ok()?;
                                     let dt = Utc.timestamp_opt(timestamp, 0).single()
                                         .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp")).ok()?;
                                     Some(dt.minute() as i64)
                                 })
                             }).collect();
                             let minute_series = Series::new(col_name, minutes);
                             new_series.push(minute_series);
                         } else {
                             let mut s = series.clone();
                             s.rename(col_name);
                             new_series.push(s);
                         }
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("minute() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype().is_numeric() {
                let minute_series = series.i64().unwrap().apply(|ts| {
                    if let Some(ts_val) = ts {
                        let dt = Utc.timestamp_opt(ts_val, 0).single()
                            .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp")).ok()?;
                        Some(dt.minute() as i64)
                    } else {
                        None
                    }
                }).into_series();
                Ok(Value::Series(minute_series))
            } else if series.dtype() == &DataType::Utf8 {
                let minutes: Vec<Option<i64>> = series.utf8().unwrap().into_iter().map(|s| {
                    s.and_then(|s| {
                        let timestamp = extract_timestamp(&Value::String(s.to_string())).ok()?;
                        let dt = Utc.timestamp_opt(timestamp, 0).single()
                            .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp")).ok()?;
                        Some(dt.minute() as i64)
                    })
                }).collect();
                let minute_series = Series::new(&series.name(), minutes);
                Ok(Value::Series(minute_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Err(dsq_shared::error::operation_error("minute() requires int, float, string, array, DataFrame, or Series")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_second(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("second() expects 1 argument"));
    }

    let timestamp = extract_timestamp(&args[0])?;
    let dt = Utc.timestamp_opt(timestamp, 0).single()
        .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
    Ok(Value::Int(dt.second() as i64))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_year(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("year() expects 1 argument"));
    }

    let timestamp = extract_timestamp(&args[0])?;
    let dt = Utc.timestamp_opt(timestamp, 0).single()
        .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
    Ok(Value::Int(dt.year() as i64))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_day(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("day() expects 1 argument"));
    }

    let timestamp = extract_timestamp(&args[0])?;
    let dt = Utc.timestamp_opt(timestamp, 0).single()
        .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
    Ok(Value::Int(dt.day() as i64))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_hour(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("hour() expects 1 argument"));
    }

    let timestamp = extract_timestamp(&args[0])?;
    let dt = Utc.timestamp_opt(timestamp, 0).single()
        .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
    Ok(Value::Int(dt.hour() as i64))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}



fn builtin_end_of_month(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("end_of_month() expects 1 argument"));
    }

    let timestamp = extract_timestamp(&args[0])?;
    let dt = Utc.timestamp_opt(timestamp, 0).single()
        .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;
    let last_day = NaiveDate::from_ymd_opt(dt.year(), dt.month() + 1, 1)
        .unwrap_or_else(|| NaiveDate::from_ymd_opt(dt.year() + 1, 1, 1).unwrap())
        .pred_opt()
        .unwrap();
    let end_of_month = Utc.from_utc_datetime(&last_day.and_hms_opt(23, 59, 59).unwrap());
    Ok(Value::Int(end_of_month.timestamp()))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_date_diff(args: &[Value]) -> Result<Value> {
    if args.len() != 3 {
        return Err(dsq_shared::error::operation_error("date_diff() expects 3 arguments: unit, start_date, end_date"));
    }

    let unit = match &args[0] {
        Value::String(s) => s.as_str(),
        _ => return Err(dsq_shared::error::operation_error("date_diff() first argument must be unit string")),
    };

    let start_ts = extract_timestamp(&args[1])?;
    let end_ts = extract_timestamp(&args[2])?;

    let start_dt = Utc.timestamp_opt(start_ts, 0).single()
        .ok_or_else(|| dsq_shared::error::operation_error("Invalid start timestamp"))?;
    let end_dt = Utc.timestamp_opt(end_ts, 0).single()
        .ok_or_else(|| dsq_shared::error::operation_error("Invalid end timestamp"))?;

    let duration = end_dt.signed_duration_since(start_dt);

    match unit {
        "seconds" => Ok(Value::Int(duration.num_seconds())),
        "minutes" => Ok(Value::Int(duration.num_minutes())),
        "hours" => Ok(Value::Int(duration.num_hours())),
        "days" => Ok(Value::Int(duration.num_days())),
        "weeks" => Ok(Value::Int(duration.num_weeks())),
        _ => Err(dsq_shared::error::operation_error("date_diff() unit must be one of: seconds, minutes, hours, days, weeks")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn builtin_truncate_date(args: &[Value]) -> Result<Value> {
    if args.len() != 2 {
        return Err(dsq_shared::error::operation_error("truncate_date() expects 2 arguments: date, unit"));
    }

    let timestamp = extract_timestamp(&args[0])?;
    let unit = match &args[1] {
        Value::String(s) => s.as_str(),
        _ => return Err(dsq_shared::error::operation_error("truncate_date() second argument must be unit string")),
    };

    let dt = Utc.timestamp_opt(timestamp, 0).single()
        .ok_or_else(|| dsq_shared::error::operation_error("Invalid timestamp"))?;

    let truncated = match unit {
        "year" => Utc.from_utc_datetime(&NaiveDate::from_ymd_opt(dt.year(), 1, 1).unwrap().and_hms_opt(0, 0, 0).unwrap()),
        "month" => Utc.from_utc_datetime(&NaiveDate::from_ymd_opt(dt.year(), dt.month(), 1).unwrap().and_hms_opt(0, 0, 0).unwrap()),
        "day" => Utc.from_utc_datetime(&dt.date_naive().and_hms_opt(0, 0, 0).unwrap()),
        "hour" => Utc.from_utc_datetime(&dt.date_naive().and_hms_opt(dt.hour(), 0, 0).unwrap()),
        "minute" => Utc.from_utc_datetime(&dt.date_naive().and_hms_opt(dt.hour(), dt.minute(), 0).unwrap()),
        _ => return Err(dsq_shared::error::operation_error("truncate_date() unit must be one of: year, month, day, hour, minute")),
    };

    Ok(Value::Int(truncated.timestamp()))
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}



// Helper function for sorting
fn compare_values_for_sorting(a: &Value, b: &Value) -> std::cmp::Ordering {
    use std::cmp::Ordering;

    match (a, b) {
        (Value::Null, Value::Null) => Ordering::Equal,
        (Value::Null, _) => Ordering::Less,
        (_, Value::Null) => Ordering::Greater,

        (Value::Bool(a), Value::Bool(b)) => a.cmp(b),
        (Value::Int(a), Value::Int(b)) => a.cmp(b),
        (Value::Float(a), Value::Float(b)) => a.partial_cmp(b).unwrap_or(Ordering::Equal),
        (Value::String(a), Value::String(b)) => a.cmp(b),

        // Cross-type numeric comparisons
        (Value::Int(a), Value::Float(b)) => (*a as f64).partial_cmp(b).unwrap_or(Ordering::Equal),
        (Value::Float(a), Value::Int(b)) => a.partial_cmp(&(*b as f64)).unwrap_or(Ordering::Equal),

        // For complex types, compare string representations
        _ => a.to_string().cmp(&b.to_string()),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

fn extract_timestamp(value: &Value) -> Result<i64> {
    match value {
        Value::Int(i) => Ok(*i),
        Value::Float(f) => Ok(*f as i64),
        Value::String(s) => {
            if let Ok(ts) = s.parse::<i64>() {
                Ok(ts)
            } else if let Ok(dt) = NaiveDate::parse_from_str(s, "%Y-%m-%d") {
                Ok(dt.and_hms_opt(0, 0, 0).unwrap().and_utc().timestamp())
            } else if let Ok(dt) = DateTime::parse_from_rfc3339(s) {
                Ok(dt.timestamp())
            } else {
                Err(dsq_shared::error::operation_error("Cannot parse timestamp from string"))
            }
        }
        _ => Err(dsq_shared::error::operation_error("Cannot extract timestamp from value")),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}











fn builtin_select(args: &[Value]) -> Result<Value> {
    if args.is_empty() || args.len() > 2 {
        return Err(dsq_shared::error::operation_error("select() expects 1 or 2 arguments"));
    }

    if args.len() == 1 {
        if is_truthy(&args[0]) {
            Ok(args[0].clone())
        } else {
            Ok(Value::Null)
        }
    } else {
        match (&args[0], &args[1]) {
            (Value::Array(arr), Value::Array(mask)) if arr.len() == mask.len() => {
                // Filter array using boolean mask
                let filtered: Vec<Value> = arr.iter()
                    .zip(mask.iter())
                    .filter_map(|(item, cond)| {
                        if is_truthy(cond) {
                            Some(item.clone())
                        } else {
                            None
                        }
                    })
                    .collect();
                Ok(Value::Array(filtered))
            }
            (Value::DataFrame(df), Value::Series(mask_series)) if df.height() == mask_series.len() => {
                // Filter DataFrame using boolean series
                let mask: Vec<bool> = (0..mask_series.len())
                    .filter_map(|i| {
                        mask_series.get(i).ok().and_then(|v| {
                            match v {
                                AnyValue::Boolean(b) => Some(b),
                                _ => None,
                            }
                        })
                    })
                    .collect();
                if mask.len() == df.height() {
                    let mask_series = Series::new("mask", mask);
                    match df.filter(&mask_series.bool().unwrap()) {
                        Ok(filtered_df) => Ok(Value::DataFrame(filtered_df)),
                        Err(e) => Err(dsq_shared::error::operation_error(format!("select() failed to filter DataFrame: {}", e))),
                    }
                } else {
                    Err(dsq_shared::error::operation_error("select() mask series length doesn't match DataFrame height"))
                }
            }
            _ => {
                // Default behavior: return first arg if condition is truthy
                if is_truthy(&args[1]) {
                    Ok(args[0].clone())
                } else {
                    Ok(Value::Null)
                }
            }
        }
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dsq_shared::value::Value;

    #[test]
    fn test_builtin_length() {
        // Test array length
        let arr = vec![Value::Int(1), Value::Int(2), Value::Int(3)];
        let result = builtin_length(&[Value::Array(arr)]).unwrap();
        assert_eq!(result, Value::Int(3));

        // Test empty array
        let empty_arr = vec![];
        let result = builtin_length(&[Value::Array(empty_arr)]).unwrap();
        assert_eq!(result, Value::Int(0));

        // Test string length (character count)
        let s = "hello".to_string();
        let result = builtin_length(&[Value::String(s)]).unwrap();
        assert_eq!(result, Value::Int(5));

        // Test empty string
        let empty_s = "".to_string();
        let result = builtin_length(&[Value::String(empty_s)]).unwrap();
        assert_eq!(result, Value::Int(0));

        // Test string with unicode characters
        let unicode_s = "hllo".to_string();
        let result = builtin_length(&[Value::String(unicode_s)]).unwrap();
        assert_eq!(result, Value::Int(5)); // Should count characters, not bytes

        // Test object length (number of keys)
        let mut obj = HashMap::new();
        obj.insert("a".to_string(), Value::Int(1));
        obj.insert("b".to_string(), Value::Int(2));
        let result = builtin_length(&[Value::Object(obj)]).unwrap();
        assert_eq!(result, Value::Int(2));

        // Test empty object
        let empty_obj = HashMap::new();
        let result = builtin_length(&[Value::Object(empty_obj)]).unwrap();
        assert_eq!(result, Value::Int(0));

        // Test DataFrame height
        let df = DataFrame::new(vec![
            Series::new("col1", vec![1, 2, 3]),
            Series::new("col2", vec!["a", "b", "c"]),
        ]).unwrap();
        let result = builtin_length(&[Value::DataFrame(df)]).unwrap();
        assert_eq!(result, Value::Int(3));

        // Test empty DataFrame
        let empty_df = DataFrame::empty();
        let result = builtin_length(&[Value::DataFrame(empty_df)]).unwrap();
        assert_eq!(result, Value::Int(0));

        // Test Series length
        let series = Series::new("test", vec![1, 2, 3, 4, 5]);
        let result = builtin_length(&[Value::Series(series)]).unwrap();
        assert_eq!(result, Value::Int(5));

        // Test empty Series
        let empty_series = Series::new("empty", Vec::<i32>::new());
        let result = builtin_length(&[Value::Series(empty_series)]).unwrap();
        assert_eq!(result, Value::Int(0));

        // Test null value
        let result = builtin_length(&[Value::Null]).unwrap();
        assert_eq!(result, Value::Int(0));

        // Test other values (should return 1)
        let result = builtin_length(&[Value::Int(42)]).unwrap();
        assert_eq!(result, Value::Int(1));

        let result = builtin_length(&[Value::Float(3.14)]).unwrap();
        assert_eq!(result, Value::Int(1));

        let result = builtin_length(&[Value::Bool(true)]).unwrap();
        assert_eq!(result, Value::Int(1));

        // Test error cases
        let result = builtin_length(&[]);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("length() expects 1 argument"));

        let result = builtin_length(&[Value::Int(1), Value::Int(2)]);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("length() expects 1 argument"));
    }

    #[test]
    fn test_builtin_add() {
        let arr = vec![Value::Int(1), Value::Int(2), Value::Int(3)];
        let result = builtin_add(&[Value::Array(arr)]).unwrap();
        assert_eq!(result, Value::Int(6));
    }

    #[test]
    fn test_builtin_add_multiple_ints() {
        let result = builtin_add(&[Value::Int(1), Value::Int(2), Value::Int(3)]).unwrap();
        assert_eq!(result, Value::Int(6));
    }

    #[test]
    fn test_builtin_add_multiple_floats() {
        let result = builtin_add(&[Value::Float(1.5), Value::Float(2.5), Value::Float(3.0)]).unwrap();
        assert_eq!(result, Value::Float(7.0));
    }

    #[test]
    fn test_builtin_add_mixed_numeric() {
        let result = builtin_add(&[Value::Int(1), Value::Float(2.5), Value::Int(3)]).unwrap();
        assert_eq!(result, Value::Float(6.5));
    }

    #[test]
    fn test_builtin_add_strings() {
        let result = builtin_add(&[Value::String("hello".to_string()), Value::String(" ".to_string()), Value::String("world".to_string())]).unwrap();
        assert_eq!(result, Value::String("hello world".to_string()));
    }

    #[test]
    fn test_builtin_add_bigint() {
        use num_bigint::BigInt;
        let big1 = Value::BigInt(BigInt::from(1000000000000i64));
        let big2 = Value::BigInt(BigInt::from(2000000000000i64));
        let result = builtin_add(&[big1, big2]).unwrap();
        match result {
            Value::BigInt(bi) => assert_eq!(bi, BigInt::from(3000000000000i64)),
            _ => panic!("Expected BigInt"),
        }
    }

    #[test]
    fn test_builtin_add_mixed_with_bigint() {
        use num_bigint::BigInt;
        let big = Value::BigInt(BigInt::from(1000000000000i64));
        let result = builtin_add(&[big, Value::Int(1)]).unwrap();
        match result {
            Value::BigInt(bi) => assert_eq!(bi, BigInt::from(1000000000001i64)),
            _ => panic!("Expected BigInt"),
        }
    }

    #[test]
    fn test_builtin_add_with_null() {
        let result = builtin_add(&[Value::Int(1), Value::Null, Value::Int(2)]).unwrap();
        assert_eq!(result, Value::Int(3));
    }

    #[test]
    fn test_builtin_add_empty_args() {
        let result = builtin_add(&[]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_add_invalid_mixed_types() {
        let result = builtin_add(&[Value::Int(1), Value::String("test".to_string())]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_coalesce() {
        // Test with nulls and values
        let result = builtin_coalesce(&[Value::Null, Value::String("default".to_string())]).unwrap();
        assert_eq!(result, Value::String("default".to_string()));

        // Test first non-null
        let result = builtin_coalesce(&[Value::String("first".to_string()), Value::String("second".to_string())]).unwrap();
        assert_eq!(result, Value::String("first".to_string()));

        // Test all null
        let result = builtin_coalesce(&[Value::Null, Value::Null]).unwrap();
        assert_eq!(result, Value::Null);

        // Test empty args
        let result = builtin_coalesce(&[]).unwrap();
        assert_eq!(result, Value::Null);

        // Test with DataFrame
        use polars::prelude::*;
        let df = DataFrame::new(vec![Series::new("a", vec![1, 2, 3])]).unwrap();
        let result = builtin_coalesce(&[Value::Null, Value::DataFrame(df.clone())]).unwrap();
        match result {
            Value::DataFrame(res_df) => {
                assert_eq!(res_df.height(), 3);
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_add_array_with_multiple_args() {
        let result = builtin_add(&[Value::Array(vec![Value::Int(1), Value::Int(2)]), Value::Int(3)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_roundup() {
        // Test roundup with no decimals (default to 0)
        let result = builtin_roundup(&[Value::Float(3.14159)]).unwrap();
        assert_eq!(result, Value::Int(4));

        // Test roundup with decimals = 0
        let result = builtin_roundup(&[Value::Float(3.14159), Value::Int(0)]).unwrap();
        assert_eq!(result, Value::Int(4));

        // Test roundup with decimals = 2
        let result = builtin_roundup(&[Value::Float(3.14159), Value::Int(2)]).unwrap();
        assert_eq!(result, Value::Float(3.15));

        // Test roundup with negative number
        let result = builtin_roundup(&[Value::Float(-2.3)]).unwrap();
        assert_eq!(result, Value::Int(-2));

        // Test roundup with integer input
        let result = builtin_roundup(&[Value::Int(5)]).unwrap();
        assert_eq!(result, Value::Int(5));

        // Test roundup with array
        let arr = vec![Value::Float(1.234), Value::Float(2.567)];
        let result = builtin_roundup(&[Value::Array(arr)]).unwrap();
        match result {
            Value::Array(vals) => {
                assert_eq!(vals.len(), 2);
                assert_eq!(vals[0], Value::Int(2));
                assert_eq!(vals[1], Value::Int(3));
            }
            _ => panic!("Expected Array"),
        }

        // Test roundup with array and decimals
        let arr = vec![Value::Float(1.234), Value::Float(2.567)];
        let result = builtin_roundup(&[Value::Array(arr), Value::Int(1)]).unwrap();
        match result {
            Value::Array(vals) => {
                assert_eq!(vals.len(), 2);
                assert_eq!(vals[0], Value::Float(1.3));
                assert_eq!(vals[1], Value::Float(2.6));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_map() {
        // Test field extraction from array of objects
        let arr = vec![
            Value::Object([("name".to_string(), Value::String("Alice".to_string())), ("age".to_string(), Value::Int(25))].into_iter().collect()),
            Value::Object([("name".to_string(), Value::String("Bob".to_string())), ("age".to_string(), Value::Int(30))].into_iter().collect()),
        ];
        let result = builtin_map(&[Value::Array(arr.clone()), Value::String("name".to_string())]).unwrap();
        assert_eq!(result, Value::Array(vec![Value::String("Alice".to_string()), Value::String("Bob".to_string())]));

        // Test field extraction with missing field
        let result = builtin_map(&[Value::Array(arr), Value::String("missing".to_string())]).unwrap();
        assert_eq!(result, Value::Array(vec![Value::Null, Value::Null]));

        // Test object template selection
        let template: HashMap<String, Value> = [("name".to_string(), Value::Null), ("age".to_string(), Value::Null)].into_iter().collect();
        let arr2 = vec![
            Value::Object([("name".to_string(), Value::String("Alice".to_string())), ("age".to_string(), Value::Int(25)), ("city".to_string(), Value::String("NYC".to_string()))].into_iter().collect()),
        ];
        let result = builtin_map(&[Value::Array(arr2), Value::Object(template)]).unwrap();
        match result {
            Value::Array(selected) => {
                assert_eq!(selected.len(), 1);
                if let Value::Object(obj) = &selected[0] {
                    assert_eq!(obj.get("name"), Some(&Value::String("Alice".to_string())));
                    assert_eq!(obj.get("age"), Some(&Value::Int(25)));
                    assert_eq!(obj.get("city"), None); // Not in template
                } else {
                    panic!("Expected Object");
                }
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_map_dataframe() {
        // Test column extraction from DataFrame
        let df = DataFrame::new(vec![
            Series::new("name", vec!["Alice", "Bob"]),
            Series::new("age", vec![25, 30]),
        ]).unwrap();
        let result = builtin_map(&[Value::DataFrame(df.clone()), Value::String("name".to_string())]).unwrap();
        match result {
            Value::Array(values) => {
                assert_eq!(values.len(), 2);
                assert_eq!(values[0], Value::String("Alice".to_string()));
                assert_eq!(values[1], Value::String("Bob".to_string()));
            }
            _ => panic!("Expected Array"),
        }

        // Test column selection with template
        let template: HashMap<String, Value> = [("name".to_string(), Value::Null)].into_iter().collect();
        let result = builtin_map(&[Value::DataFrame(df), Value::Object(template)]).unwrap();
        match result {
            Value::DataFrame(selected_df) => {
                assert_eq!(selected_df.get_column_names(), &["name"]);
                assert_eq!(selected_df.height(), 2);
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_map_edge_cases() {
        // Test with empty array
        let result = builtin_map(&[Value::Array(vec![]), Value::String("field".to_string())]).unwrap();
        assert_eq!(result, Value::Array(vec![]));

        // Test with non-object in array
        let arr = vec![Value::String("not an object".to_string())];
        let result = builtin_map(&[Value::Array(arr), Value::String("field".to_string())]).unwrap();
        assert_eq!(result, Value::Array(vec![Value::Null]));

        // Test with single argument (identity)
        let value = Value::String("test".to_string());
        let result = builtin_map(&[value.clone()]).unwrap();
        assert_eq!(result, value);

        // Test with invalid arguments
        let result = builtin_map(&[Value::Int(1), Value::Int(2), Value::Int(3)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_group_by() {
        let arr = vec![Value::String("A".to_string()), Value::String("B".to_string()), Value::String("A".to_string())];
        let keys = vec![Value::String("group1".to_string()), Value::String("group2".to_string()), Value::String("group1".to_string())];
        let result = builtin_group_by(&[Value::Array(arr), Value::Array(keys)]).unwrap();
        // Should be array of arrays, grouped
        match result {
            Value::Array(groups) => {
                assert_eq!(groups.len(), 2); // two groups
            }
            _ => panic!("Expected Array"),
        }
    }



    #[test]
    fn test_builtin_systime_ns_no_args() {
        let result = builtin_systime_ns(&[]).unwrap();
        match result {
            Value::Int(_) => {
                // Should be a large integer representing nanoseconds since epoch
            }
            _ => panic!("Expected Int"),
        }
    }

    #[test]
    fn test_builtin_sort_by_dataframe() {
        // Test sorting DataFrame by string column
        let df = DataFrame::new(vec![
            Series::new("name", vec!["Charlie", "Alice", "Bob"]),
            Series::new("salary", vec![50000, 60000, 55000]),
        ]).unwrap();
        let result = builtin_sort_by(&[Value::DataFrame(df), Value::String("name".to_string())]).unwrap();
        match result {
            Value::DataFrame(sorted_df) => {
                assert_eq!(sorted_df.height(), 3);
                let names = sorted_df.column("name").unwrap().utf8().unwrap();
                assert_eq!(names.get(0), Some("Alice"));
                assert_eq!(names.get(1), Some("Bob"));
                assert_eq!(names.get(2), Some("Charlie"));
            }
            _ => panic!("Expected DataFrame"),
        }

        // Test sorting DataFrame by numeric column
        let df = DataFrame::new(vec![
            Series::new("name", vec!["Alice", "Bob", "Charlie"]),
            Series::new("salary", vec![60000i64, 55000i64, 50000i64]),
        ]).unwrap();
        let result = builtin_sort_by(&[Value::DataFrame(df), Value::String("salary".to_string())]).unwrap();
        match result {
            Value::DataFrame(sorted_df) => {
                assert_eq!(sorted_df.height(), 3);
                let salaries = sorted_df.column("salary").unwrap().i64().unwrap();
                assert_eq!(salaries.get(0), Some(50000));
                assert_eq!(salaries.get(1), Some(55000));
                assert_eq!(salaries.get(2), Some(60000));
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_reverse_dataframe() {
        let df = DataFrame::new(vec![
            Series::new("name", vec!["Alice", "Bob", "Charlie"]),
            Series::new("salary", vec![50000, 55000, 60000]),
        ]).unwrap();
        let result = builtin_reverse(&[Value::DataFrame(df)]).unwrap();
        match result {
            Value::DataFrame(reversed_df) => {
                assert_eq!(reversed_df.height(), 3);
                let names = reversed_df.column("name").unwrap().utf8().unwrap();
                assert_eq!(names.get(0), Some("Charlie"));
                assert_eq!(names.get(1), Some("Bob"));
                assert_eq!(names.get(2), Some("Alice"));
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_map_dataframe_columns() {
        let df = DataFrame::new(vec![
            Series::new("name", vec!["Alice", "Bob"]),
            Series::new("salary", vec![50000, 55000]),
            Series::new("age", vec![25, 30]),
        ]).unwrap();

        // Test selecting specific columns
        let template: HashMap<String, Value> = [
            ("name".to_string(), Value::Null),
            ("salary".to_string(), Value::Null),
        ].into_iter().collect();
        let result = builtin_map(&[Value::DataFrame(df), Value::Object(template)]).unwrap();
        match result {
            Value::DataFrame(selected_df) => {
                assert_eq!(selected_df.get_column_names(), &["name", "salary"]);
                assert_eq!(selected_df.height(), 2);
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_systime_ns_with_array() {
        let arr = vec![Value::Int(1), Value::Int(2), Value::Int(3)];
        let result = builtin_systime_ns(&[Value::Array(arr)]).unwrap();
        match result {
            Value::Array(times) => {
                assert_eq!(times.len(), 3);
                for time in times {
                    match time {
                        Value::Int(_) => {}
                        _ => panic!("Expected Int in array"),
                    }
                }
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_systime_ns_with_dataframe() {
        let df = DataFrame::new(vec![
            Series::new("col1", vec![1, 2, 3]),
        ]).unwrap();
        let result = builtin_systime_ns(&[Value::DataFrame(df.clone())]).unwrap();
        match result {
            Value::DataFrame(result_df) => {
                assert_eq!(result_df.height(), 3);
                assert!(result_df.get_column_names().contains(&"systime_ns"));
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_systime_ns_with_series() {
        let series = Series::new("test", vec![1, 2, 3]);
        let result = builtin_systime_ns(&[Value::Series(series)]).unwrap();
        match result {
            Value::Series(result_series) => {
                assert_eq!(result_series.len(), 3);
            }
            _ => panic!("Expected Series"),
        }
    }

    #[test]
    fn test_builtin_systime_ns_with_other_value() {
        let result = builtin_systime_ns(&[Value::String("test".to_string())]).unwrap();
        match result {
            Value::Int(_) => {
                // Should return current time as Int
            }
            _ => panic!("Expected Int"),
        }
    }

    #[test]
    fn test_builtin_systime_ns_too_many_args() {
        let result = builtin_systime_ns(&[Value::Int(1), Value::Int(2)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_systime_int_no_args() {
        let result = builtin_systime_int(&[]).unwrap();
        match result {
            Value::Int(_) => {
                // Should be an integer representing seconds since epoch
            }
            _ => panic!("Expected Int"),
        }
    }

    #[test]
    fn test_builtin_systime_int_with_array() {
        let arr = vec![Value::Int(1), Value::Int(2), Value::Int(3)];
        let result = builtin_systime_int(&[Value::Array(arr)]).unwrap();
        match result {
            Value::Array(times) => {
                assert_eq!(times.len(), 3);
                for time in times {
                    match time {
                        Value::Int(_) => {}
                        _ => panic!("Expected Int in array"),
                    }
                }
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_systime_int_with_dataframe() {
        let df = DataFrame::new(vec![
            Series::new("col1", vec![1, 2, 3]),
        ]).unwrap();
        let result = builtin_systime_int(&[Value::DataFrame(df.clone())]).unwrap();
        match result {
            Value::DataFrame(result_df) => {
                assert_eq!(result_df.height(), 3);
                assert!(result_df.get_column_names().contains(&"systime_int"));
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_systime_int_with_series() {
        let series = Series::new("test", vec![1, 2, 3]);
        let result = builtin_systime_int(&[Value::Series(series)]).unwrap();
        match result {
            Value::Series(result_series) => {
                assert_eq!(result_series.len(), 3);
            }
            _ => panic!("Expected Series"),
        }
    }

    #[test]
    fn test_builtin_systime_int_with_other_value() {
        let result = builtin_systime_int(&[Value::String("test".to_string())]).unwrap();
        match result {
            Value::Int(_) => {
                // Should return current time as Int
            }
            _ => panic!("Expected Int"),
        }
    }

    #[test]
    fn test_builtin_systime_int_too_many_args() {
        let result = builtin_systime_int(&[Value::Int(1), Value::Int(2)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_localtime_int() {
        // Test with a known timestamp: 1609459200 = 2021-01-01 00:00:00 UTC
        let result = builtin_localtime(&[Value::Int(1609459200)]).unwrap();
        match result {
            Value::String(s) => {
                // The exact format depends on local timezone, but should contain date/time elements
                assert!(s.contains("2021") || s.contains("2020")); // Depending on timezone offset
                assert!(s.contains(":"));
            }
            _ => panic!("Expected String"),
        }
    }

    #[test]
    fn test_builtin_localtime_float() {
        // Test with float timestamp
        let result = builtin_localtime(&[Value::Float(1609459200.5)]).unwrap();
        match result {
            Value::String(s) => {
                assert!(s.contains("2021") || s.contains("2020"));
                assert!(s.contains(":"));
            }
            _ => panic!("Expected String"),
        }
    }

    #[test]
    fn test_builtin_localtime_string_timestamp() {
        // Test with string containing timestamp
        let result = builtin_localtime(&[Value::String("1609459200".to_string())]).unwrap();
        match result {
            Value::String(s) => {
                assert!(s.contains("2021") || s.contains("2020"));
                assert!(s.contains(":"));
            }
            _ => panic!("Expected String"),
        }
    }

    #[test]
    fn test_builtin_localtime_invalid_string() {
        // Test with invalid string
        let result = builtin_localtime(&[Value::String("invalid".to_string())]).unwrap();
        assert_eq!(result, Value::Null);
    }

    #[test]
    fn test_builtin_localtime_array() {
        let arr = vec![Value::Int(1609459200), Value::Int(1609459201)];
        let result = builtin_localtime(&[Value::Array(arr)]).unwrap();
        match result {
            Value::Array(times) => {
                assert_eq!(times.len(), 2);
                for time in times {
                    match time {
                        Value::String(s) => {
                            assert!(s.contains("2021") || s.contains("2020"));
                            assert!(s.contains(":"));
                        }
                        _ => panic!("Expected String in array"),
                    }
                }
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_localtime_dataframe() {
        let df = DataFrame::new(vec![
            Series::new("timestamp", vec![1609459200i64, 1609459201i64]),
            Series::new("name", vec!["A", "B"]),
        ]).unwrap();
        let result = builtin_localtime(&[Value::DataFrame(df.clone())]).unwrap();
        match result {
            Value::DataFrame(result_df) => {
                assert_eq!(result_df.height(), 2);
                // Check that timestamp column was converted
                let timestamp_col = result_df.column("timestamp").unwrap();
                assert_eq!(timestamp_col.dtype(), &DataType::Utf8);
                for i in 0..timestamp_col.len() {
                    if let Ok(AnyValue::Utf8(s)) = timestamp_col.get(i) {
                        assert!(s.contains("2021") || s.contains("2020"));
                        assert!(s.contains(":"));
                    }
                }
                // Check that name column remains unchanged
                let name_col = result_df.column("name").unwrap();
                assert_eq!(name_col.dtype(), &DataType::Utf8);
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_localtime_series() {
        let series = Series::new("timestamps", vec![1609459200i64, 1609459201i64]);
        let result = builtin_localtime(&[Value::Series(series)]).unwrap();
        match result {
            Value::Series(result_series) => {
                assert_eq!(result_series.len(), 2);
                assert_eq!(result_series.dtype(), &DataType::Utf8);
                for i in 0..result_series.len() {
                    if let Ok(AnyValue::Utf8(s)) = result_series.get(i) {
                        assert!(s.contains("2021") || s.contains("2020"));
                        assert!(s.contains(":"));
                    }
                }
            }
            _ => panic!("Expected Series"),
        }
    }

    #[test]
    fn test_builtin_strflocaltime_int() {
        // Test with a known timestamp: 1609459200 = 2021-01-01 00:00:00 UTC
        let result = builtin_strflocaltime(&[Value::Int(1609459200), Value::String("%Y-%m-%d %H:%M:%S".to_string())]).unwrap();
        match result {
            Value::String(s) => {
                // The exact format depends on local timezone, but should contain date/time elements
                assert!(s.contains("2021") || s.contains("2020")); // Depending on timezone offset
                assert!(s.contains("-"));
                assert!(s.contains(":"));
            }
            _ => panic!("Expected String"),
        }
    }

    #[test]
    fn test_builtin_strflocaltime_float() {
        // Test with float timestamp
        let result = builtin_strflocaltime(&[Value::Float(1609459200.5), Value::String("%Y-%m-%d %H:%M:%S".to_string())]).unwrap();
        match result {
            Value::String(s) => {
                assert!(s.contains("2021") || s.contains("2020"));
                assert!(s.contains("-"));
                assert!(s.contains(":"));
            }
            _ => panic!("Expected String"),
        }
    }

    #[test]
    fn test_builtin_strflocaltime_string_timestamp() {
        // Test with string containing timestamp
        let result = builtin_strflocaltime(&[Value::String("1609459200".to_string()), Value::String("%Y-%m-%d".to_string())]).unwrap();
        match result {
            Value::String(s) => {
                assert!(s.contains("2021") || s.contains("2020"));
                assert!(s.contains("-"));
            }
            _ => panic!("Expected String"),
        }
    }

    #[test]
    fn test_builtin_strflocaltime_invalid_string() {
        // Test with invalid string
        let result = builtin_strflocaltime(&[Value::String("invalid".to_string()), Value::String("%Y-%m-%d".to_string())]).unwrap();
        assert_eq!(result, Value::Null);
    }

    #[test]
    fn test_builtin_strflocaltime_array() {
        let arr = vec![Value::Int(1609459200), Value::Int(1609459201)];
        let result = builtin_strflocaltime(&[Value::Array(arr), Value::String("%Y-%m-%d %H:%M:%S".to_string())]).unwrap();
        match result {
            Value::Array(times) => {
                assert_eq!(times.len(), 2);
                for time in times {
                    match time {
                        Value::String(s) => {
                            assert!(s.contains("2021") || s.contains("2020"));
                            assert!(s.contains("-"));
                            assert!(s.contains(":"));
                        }
                        _ => panic!("Expected String in array"),
                    }
                }
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_strflocaltime_dataframe() {
        let df = DataFrame::new(vec![
            Series::new("timestamp", vec![1609459200i64, 1609459201i64]),
            Series::new("name", vec!["A", "B"]),
        ]).unwrap();
        let result = builtin_strflocaltime(&[Value::DataFrame(df.clone()), Value::String("%Y-%m-%d %H:%M:%S".to_string())]).unwrap();
        match result {
            Value::DataFrame(result_df) => {
                assert_eq!(result_df.height(), 2);
                // Check that timestamp column was converted
                let timestamp_col = result_df.column("timestamp").unwrap();
                assert_eq!(timestamp_col.dtype(), &DataType::Utf8);
                for i in 0..timestamp_col.len() {
                    if let Ok(AnyValue::Utf8(s)) = timestamp_col.get(i) {
                        assert!(s.contains("2021") || s.contains("2020"));
                        assert!(s.contains("-"));
                        assert!(s.contains(":"));
                    }
                }
                // Check that name column remains unchanged
                let name_col = result_df.column("name").unwrap();
                assert_eq!(name_col.dtype(), &DataType::Utf8);
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_strflocaltime_series() {
        let series = Series::new("timestamps", vec![1609459200i64, 1609459201i64]);
        let result = builtin_strflocaltime(&[Value::Series(series), Value::String("%Y-%m-%d %H:%M:%S".to_string())]).unwrap();
        match result {
            Value::Series(result_series) => {
                assert_eq!(result_series.len(), 2);
                assert_eq!(result_series.dtype(), &DataType::Utf8);
                for i in 0..result_series.len() {
                    if let Ok(AnyValue::Utf8(s)) = result_series.get(i) {
                        assert!(s.contains("2021") || s.contains("2020"));
                        assert!(s.contains("-"));
                        assert!(s.contains(":"));
                    }
                }
            }
            _ => panic!("Expected Series"),
        }
    }

    #[test]
    fn test_builtin_strflocaltime_invalid_args() {
        // No args
        let result = builtin_strflocaltime(&[]);
        assert!(result.is_err());

        // Too many args
        let result = builtin_strflocaltime(&[Value::Int(1), Value::String("format".to_string()), Value::Int(3)]);
        assert!(result.is_err());

        // Invalid format type
        let result = builtin_strflocaltime(&[Value::Int(1609459200), Value::Int(123)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_url_parse_string() {
        let url = "https://www.example.com:8080/path?query=value#fragment";
        let result = builtin_url_parse(&[Value::String(url.to_string())]).unwrap();
        match result {
            Value::Object(obj) => {
                assert_eq!(obj.get("scheme"), Some(&Value::String("https".to_string())));
                assert_eq!(obj.get("host"), Some(&Value::String("www.example.com".to_string())));
                assert_eq!(obj.get("port"), Some(&Value::Int(8080)));
                assert_eq!(obj.get("path"), Some(&Value::String("/path".to_string())));
                assert_eq!(obj.get("query"), Some(&Value::String("query=value".to_string())));
                assert_eq!(obj.get("fragment"), Some(&Value::String("fragment".to_string())));
            }
            _ => panic!("Expected Object"),
        }
    }

    #[test]
    fn test_builtin_url_parse_array() {
        let urls = vec![
            Value::String("https://example.com".to_string()),
            Value::String("http://test.com/path".to_string()),
        ];
        let result = builtin_url_parse(&[Value::Array(urls)]).unwrap();
        match result {
            Value::Array(arr) => {
                assert_eq!(arr.len(), 2);
                match &arr[0] {
                    Value::Object(obj) => {
                        assert_eq!(obj.get("scheme"), Some(&Value::String("https".to_string())));
                        assert_eq!(obj.get("host"), Some(&Value::String("example.com".to_string())));
                    }
                    _ => panic!("Expected Object in array"),
                }
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_url_parse_dataframe() {
        let urls = vec!["https://example.com", "http://test.com"];
        let series = Series::new("url", urls);
        let df = DataFrame::new(vec![series]).unwrap();
        let result = builtin_url_parse(&[Value::DataFrame(df)]).unwrap();
        match result {
            Value::DataFrame(result_df) => {
                assert_eq!(result_df.height(), 2);
                let url_col = result_df.column("url").unwrap();
                assert_eq!(url_col.dtype(), &DataType::Utf8);
                // The values should be JSON strings of the parsed objects
                for i in 0..url_col.len() {
                    if let Ok(AnyValue::Utf8(json_str)) = url_col.get(i) {
                        // Should be valid JSON
                        serde_json::from_str::<serde_json::Value>(json_str).unwrap();
                    }
                }
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_url_parse_series() {
        let urls = vec!["https://example.com", "http://test.com"];
        let series = Series::new("urls", urls);
        let result = builtin_url_parse(&[Value::Series(series)]).unwrap();
        match result {
            Value::Series(result_series) => {
                assert_eq!(result_series.len(), 2);
                assert_eq!(result_series.dtype(), &DataType::Utf8);
                // Values should be JSON strings
                for i in 0..result_series.len() {
                    if let Ok(AnyValue::Utf8(json_str)) = result_series.get(i) {
                        serde_json::from_str::<serde_json::Value>(json_str).unwrap();
                    }
                }
            }
            _ => panic!("Expected Series"),
        }
    }

    #[test]
    fn test_builtin_url_parse_invalid() {
        let result = builtin_url_parse(&[Value::String("not a url".to_string())]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_url_set_protocol() {
        // Test basic functionality
        let result = builtin_url_set_protocol(&[Value::String("http://example.com/path".to_string()), Value::String("https".to_string())]).unwrap();
        assert_eq!(result, Value::String("https://example.com/path".to_string()));

        // Test with different protocols
        let result = builtin_url_set_protocol(&[Value::String("https://secure.com".to_string()), Value::String("http".to_string())]).unwrap();
        assert_eq!(result, Value::String("http://secure.com/".to_string()));

        // Test with port
        let result = builtin_url_set_protocol(&[Value::String("http://example.com:8080/path".to_string()), Value::String("https".to_string())]).unwrap();
        assert_eq!(result, Value::String("https://example.com:8080/path".to_string()));

        // Test invalid URL
        let result = builtin_url_set_protocol(&[Value::String("not a url".to_string()), Value::String("https".to_string())]).unwrap();
        assert_eq!(result, Value::String("not a url".to_string()));

        // Test invalid protocol
        let result = builtin_url_set_protocol(&[Value::String("http://example.com".to_string()), Value::String("invalid".to_string())]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_localtime_invalid_args() {
        // No args
        let result = builtin_localtime(&[]);
        assert!(result.is_err());

        // Too many args
        let result = builtin_localtime(&[Value::Int(1), Value::Int(2)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_group_by_dataframe() {
        let df = DataFrame::new(vec![
            Series::new("department", vec!["Engineering", "Sales", "Engineering", "HR"]),
            Series::new("salary", vec![75000, 82000, 95000, 62000]),
        ]).unwrap();
        let result = builtin_group_by(&[Value::DataFrame(df), Value::String("department".to_string())]).unwrap();
        match result {
            Value::Array(groups) => {
                assert_eq!(groups.len(), 3); // Engineering, HR, Sales (sorted)
                // Check the order: Engineering, HR, Sales
                if let Value::Array(first_group) = &groups[0] {
                    if let Some(Value::Object(obj)) = first_group.first() {
                        if let Some(Value::String(dept)) = obj.get("department") {
                            assert_eq!(dept, "Engineering");
                        }
                    }
                }
                if let Value::Array(second_group) = &groups[1] {
                    if let Some(Value::Object(obj)) = second_group.first() {
                        if let Some(Value::String(dept)) = obj.get("department") {
                            assert_eq!(dept, "HR");
                        }
                    }
                }
                if let Value::Array(third_group) = &groups[2] {
                    if let Some(Value::Object(obj)) = third_group.first() {
                        if let Some(Value::String(dept)) = obj.get("department") {
                            assert_eq!(dept, "Sales");
                        }
                    }
                }
                for group in groups {
                    match group {
                        Value::Array(group_arr) => {
                            assert!(group_arr.len() >= 1);
                            for obj in group_arr {
                                match obj {
                                    Value::Object(obj) => {
                                        assert!(obj.contains_key("department"));
                                        assert!(obj.contains_key("salary"));
                                    }
                                    _ => panic!("Expected Object in group"),
                                }
                            }
                        }
                        _ => panic!("Expected Array of objects in group"),
                    }
                }
            }
            _ => panic!("Expected Array of Arrays"),
        }
    }

    #[test]
    fn test_builtin_group_by_dataframe_with_series() {
        let df = DataFrame::new(vec![
            Series::new("name", vec!["Alice", "Bob", "Charlie"]),
            Series::new("age", vec![25, 30, 35]),
        ]).unwrap();
        let group_series = Series::new("group_key", vec![1i64, 1i64, 2i64]);
        let result = builtin_group_by(&[Value::DataFrame(df), Value::Series(group_series)]).unwrap();
        match result {
            Value::Array(groups) => {
                assert_eq!(groups.len(), 2); // Two groups
                // Check that groups are sorted by key
                if let Value::Array(first_group) = &groups[0] {
                    assert_eq!(first_group.len(), 2); // Group with key 1
                }
                if let Value::Array(second_group) = &groups[1] {
                    assert_eq!(second_group.len(), 1); // Group with key 2
                }
            }
            _ => panic!("Expected Array of Arrays"),
        }
    }



    #[test]
    fn test_builtin_length_dataframe() {
        let df = DataFrame::new(vec![
            Series::new("col1", vec![1, 2, 3]),
            Series::new("col2", vec!["a", "b", "c"]),
        ]).unwrap();
        let result = builtin_length(&[Value::DataFrame(df)]).unwrap();
        assert_eq!(result, Value::Int(3)); // height
    }

    #[test]
    fn test_builtin_add_dataframe() {
        let df = DataFrame::new(vec![
            Series::new("values", vec![1.0, 2.0, 3.0]),
        ]).unwrap();
        let result = builtin_add(&[Value::DataFrame(df)]).unwrap();
        assert_eq!(result, Value::Float(6.0)); // sum of first numeric column
    }

    #[test]
    fn test_builtin_add_series() {
        let series = Series::new("values", vec![1.0, 2.0, 3.0]);
        let result = builtin_add(&[Value::Series(series)]).unwrap();
        assert_eq!(result, Value::Float(6.0));
    }

    #[test]
    fn test_builtin_sha512_string() {
        let input = "hello";
        let result = builtin_sha512(&[Value::String(input.to_string())]).unwrap();
        match result {
            Value::String(hash) => {
                // SHA512 hash of "hello" should be a 128-character hex string
                assert_eq!(hash.len(), 128);
                // Verify it's a valid hex string
                assert!(hash.chars().all(|c| c.is_ascii_hexdigit()));
                // Known SHA512 hash of "hello"
                assert_eq!(hash, "9b71d224bd62f3785d96d46ad3ea3d73319bfbc2890caadae2dff72519673ca72323c3d99ba5c11d7c7acc6e14b8c5da0c4663475c2e5c3adef46f73bcdec043");
            }
            _ => panic!("Expected String"),
        }
    }

    #[test]
    fn test_builtin_sha512_array() {
        let inputs = vec![Value::String("hello".to_string()), Value::String("world".to_string())];
        let result = builtin_sha512(&[Value::Array(inputs)]).unwrap();
        match result {
            Value::Array(hashes) => {
                assert_eq!(hashes.len(), 2);
                for hash in hashes {
                    match hash {
                        Value::String(h) => {
                            assert_eq!(h.len(), 128);
                            assert!(h.chars().all(|c| c.is_ascii_hexdigit()));
                        }
                        _ => panic!("Expected String in array"),
                    }
                }
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_sha512_dataframe() {
        let df = DataFrame::new(vec![
            Series::new("text", vec!["hello", "world"]),
            Series::new("number", vec![1, 2]),
        ]).unwrap();
        let result = builtin_sha512(&[Value::DataFrame(df.clone())]).unwrap();
        match result {
            Value::DataFrame(result_df) => {
                assert_eq!(result_df.height(), 2);
                // text column should be hashed
                let text_col = result_df.column("text").unwrap();
                assert_eq!(text_col.dtype(), &DataType::Utf8);
                for i in 0..text_col.len() {
                    if let Ok(AnyValue::Utf8(hash)) = text_col.get(i) {
                        assert_eq!(hash.len(), 128);
                        assert!(hash.chars().all(|c| c.is_ascii_hexdigit()));
                    }
                }
                // number column should remain unchanged
                let number_col = result_df.column("number").unwrap();
                assert!(number_col.dtype().is_integer());
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_sha512_series() {
        let series = Series::new("texts", vec!["hello", "world"]);
        let result = builtin_sha512(&[Value::Series(series)]).unwrap();
        match result {
            Value::Series(result_series) => {
                assert_eq!(result_series.len(), 2);
                assert_eq!(result_series.dtype(), &DataType::Utf8);
                for i in 0..result_series.len() {
                    if let Ok(AnyValue::Utf8(hash)) = result_series.get(i) {
                        assert_eq!(hash.len(), 128);
                        assert!(hash.chars().all(|c| c.is_ascii_hexdigit()));
                    }
                }
            }
            _ => panic!("Expected Series"),
        }
    }

    #[test]
    fn test_builtin_sha512_invalid_args() {
        // No args
        let result = builtin_sha512(&[]);
        assert!(result.is_err());

        // Too many args
        let result = builtin_sha512(&[Value::String("test".to_string()), Value::String("extra".to_string())]);
        assert!(result.is_err());

        // Invalid type
        let result = builtin_sha512(&[Value::Int(123)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_has() {
        // Test has on object with existing key
        let obj = Value::Object([("name".to_string(), Value::String("Alice".to_string())), ("age".to_string(), Value::Int(30))].into_iter().collect());
        let result = builtin_has(&[obj, Value::String("name".to_string())]).unwrap();
        assert_eq!(result, Value::Bool(true));

        // Test has on object with non-existing key
        let obj = Value::Object([("name".to_string(), Value::String("Alice".to_string()))].into_iter().collect());
        let result = builtin_has(&[obj, Value::String("age".to_string())]).unwrap();
        assert_eq!(result, Value::Bool(false));

        // Test has on non-object
        let result = builtin_has(&[Value::String("test".to_string()), Value::String("key".to_string())]).unwrap();
        assert_eq!(result, Value::Bool(false));

        // Test invalid key type
        let obj = Value::Object([("name".to_string(), Value::String("Alice".to_string()))].into_iter().collect());
        let result = builtin_has(&[obj, Value::Int(123)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_select_single_arg() {
        // Test with truthy value
        let result = builtin_select(&[Value::Bool(true)]).unwrap();
        assert_eq!(result, Value::Bool(true));

        // Test with falsy value
        let result = builtin_select(&[Value::Bool(false)]).unwrap();
        assert_eq!(result, Value::Null);

        // Test with null
        let result = builtin_select(&[Value::Null]).unwrap();
        assert_eq!(result, Value::Null);
    }

    #[test]
    fn test_builtin_sin_single_value() {
        let result = builtin_sin(&[Value::Float(std::f64::consts::PI / 2.0)]).unwrap();
        match result {
            Value::Float(val) => assert!((val - 1.0).abs() < 1e-10),
            _ => panic!("Expected Float"),
        }
    }

    #[test]
    fn test_builtin_sin_array() {
        let arr = vec![Value::Float(0.0), Value::Float(std::f64::consts::PI / 2.0)];
        let result = builtin_sin(&[Value::Array(arr)]).unwrap();
        match result {
            Value::Array(sin_vals) => {
                assert_eq!(sin_vals.len(), 2);
                match &sin_vals[0] {
                    Value::Float(val) => assert!((val - 0.0).abs() < 1e-10),
                    _ => panic!("Expected Float"),
                }
                match &sin_vals[1] {
                    Value::Float(val) => assert!((val - 1.0).abs() < 1e-10),
                    _ => panic!("Expected Float"),
                }
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_sin_dataframe() {
        let df = DataFrame::new(vec![
            Series::new("angles", vec![0.0, std::f64::consts::PI / 2.0]),
        ]).unwrap();
        let result = builtin_sin(&[Value::DataFrame(df)]).unwrap();
        match result {
            Value::DataFrame(result_df) => {
                let sin_col = result_df.column("angles").unwrap();
                assert_eq!(sin_col.dtype(), &DataType::Float64);
                if let Ok(AnyValue::Float64(val)) = sin_col.get(0) {
                    assert!((val - 0.0).abs() < 1e-10);
                }
                if let Ok(AnyValue::Float64(val)) = sin_col.get(1) {
                    assert!((val - 1.0).abs() < 1e-10);
                }
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_sin_series() {
        let series = Series::new("angles", vec![0.0, std::f64::consts::PI / 2.0]);
        let result = builtin_sin(&[Value::Series(series)]).unwrap();
        match result {
            Value::Series(result_series) => {
                assert_eq!(result_series.dtype(), &DataType::Float64);
                if let Ok(AnyValue::Float64(val)) = result_series.get(0) {
                    assert!((val - 0.0).abs() < 1e-10);
                }
                if let Ok(AnyValue::Float64(val)) = result_series.get(1) {
                    assert!((val - 1.0).abs() < 1e-10);
                }
            }
            _ => panic!("Expected Series"),
        }
    }

    #[test]
    fn test_builtin_tan_single_value() {
        let result = builtin_tan(&[Value::Float(0.0)]).unwrap();
        match result {
            Value::Float(val) => assert!((val - 0.0).abs() < 1e-10),
            _ => panic!("Expected Float"),
        }
    }

    #[test]
    fn test_builtin_asin_single_value() {
        let result = builtin_asin(&[Value::Float(1.0)]).unwrap();
        match result {
            Value::Float(val) => assert!((val - std::f64::consts::PI / 2.0).abs() < 1e-10),
            _ => panic!("Expected Float"),
        }
    }

    #[test]
    fn test_builtin_acos_single_value() {
        let result = builtin_acos(&[Value::Float(0.0)]).unwrap();
        match result {
            Value::Float(val) => assert!((val - std::f64::consts::PI / 2.0).abs() < 1e-10),
            _ => panic!("Expected Float"),
        }
    }

    #[test]
    fn test_builtin_atan_single_value() {
        let result = builtin_atan(&[Value::Float(1.0)]).unwrap();
        match result {
            Value::Float(val) => assert!((val - std::f64::consts::PI / 4.0).abs() < 1e-10),
            _ => panic!("Expected Float"),
        }
    }

    #[test]
    fn test_builtin_select_two_args() {
        // Test with truthy condition
        let result = builtin_select(&[Value::String("test".to_string()), Value::Bool(true)]).unwrap();
        assert_eq!(result, Value::String("test".to_string()));

        // Test with falsy condition
        let result = builtin_select(&[Value::String("test".to_string()), Value::Bool(false)]).unwrap();
        assert_eq!(result, Value::Null);
    }

    #[test]
    fn test_builtin_select_array_with_mask() {
        let arr = vec![Value::Int(1), Value::Int(2), Value::Int(3)];
        let mask = vec![Value::Bool(true), Value::Bool(false), Value::Bool(true)];
        let result = builtin_select(&[Value::Array(arr), Value::Array(mask)]).unwrap();
        match result {
            Value::Array(filtered) => {
                assert_eq!(filtered.len(), 2);
                assert_eq!(filtered[0], Value::Int(1));
                assert_eq!(filtered[1], Value::Int(3));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_select_dataframe_with_series() {
        let df = DataFrame::new(vec![
            Series::new("name", vec!["Alice", "Bob", "Charlie"]),
            Series::new("age", vec![25, 30, 35]),
        ]).unwrap();
        let mask_series = Series::new("mask", vec![true, false, true]);
        let result = builtin_select(&[Value::DataFrame(df.clone()), Value::Series(mask_series)]).unwrap();
        match result {
            Value::DataFrame(filtered_df) => {
                assert_eq!(filtered_df.height(), 2);
                let names = filtered_df.column("name").unwrap();
                assert_eq!(names.len(), 2);
                if let Ok(AnyValue::Utf8(name1)) = names.get(0) {
                    assert_eq!(name1, "Alice");
                }
                if let Ok(AnyValue::Utf8(name2)) = names.get(1) {
                    assert_eq!(name2, "Charlie");
                }
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_select_invalid_args() {
        // No args
        let result = builtin_select(&[]);
        assert!(result.is_err());

        // Too many args
        let result = builtin_select(&[Value::Int(1), Value::Int(2), Value::Int(3)]);
        assert!(result.is_err());
    }



    #[test]
    fn test_builtin_reverse_series() {
        let series = Series::new("test", vec![1, 2, 3, 4]);
        let result = builtin_reverse(&[Value::Series(series)]).unwrap();
        match result {
            Value::Series(reversed) => {
                assert_eq!(reversed.len(), 4);
                if let Ok(val0) = reversed.get(0) {
                    assert_eq!(val0, AnyValue::Int32(4));
                }
                if let Ok(val3) = reversed.get(3) {
                    assert_eq!(val3, AnyValue::Int32(1));
                }
            }
            _ => panic!("Expected Series"),
        }
    }

    #[test]
    fn test_builtin_sort_series() {
        let series = Series::new("test", vec![3, 1, 4, 2]);
        let result = builtin_sort(&[Value::Series(series)]).unwrap();
        match result {
            Value::Series(sorted_series) => {
                assert_eq!(sorted_series.len(), 4);
                if let Ok(val0) = sorted_series.get(0) {
                    if let AnyValue::Int64(v0) = val0 {
                        assert_eq!(v0, 1);
                    }
                }
                if let Ok(val3) = sorted_series.get(3) {
                    if let AnyValue::Int64(v3) = val3 {
                        assert_eq!(v3, 4);
                    }
                }
            }
            _ => panic!("Expected Series"),
        }
    }

    #[test]
    fn test_builtin_map_dataframe_select_columns() {
        let df = DataFrame::new(vec![
            Series::new("name", vec!["Alice", "Bob"]),
            Series::new("salary", vec![75000, 82000]),
            Series::new("age", vec![28, 34]),
        ]).unwrap();
        let template = [("name".to_string(), Value::Null), ("salary".to_string(), Value::Null)].into_iter().collect();
        let result = builtin_map(&[Value::DataFrame(df), Value::Object(template)]).unwrap();
        match result {
            Value::DataFrame(mapped_df) => {
                assert_eq!(mapped_df.height(), 2);
                assert_eq!(mapped_df.width(), 2);
                assert!(mapped_df.get_column_names().contains(&"name"));
                assert!(mapped_df.get_column_names().contains(&"salary"));
                assert!(!mapped_df.get_column_names().contains(&"age"));
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_map_dataframe_select_field() {
        let df = DataFrame::new(vec![
            Series::new("name", vec!["Alice", "Bob"]),
            Series::new("salary", vec![75000, 82000]),
        ]).unwrap();
        let result = builtin_map(&[Value::DataFrame(df), Value::String("name".to_string())]).unwrap();
        match result {
            Value::Array(names) => {
                assert_eq!(names.len(), 2);
                assert_eq!(names[0], Value::String("Alice".to_string()));
                assert_eq!(names[1], Value::String("Bob".to_string()));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_map_dataframe_select_fields() {
        let df = DataFrame::new(vec![
            Series::new("name", vec!["Alice", "Bob"]),
            Series::new("age", vec![25, 30]),
            Series::new("city", vec!["NYC", "LA"]),
        ]).unwrap();
        let template = [("name".to_string(), Value::Null), ("age".to_string(), Value::Null)].into_iter().collect();
        let result = builtin_map(&[Value::DataFrame(df), Value::Object(template)]).unwrap();
        match result {
            Value::DataFrame(mapped_df) => {
                assert_eq!(mapped_df.width(), 2);
                assert!(mapped_df.get_column_names().contains(&"name"));
                assert!(mapped_df.get_column_names().contains(&"age"));
                assert!(!mapped_df.get_column_names().contains(&"city"));
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_array_push_array() {
        let arr = vec![Value::Int(1), Value::Int(2)];
        let result = builtin_array_push(&[Value::Array(arr), Value::Int(3)]).unwrap();
        match result {
            Value::Array(pushed) => {
                assert_eq!(pushed.len(), 3);
                assert_eq!(pushed[0], Value::Int(1));
                assert_eq!(pushed[1], Value::Int(2));
                assert_eq!(pushed[2], Value::Int(3));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_array_push_dataframe() {
        let s1 = Series::new("", &[1i64, 2i64]);
        let s2 = Series::new("", &[3i64]);
        let list_series = Series::new("list_col", &[s1, s2]);
        let df = DataFrame::new(vec![list_series]).unwrap();
        let result = builtin_array_push(&[Value::DataFrame(df), Value::Int(4)]).unwrap();
        match result {
            Value::DataFrame(new_df) => {
                let list_col = new_df.column("list_col").unwrap().list().unwrap();
                let first_list = list_col.get_as_series(0).unwrap();
                assert_eq!(first_list.get(0).unwrap(), AnyValue::Int64(1));
                assert_eq!(first_list.get(1).unwrap(), AnyValue::Int64(2));
                assert_eq!(first_list.get(2).unwrap(), AnyValue::Int64(4));
                let second_list = list_col.get_as_series(1).unwrap();
                assert_eq!(second_list.get(0).unwrap(), AnyValue::Int64(3));
                assert_eq!(second_list.get(1).unwrap(), AnyValue::Int64(4));
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_split_string() {
        let result = builtin_split(&[Value::String("hello world".to_string())]).unwrap();
        match result {
            Value::Array(parts) => {
                assert_eq!(parts.len(), 2);
                assert_eq!(parts[0], Value::String("hello".to_string()));
                assert_eq!(parts[1], Value::String("world".to_string()));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_split_string_with_separator() {
        let result = builtin_split(&[Value::String("a,b,c".to_string()), Value::String(",".to_string())]).unwrap();
        match result {
            Value::Array(parts) => {
                assert_eq!(parts.len(), 3);
                assert_eq!(parts[0], Value::String("a".to_string()));
                assert_eq!(parts[1], Value::String("b".to_string()));
                assert_eq!(parts[2], Value::String("c".to_string()));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_split_empty_separator() {
        let result = builtin_split(&[Value::String("abc".to_string()), Value::String("".to_string())]).unwrap();
        match result {
            Value::Array(parts) => {
                assert_eq!(parts.len(), 3);
                assert_eq!(parts[0], Value::String("a".to_string()));
                assert_eq!(parts[1], Value::String("b".to_string()));
                assert_eq!(parts[2], Value::String("c".to_string()));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_split_array() {
        let arr = vec![Value::String("a b".to_string()), Value::String("c d".to_string())];
        let result = builtin_split(&[Value::Array(arr)]).unwrap();
        match result {
            Value::Array(arrays) => {
                assert_eq!(arrays.len(), 2);
                if let Value::Array(first) = &arrays[0] {
                    assert_eq!(first.len(), 2);
                    assert_eq!(first[0], Value::String("a".to_string()));
                    assert_eq!(first[1], Value::String("b".to_string()));
                }
                if let Value::Array(second) = &arrays[1] {
                    assert_eq!(second.len(), 2);
                    assert_eq!(second[0], Value::String("c".to_string()));
                    assert_eq!(second[1], Value::String("d".to_string()));
                }
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_url_set_path() {
        let result = builtin_url_set_path(&[Value::String("https://example.com/old/path".to_string()), Value::String("/new/path".to_string())]).unwrap();
        assert_eq!(result, Value::String("https://example.com/new/path".to_string()));
    }

    #[test]
    fn test_builtin_url_set_path_invalid_url() {
        let result = builtin_url_set_path(&[Value::String("not a url".to_string()), Value::String("/new/path".to_string())]).unwrap();
        assert_eq!(result, Value::String("not a url".to_string()));
    }

    #[test]
    fn test_builtin_url_set_path_array() {
        let arr = vec![Value::String("https://example.com/path1".to_string()), Value::String("https://example.com/path2".to_string())];
        let result = builtin_url_set_path(&[Value::Array(arr), Value::String("/new".to_string())]).unwrap();
        match result {
            Value::Array(urls) => {
                assert_eq!(urls.len(), 2);
                assert_eq!(urls[0], Value::String("https://example.com/new".to_string()));
                assert_eq!(urls[1], Value::String("https://example.com/new".to_string()));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_url_set_domain_without_www() {
        let result = builtin_url_set_domain_without_www(&[Value::String("https://www.example.com/path".to_string())]).unwrap();
        assert_eq!(result, Value::String("https://example.com/path".to_string()));

        let result = builtin_url_set_domain_without_www(&[Value::String("https://example.com/path".to_string())]).unwrap();
        assert_eq!(result, Value::String("https://example.com/path".to_string()));

        let result = builtin_url_set_domain_without_www(&[Value::String("https://sub.www.example.com/path".to_string())]).unwrap();
        assert_eq!(result, Value::String("https://sub.www.example.com/path".to_string()));

        let result = builtin_url_set_domain_without_www(&[Value::String("invalid-url".to_string())]).unwrap();
        assert_eq!(result, Value::String("invalid-url".to_string()));
    }

    #[test]
    fn test_builtin_url_set_domain_without_www_array() {
        let arr = vec![
            Value::String("https://www.example.com/path1".to_string()),
            Value::String("https://example.com/path2".to_string()),
        ];
        let result = builtin_url_set_domain_without_www(&[Value::Array(arr)]).unwrap();
        match result {
            Value::Array(urls) => {
                assert_eq!(urls.len(), 2);
                assert_eq!(urls[0], Value::String("https://example.com/path1".to_string()));
                assert_eq!(urls[1], Value::String("https://example.com/path2".to_string()));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_camel_case_string() {
        let result = builtin_camel_case(&[Value::String("hello_world".to_string())]).unwrap();
        assert_eq!(result, Value::String("helloWorld".to_string()));

        let result = builtin_camel_case(&[Value::String("snake_case_example".to_string())]).unwrap();
        assert_eq!(result, Value::String("snakeCaseExample".to_string()));

        let result = builtin_camel_case(&[Value::String("already-camel".to_string())]).unwrap();
        assert_eq!(result, Value::String("alreadyCamel".to_string()));
    }

    // #[test]
    #[test]
    fn test_builtin_camel_case_array() {
        let arr = vec![Value::String("hello_world".to_string()), Value::String("test_case".to_string())];
        let result = builtin_camel_case(&[Value::Array(arr)]).unwrap();
        match result {
            Value::Array(converted) => {
                assert_eq!(converted.len(), 2);
                assert_eq!(converted[0], Value::String("helloWorld".to_string()));
                assert_eq!(converted[1], Value::String("testCase".to_string()));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_camel_case_dataframe() {
        let df = DataFrame::new(vec![
            Series::new("text", vec!["hello_world", "test_case"]),
            Series::new("number", vec![1, 2]),
        ]).unwrap();
        let result = builtin_camel_case(&[Value::DataFrame(df)]).unwrap();
        match result {
            Value::DataFrame(result_df) => {
                assert_eq!(result_df.height(), 2);
                let text_col = result_df.column("text").unwrap();
                assert_eq!(text_col.dtype(), &DataType::Utf8);
                if let Ok(AnyValue::Utf8(first)) = text_col.get(0) {
                    assert_eq!(first, "helloWorld");
                }
                if let Ok(AnyValue::Utf8(second)) = text_col.get(1) {
                    assert_eq!(second, "testCase");
                }
                // number column should remain unchanged
                let number_col = result_df.column("number").unwrap();
                assert!(number_col.dtype().is_integer());
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_camel_case_series() {
        let series = Series::new("texts", vec!["hello_world", "test_case"]);
        let result = builtin_camel_case(&[Value::Series(series)]).unwrap();
        match result {
            Value::Series(result_series) => {
                assert_eq!(result_series.len(), 2);
                assert_eq!(result_series.dtype(), &DataType::Utf8);
                if let Ok(AnyValue::Utf8(first)) = result_series.get(0) {
                    assert_eq!(first, "helloWorld");
                }
                if let Ok(AnyValue::Utf8(second)) = result_series.get(1) {
                    assert_eq!(second, "testCase");
                }
            }
            _ => panic!("Expected Series"),
        }
    }

    #[test]
    fn test_builtin_camel_case_invalid_args() {
        // No args
        let result = builtin_camel_case(&[]);
        assert!(result.is_err());

        // Too many args
        let result = builtin_camel_case(&[Value::String("test".to_string()), Value::String("extra".to_string())]);
        assert!(result.is_err());

        // Invalid type
        let result = builtin_camel_case(&[Value::Int(123)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_sort_by_array_objects() {
        let arr = vec![
            Value::Object([("name".to_string(), Value::String("Alice".to_string())), ("salary".to_string(), Value::Int(75000))].into_iter().collect()),
            Value::Object([("name".to_string(), Value::String("Bob".to_string())), ("salary".to_string(), Value::Int(82000))].into_iter().collect()),
            Value::Object([("name".to_string(), Value::String("Charlie".to_string())), ("salary".to_string(), Value::Int(68000))].into_iter().collect()),
        ];
        let result = builtin_sort_by(&[Value::Array(arr), Value::String("salary".to_string())]).unwrap();
        match result {
            Value::Array(sorted) => {
                assert_eq!(sorted.len(), 3);
                // Check that salaries are sorted ascending
                if let Value::Object(obj0) = &sorted[0] {
                    assert_eq!(obj0.get("salary"), Some(&Value::Int(68000)));
                }
                if let Value::Object(obj1) = &sorted[1] {
                    assert_eq!(obj1.get("salary"), Some(&Value::Int(75000)));
                }
                if let Value::Object(obj2) = &sorted[2] {
                    assert_eq!(obj2.get("salary"), Some(&Value::Int(82000)));
                }
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_sort_by_array_key_array() {
        let arr = vec![Value::String("A".to_string()), Value::String("B".to_string()), Value::String("C".to_string())];
        let keys = vec![Value::Int(3), Value::Int(1), Value::Int(2)];
        let result = builtin_sort_by(&[Value::Array(arr), Value::Array(keys)]).unwrap();
        match result {
            Value::Array(sorted) => {
                assert_eq!(sorted.len(), 3);
                assert_eq!(sorted[0], Value::String("B".to_string())); // key 1
                assert_eq!(sorted[1], Value::String("C".to_string())); // key 2
                assert_eq!(sorted[2], Value::String("A".to_string())); // key 3
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_sort_by_dataframe_descending() {
        let df = DataFrame::new(vec![
            Series::new("name", vec!["Alice", "Bob", "Charlie"]),
            Series::new("salary", vec![75000i64, 82000i64, 68000i64]),
        ]).unwrap();
        let result = builtin_sort_by(&[Value::DataFrame(df), Value::String("salary".to_string())]).unwrap();
        match result {
            Value::DataFrame(sorted_df) => {
                assert_eq!(sorted_df.height(), 3);
                // Check that salaries are sorted ascending
                if let Ok(salary_series) = sorted_df.column("salary") {
                    if let Ok(val0) = salary_series.get(0) {
                        if let AnyValue::Int64(s0) = val0 {
                            assert_eq!(s0, 68000);
                        }
                    }
                    if let Ok(val1) = salary_series.get(1) {
                        if let AnyValue::Int64(s1) = val1 {
                            assert_eq!(s1, 75000);
                        }
                    }
                    if let Ok(val2) = salary_series.get(2) {
                        if let AnyValue::Int64(s2) = val2 {
                            assert_eq!(s2, 82000);
                        }
                    }
                }
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_sort_by_dataframe_with_series() {
        let df = DataFrame::new(vec![
            Series::new("name", vec!["Alice", "Bob", "Charlie"]),
            Series::new("age", vec![28i64, 34i64, 25i64]),
        ]).unwrap();
        let sort_series = Series::new("custom_sort", vec![3i64, 1i64, 2i64]);
        let result = builtin_sort_by(&[Value::DataFrame(df), Value::Series(sort_series)]).unwrap();
        match result {
            Value::DataFrame(sorted_df) => {
                assert_eq!(sorted_df.height(), 3);
                // Check that rows are sorted by the custom series (1, 2, 3)
                if let Ok(name_series) = sorted_df.column("name") {
                    if let Ok(val0) = name_series.get(0) {
                        if let AnyValue::Utf8(name0) = val0 {
                            assert_eq!(name0, "Bob"); // sort key 1
                        }
                    }
                    if let Ok(val1) = name_series.get(1) {
                        if let AnyValue::Utf8(name1) = val1 {
                            assert_eq!(name1, "Charlie"); // sort key 2
                        }
                    }
                    if let Ok(val2) = name_series.get(2) {
                        if let AnyValue::Utf8(name2) = val2 {
                            assert_eq!(name2, "Alice"); // sort key 3
                        }
                    }
                }
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_sort_by_series() {
        let series = Series::new("values", vec![3i64, 1i64, 4i64, 2i64]);
        let key_series = Series::new("keys", vec![3i64, 1i64, 4i64, 2i64]);
        let result = builtin_sort_by(&[Value::Series(series), Value::Series(key_series)]).unwrap();
        match result {
            Value::Series(sorted_series) => {
                assert_eq!(sorted_series.len(), 4);
                if let Ok(val0) = sorted_series.get(0) {
                    if let AnyValue::Int64(v0) = val0 {
                        assert_eq!(v0, 1);
                    }
                }
                if let Ok(val1) = sorted_series.get(1) {
                    if let AnyValue::Int64(v1) = val1 {
                        assert_eq!(v1, 2);
                    }
                }
                if let Ok(val2) = sorted_series.get(2) {
                    if let AnyValue::Int64(v2) = val2 {
                        assert_eq!(v2, 3);
                    }
                }
                if let Ok(val3) = sorted_series.get(3) {
                    if let AnyValue::Int64(v3) = val3 {
                        assert_eq!(v3, 4);
                    }
                }
            }
            _ => panic!("Expected Series"),
        }
    }

    #[test]
    fn test_builtin_reverse_array() {
        let arr = vec![Value::Int(1), Value::Int(2), Value::Int(3)];
        let result = builtin_reverse(&[Value::Array(arr)]).unwrap();
        match result {
            Value::Array(reversed) => {
                assert_eq!(reversed.len(), 3);
                assert_eq!(reversed[0], Value::Int(3));
                assert_eq!(reversed[1], Value::Int(2));
                assert_eq!(reversed[2], Value::Int(1));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_reverse_string() {
        let s = "hello".to_string();
        let result = builtin_reverse(&[Value::String(s)]).unwrap();
        assert_eq!(result, Value::String("olleh".to_string()));
    }

    #[test]
    fn test_builtin_map_array_field_extraction() {
        let arr = vec![
            Value::Object([("name".to_string(), Value::String("Alice".to_string())), ("age".to_string(), Value::Int(25))].into_iter().collect()),
            Value::Object([("name".to_string(), Value::String("Bob".to_string())), ("age".to_string(), Value::Int(30))].into_iter().collect()),
        ];
        let result = builtin_map(&[Value::Array(arr), Value::String("name".to_string())]).unwrap();
        match result {
            Value::Array(names) => {
                assert_eq!(names.len(), 2);
                assert_eq!(names[0], Value::String("Alice".to_string()));
                assert_eq!(names[1], Value::String("Bob".to_string()));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_map_array_object_template() {
        let arr = vec![
            Value::Object([
                ("name".to_string(), Value::String("Alice".to_string())),
                ("age".to_string(), Value::Int(25)),
                ("city".to_string(), Value::String("NYC".to_string()))
            ].into_iter().collect()),
        ];
        let template = [("name".to_string(), Value::Null), ("age".to_string(), Value::Null)].into_iter().collect();
        let result = builtin_map(&[Value::Array(arr), Value::Object(template)]).unwrap();
        match result {
            Value::Array(mapped) => {
                assert_eq!(mapped.len(), 1);
                if let Value::Object(obj) = &mapped[0] {
                    assert_eq!(obj.get("name"), Some(&Value::String("Alice".to_string())));
                    assert_eq!(obj.get("age"), Some(&Value::Int(25)));
                    assert_eq!(obj.get("city"), None); // Not in template
                } else {
                    panic!("Expected Object");
                }
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_sort_by_invalid_args() {
        // No args
        let result = builtin_sort_by(&[]);
        assert!(result.is_err());

        // Too many args
        let result = builtin_sort_by(&[Value::Int(1), Value::Int(2), Value::Int(3)]);
        assert!(result.is_err());

        // Invalid combination
        let result = builtin_sort_by(&[Value::String("test".to_string()), Value::Int(1)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_reverse_invalid_args() {
        // No args
        let result = builtin_reverse(&[]);
        assert!(result.is_err());

        // Too many args
        let result = builtin_reverse(&[Value::Int(1), Value::Int(2)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_map_invalid_args() {
        // No args
        let result = builtin_map(&[]);
        assert!(result.is_err());

        // Too many args
        let result = builtin_map(&[Value::Int(1), Value::Int(2), Value::Int(3)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_is_valid_utf8_string() {
        let result = builtin_is_valid_utf8(&[Value::String("hello world".to_string())]).unwrap();
        assert_eq!(result, Value::Bool(true));

        let result = builtin_is_valid_utf8(&[Value::String("caf".to_string())]).unwrap();
        assert_eq!(result, Value::Bool(true));
    }

    #[test]
    fn test_builtin_is_valid_utf8_array() {
        // Valid UTF-8 bytes
        let valid_bytes = vec![Value::Int(72), Value::Int(101), Value::Int(108), Value::Int(108), Value::Int(111)]; // "Hello"
        let result = builtin_is_valid_utf8(&[Value::Array(valid_bytes)]).unwrap();
        assert_eq!(result, Value::Bool(true));

        // Invalid UTF-8 bytes
        let invalid_bytes = vec![Value::Int(255), Value::Int(254)];
        let result = builtin_is_valid_utf8(&[Value::Array(invalid_bytes)]).unwrap();
        assert_eq!(result, Value::Bool(false));
    }

    #[test]
    fn test_builtin_is_valid_utf8_invalid_args() {
        // No args
        let result = builtin_is_valid_utf8(&[]);
        assert!(result.is_err());

        // Too many args
        let result = builtin_is_valid_utf8(&[Value::String("test".to_string()), Value::String("extra".to_string())]);
        assert!(result.is_err());

        // Invalid array element
        let invalid_array = vec![Value::String("not a byte".to_string())];
        let result = builtin_is_valid_utf8(&[Value::Array(invalid_array)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_abs_int() {
        let result = builtin_abs(&[Value::Int(-5)]).unwrap();
        assert_eq!(result, Value::Int(5));

        let result = builtin_abs(&[Value::Int(5)]).unwrap();
        assert_eq!(result, Value::Int(5));
    }

    #[test]
    fn test_builtin_abs_float() {
        let result = builtin_abs(&[Value::Float(-3.14)]).unwrap();
        assert_eq!(result, Value::Float(3.14));

        let result = builtin_abs(&[Value::Float(3.14)]).unwrap();
        assert_eq!(result, Value::Float(3.14));
    }

    #[test]
    fn test_builtin_abs_bigint() {
        let bi = num_bigint::BigInt::from(-123);
        let result = builtin_abs(&[Value::BigInt(bi.clone())]).unwrap();
        assert_eq!(result, Value::BigInt(bi.abs()));
    }

    #[test]
    fn test_builtin_abs_array() {
        let arr = vec![Value::Int(-1), Value::Float(-2.5), Value::Int(3)];
        let result = builtin_abs(&[Value::Array(arr)]).unwrap();
        match result {
            Value::Array(abs_arr) => {
                assert_eq!(abs_arr.len(), 3);
                assert_eq!(abs_arr[0], Value::Int(1));
                assert_eq!(abs_arr[1], Value::Float(2.5));
                assert_eq!(abs_arr[2], Value::Int(3));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_abs_dataframe() {
        let df = DataFrame::new(vec![
            Series::new("values", vec![-1i64, -2i64, 3i64]),
            Series::new("text", vec!["a", "b", "c"]),
        ]).unwrap();
        let result = builtin_abs(&[Value::DataFrame(df.clone())]).unwrap();
        match result {
            Value::DataFrame(abs_df) => {
                assert_eq!(abs_df.height(), 3);
                let values_col = abs_df.column("values").unwrap();
                assert_eq!(values_col.dtype(), &DataType::Int64);
                if let Ok(val0) = values_col.get(0) {
                    if let AnyValue::Int64(v0) = val0 {
                        assert_eq!(v0, 1);
                    }
                }
                if let Ok(val1) = values_col.get(1) {
                    if let AnyValue::Int64(v1) = val1 {
                        assert_eq!(v1, 2);
                    }
                }
                if let Ok(val2) = values_col.get(2) {
                    if let AnyValue::Int64(v2) = val2 {
                        assert_eq!(v2, 3);
                    }
                }
                // text column should remain unchanged
                let text_col = abs_df.column("text").unwrap();
                assert_eq!(text_col.dtype(), &DataType::Utf8);
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_abs_series() {
        let series = Series::new("values", vec![-1.0, -2.0, 3.0]);
        let result = builtin_abs(&[Value::Series(series)]).unwrap();
        match result {
            Value::Series(abs_series) => {
                assert_eq!(abs_series.len(), 3);
                assert_eq!(abs_series.dtype(), &DataType::Float64);
                if let Ok(val0) = abs_series.get(0) {
                    if let AnyValue::Float64(v0) = val0 {
                        assert_eq!(v0, 1.0);
                    }
                }
                if let Ok(val1) = abs_series.get(1) {
                    if let AnyValue::Float64(v1) = val1 {
                        assert_eq!(v1, 2.0);
                    }
                }
                if let Ok(val2) = abs_series.get(2) {
                    if let AnyValue::Float64(v2) = val2 {
                        assert_eq!(v2, 3.0);
                    }
                }
            }
            _ => panic!("Expected Series"),
        }
    }

    #[test]
    fn test_builtin_abs_invalid_args() {
        // No args
        let result = builtin_abs(&[]);
        assert!(result.is_err());

        // Too many args
        let result = builtin_abs(&[Value::Int(1), Value::Int(2)]);
        assert!(result.is_err());

        // Invalid type
        let result = builtin_abs(&[Value::String("test".to_string())]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_group_by_complex_dataframe() {
        // Test group_by with multiple columns and different data types
        let df = DataFrame::new(vec![
            Series::new("category", vec!["A", "B", "A", "C", "B"]),
            Series::new("value", vec![10.5, 20.0, 15.5, 5.0, 25.0]),
            Series::new("count", vec![1i64, 2i64, 3i64, 1i64, 2i64]),
        ]).unwrap();

        let result = builtin_group_by(&[Value::DataFrame(df), Value::String("category".to_string())]).unwrap();
        match result {
            Value::Array(groups) => {
                assert_eq!(groups.len(), 3); // A, B, C
                // Verify each group is an array of objects with correct data
                for group in groups {
                    match group {
                        Value::Array(group_arr) => {
                            assert!(group_arr.len() >= 1);
                            for obj in group_arr {
                                match obj {
                                    Value::Object(obj) => {
                                        assert!(obj.contains_key("category"));
                                        assert!(obj.contains_key("value"));
                                        assert!(obj.contains_key("count"));
                                    }
                                    _ => panic!("Expected Object in group"),
                                }
                            }
                        }
                        _ => panic!("Expected Array of objects in group"),
                    }
                }
            }
            _ => panic!("Expected Array of Arrays"),
        }
    }

    #[test]
    fn test_builtin_map_nested_operations() {
        // Test map with nested operations on DataFrame
        let df_simple = DataFrame::new(vec![
            Series::new("name", vec!["Alice", "Bob"]),
            Series::new("age", vec![25, 30]),
        ]).unwrap();

        let result = builtin_map(&[Value::DataFrame(df_simple), Value::String("name".to_string())]).unwrap();
        match result {
            Value::Array(names) => {
                assert_eq!(names.len(), 2);
                assert_eq!(names[0], Value::String("Alice".to_string()));
                assert_eq!(names[1], Value::String("Bob".to_string()));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_group_by_empty_dataframe() {
        let df = DataFrame::new(vec![
            Series::new("category", Vec::<String>::new()),
            Series::new("value", Vec::<f64>::new()),
        ]).unwrap();

        let result = builtin_group_by(&[Value::DataFrame(df), Value::String("category".to_string())]).unwrap();
        match result {
            Value::Array(groups) => {
                assert_eq!(groups.len(), 0); // No groups for empty DataFrame
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_map_empty_dataframe() {
        let df = DataFrame::new(vec![
            Series::new("name", Vec::<String>::new()),
        ]).unwrap();

        let result = builtin_map(&[Value::DataFrame(df), Value::String("name".to_string())]).unwrap();
        match result {
            Value::Array(values) => {
                assert_eq!(values.len(), 0); // Empty result for empty DataFrame
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_base64_decode_string() {
        // Test basic decoding
        let encoded = "SGVsbG8gV29ybGQ="; // "Hello World" in base64
        let result = builtin_base64_decode(&[Value::String(encoded.to_string())]).unwrap();
        assert_eq!(result, Value::String("Hello World".to_string()));

        // Test with padding
        let encoded = "SGVsbG8="; // "Hello" in base64
        let result = builtin_base64_decode(&[Value::String(encoded.to_string())]).unwrap();
        assert_eq!(result, Value::String("Hello".to_string()));

        // Test empty string
        let result = builtin_base64_decode(&[Value::String("".to_string())]).unwrap();
        assert_eq!(result, Value::String("".to_string()));
    }

    #[test]
    fn test_builtin_base64_decode_array() {
        let encoded_values = vec![
            Value::String("SGVsbG8=".to_string()), // "Hello"
            Value::String("V29ybGQ=".to_string()), // "World"
        ];
        let result = builtin_base64_decode(&[Value::Array(encoded_values)]).unwrap();
        match result {
            Value::Array(decoded) => {
                assert_eq!(decoded.len(), 2);
                assert_eq!(decoded[0], Value::String("Hello".to_string()));
                assert_eq!(decoded[1], Value::String("World".to_string()));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_base64_decode_dataframe() {
        let df = DataFrame::new(vec![
            Series::new("encoded", vec!["SGVsbG8=", "V29ybGQ="]), // "Hello", "World"
            Series::new("number", vec![1, 2]),
        ]).unwrap();
        let result = builtin_base64_decode(&[Value::DataFrame(df.clone())]).unwrap();
        match result {
            Value::DataFrame(result_df) => {
                assert_eq!(result_df.height(), 2);
                // encoded column should be decoded
                let encoded_col = result_df.column("encoded").unwrap();
                assert_eq!(encoded_col.dtype(), &DataType::Utf8);
                if let Ok(AnyValue::Utf8(first)) = encoded_col.get(0) {
                    assert_eq!(first, "Hello");
                }
                if let Ok(AnyValue::Utf8(second)) = encoded_col.get(1) {
                    assert_eq!(second, "World");
                }
                // number column should remain unchanged
                let number_col = result_df.column("number").unwrap();
                assert!(number_col.dtype().is_integer());
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_base64_decode_series() {
        let series = Series::new("encoded", vec!["SGVsbG8=", "V29ybGQ="]); // "Hello", "World"
        let result = builtin_base64_decode(&[Value::Series(series)]).unwrap();
        match result {
            Value::Series(result_series) => {
                assert_eq!(result_series.len(), 2);
                assert_eq!(result_series.dtype(), &DataType::Utf8);
                if let Ok(AnyValue::Utf8(first)) = result_series.get(0) {
                    assert_eq!(first, "Hello");
                }
                if let Ok(AnyValue::Utf8(second)) = result_series.get(1) {
                    assert_eq!(second, "World");
                }
            }
            _ => panic!("Expected Series"),
        }
    }

    #[test]
    fn test_builtin_base64_decode_invalid_base64() {
        // Invalid base64 string
        let result = builtin_base64_decode(&[Value::String("invalid base64!".to_string())]);
        assert!(result.is_err());

        // Valid base64 but invalid UTF-8 (this would be an error)
        let invalid_utf8 = "////"; // This decodes to bytes that aren't valid UTF-8
        let result = builtin_base64_decode(&[Value::String(invalid_utf8.to_string())]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_base64_decode_invalid_args() {
        // No args
        let result = builtin_base64_decode(&[]);
        assert!(result.is_err());

        // Too many args
        let result = builtin_base64_decode(&[Value::String("test".to_string()), Value::String("extra".to_string())]);
        assert!(result.is_err());

        // Invalid type
        let result = builtin_base64_decode(&[Value::Int(123)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_base64_decode_array_with_invalid_elements() {
        let arr = vec![
            Value::String("SGVsbG8=".to_string()), // Valid: "Hello"
            Value::String("invalid!".to_string()), // Invalid base64
        ];
        let result = builtin_base64_decode(&[Value::Array(arr)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_map_array_string() {
        let arr = Value::Array(vec![
            Value::Object([("name".to_string(), Value::String("Alice".to_string())), ("age".to_string(), Value::Int(30))].into()),
            Value::Object([("name".to_string(), Value::String("Bob".to_string())), ("age".to_string(), Value::Int(25))].into()),
        ]);
        let result = builtin_map(&[arr, Value::String("name".to_string())]).unwrap();
        assert_eq!(result, Value::Array(vec![Value::String("Alice".to_string()), Value::String("Bob".to_string())]));
    }

    #[test]
    fn test_builtin_map_dataframe_string() {
        let df = DataFrame::new(vec![
            Series::new("name", &["Alice", "Bob"]),
            Series::new("age", &[30, 25]),
        ]).unwrap();
        let result = builtin_map(&[Value::DataFrame(df), Value::String("name".to_string())]).unwrap();
        assert_eq!(result, Value::Array(vec![Value::String("Alice".to_string()), Value::String("Bob".to_string())]));
    }

    #[test]
    fn test_builtin_map_array_object() {
        let arr = Value::Array(vec![
            Value::Object([("name".to_string(), Value::String("Alice".to_string())), ("age".to_string(), Value::Int(30))].into()),
            Value::Object([("name".to_string(), Value::String("Bob".to_string())), ("age".to_string(), Value::Int(25))].into()),
        ]);
        let template = Value::Object([("name".to_string(), Value::Null), ("age".to_string(), Value::Null)].into());
        let result = builtin_map(&[arr, template]).unwrap();
        let expected = Value::Array(vec![
            Value::Object([("name".to_string(), Value::String("Alice".to_string())), ("age".to_string(), Value::Int(30))].into()),
            Value::Object([("name".to_string(), Value::String("Bob".to_string())), ("age".to_string(), Value::Int(25))].into()),
        ]);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_builtin_map_dataframe_object() {
        let df = DataFrame::new(vec![
            Series::new("name", &["Alice", "Bob"]),
            Series::new("age", &[30, 25]),
        ]).unwrap();
        let template = Value::Object([("name".to_string(), Value::Null), ("age".to_string(), Value::Null)].into());
        let result = builtin_map(&[Value::DataFrame(df), template]).unwrap();
        let expected_df = DataFrame::new(vec![
            Series::new("name", &["Alice", "Bob"]),
            Series::new("age", &[30, 25]),
        ]).unwrap();
        assert_eq!(result, Value::DataFrame(expected_df));
    }

    #[test]
    fn test_builtin_base64_decode_dataframe_with_invalid_values() {
        let df = DataFrame::new(vec![
            Series::new("encoded", vec!["SGVsbG8=", "invalid!"]), // First valid, second invalid
        ]).unwrap();
        let result = builtin_base64_decode(&[Value::DataFrame(df)]);
        // For DataFrame, invalid values should be set to null, so this should succeed
        assert!(result.is_ok());
        match result.unwrap() {
            Value::DataFrame(result_df) => {
                let encoded_col = result_df.column("encoded").unwrap();
                if let Ok(AnyValue::Utf8(first)) = encoded_col.get(0) {
                    assert_eq!(first, "Hello");
                }
                // Second value should be null due to invalid base64
                if let Ok(AnyValue::Null) = encoded_col.get(1) {
                    // Correctly set to null
                } else {
                    panic!("Expected null for invalid base64");
                }
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_minute_timestamp() {
        // Test minute extraction from timestamp
        let result = builtin_minute(&[Value::Int(1609459200)]).unwrap(); // 2021-01-01 00:00:00 UTC
        assert_eq!(result, Value::Int(0));

        let result = builtin_minute(&[Value::Int(1609459260)]).unwrap(); // 2021-01-01 00:01:00 UTC
        assert_eq!(result, Value::Int(1));
    }

    #[test]
    fn test_builtin_minute_string_timestamp() {
        // Test minute extraction from string timestamp
        let result = builtin_minute(&[Value::String("1609459200".to_string())]).unwrap();
        assert_eq!(result, Value::Int(0));

        let result = builtin_minute(&[Value::String("1609459260".to_string())]).unwrap();
        assert_eq!(result, Value::Int(1));
    }

    #[test]
    fn test_builtin_minute_array() {
        let arr = vec![Value::Int(1609459200), Value::Int(1609459260)];
        let result = builtin_minute(&[Value::Array(arr)]).unwrap();
        match result {
            Value::Array(minutes) => {
                assert_eq!(minutes.len(), 2);
                assert_eq!(minutes[0], Value::Int(0));
                assert_eq!(minutes[1], Value::Int(1));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_minute_dataframe() {
        let df = DataFrame::new(vec![
            Series::new("timestamps", vec![1609459200i64, 1609459260i64]),
            Series::new("names", vec!["A", "B"]),
        ]).unwrap();
        let result = builtin_minute(&[Value::DataFrame(df.clone())]).unwrap();
        match result {
            Value::DataFrame(result_df) => {
                assert_eq!(result_df.height(), 2);
                let timestamp_col = result_df.column("timestamps").unwrap();
                println!("Actual dtype: {:?}", timestamp_col.dtype());
                assert_eq!(timestamp_col.dtype(), &DataType::Int64);
                if let Ok(val0) = timestamp_col.get(0) {
                    if let AnyValue::Int64(v0) = val0 {
                        assert_eq!(v0, 0);
                    }
                }
                if let Ok(val1) = timestamp_col.get(1) {
                    if let AnyValue::Int64(v1) = val1 {
                        assert_eq!(v1, 1);
                    }
                }
                // names column should remain unchanged
                let names_col = result_df.column("names").unwrap();
                assert_eq!(names_col.dtype(), &DataType::Utf8);
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_minute_dataframe_string_timestamps() {
        let df = DataFrame::new(vec![
            Series::new("timestamps", vec!["1609459200", "1609459260"]),
            Series::new("names", vec!["A", "B"]),
        ]).unwrap();
        let result = builtin_minute(&[Value::DataFrame(df.clone())]).unwrap();
        match result {
            Value::DataFrame(result_df) => {
                assert_eq!(result_df.height(), 2);
                let timestamp_col = result_df.column("timestamps").unwrap();
                assert_eq!(timestamp_col.dtype(), &DataType::Int64);
                if let Ok(val0) = timestamp_col.get(0) {
                    if let AnyValue::Int64(v0) = val0 {
                        assert_eq!(v0, 0);
                    }
                }
                if let Ok(val1) = timestamp_col.get(1) {
                    if let AnyValue::Int64(v1) = val1 {
                        assert_eq!(v1, 1);
                    }
                }
                // names column should remain unchanged
                let names_col = result_df.column("names").unwrap();
                assert_eq!(names_col.dtype(), &DataType::Utf8);
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_minute_series() {
        let series = Series::new("timestamps", vec![1609459200i64, 1609459260i64]);
        let result = builtin_minute(&[Value::Series(series)]).unwrap();
        match result {
            Value::Series(result_series) => {
                assert_eq!(result_series.len(), 2);
                assert_eq!(result_series.dtype(), &DataType::Int64);
                if let Ok(val0) = result_series.get(0) {
                    if let AnyValue::Int64(v0) = val0 {
                        assert_eq!(v0, 0);
                    }
                }
                if let Ok(val1) = result_series.get(1) {
                    if let AnyValue::Int64(v1) = val1 {
                        assert_eq!(v1, 1);
                    }
                }
            }
            _ => panic!("Expected Series"),
        }
    }

    #[test]
    fn test_builtin_minute_series_string_timestamps() {
        let series = Series::new("timestamps", vec!["1609459200", "1609459260"]);
        let result = builtin_minute(&[Value::Series(series)]).unwrap();
        match result {
            Value::Series(result_series) => {
                assert_eq!(result_series.len(), 2);
                assert_eq!(result_series.dtype(), &DataType::Int64);
                if let Ok(val0) = result_series.get(0) {
                    if let AnyValue::Int64(v0) = val0 {
                        assert_eq!(v0, 0);
                    }
                }
                if let Ok(val1) = result_series.get(1) {
                    if let AnyValue::Int64(v1) = val1 {
                        assert_eq!(v1, 1);
                    }
                }
            }
            _ => panic!("Expected Series"),
        }
    }

    #[test]
    fn test_builtin_minute_invalid_args() {
        // No args
        let result = builtin_minute(&[]);
        assert!(result.is_err());

        // Too many args
        let result = builtin_minute(&[Value::Int(1), Value::Int(2)]);
        assert!(result.is_err());

        // Invalid timestamp string
        let result = builtin_minute(&[Value::String("invalid".to_string())]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_generate_uuidv7_no_args() {
        let result = builtin_generate_uuidv7(&[]).unwrap();
        match result {
            Value::String(uuid_str) => {
                // UUID v7 should be a valid UUID string (36 characters with dashes)
                assert_eq!(uuid_str.len(), 36);
                // Should contain dashes at expected positions
                assert_eq!(uuid_str.chars().nth(8), Some('-'));
                assert_eq!(uuid_str.chars().nth(13), Some('-'));
                assert_eq!(uuid_str.chars().nth(18), Some('-'));
                assert_eq!(uuid_str.chars().nth(23), Some('-'));
                // Should be able to parse as UUID
                assert!(uuid::Uuid::parse_str(&uuid_str).is_ok());
            }
            _ => panic!("Expected String"),
        }
    }

    #[test]
    fn test_builtin_generate_uuidv7_with_array() {
        let arr = vec![Value::Int(1), Value::Int(2), Value::Int(3)];
        let result = builtin_generate_uuidv7(&[Value::Array(arr)]).unwrap();
        match result {
            Value::Array(uuids) => {
                assert_eq!(uuids.len(), 3);
                for uuid_val in uuids {
                    match uuid_val {
                        Value::String(uuid_str) => {
                            assert_eq!(uuid_str.len(), 36);
                            assert!(uuid::Uuid::parse_str(&uuid_str).is_ok());
                        }
                        _ => panic!("Expected String in array"),
                    }
                }
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_generate_uuidv7_with_dataframe() {
        let df = DataFrame::new(vec![
            Series::new("col1", vec![1, 2, 3]),
            Series::new("col2", vec!["a", "b", "c"]),
        ]).unwrap();
        let result = builtin_generate_uuidv7(&[Value::DataFrame(df.clone())]).unwrap();
        match result {
            Value::DataFrame(result_df) => {
                assert_eq!(result_df.height(), 3);
                assert!(result_df.get_column_names().contains(&"uuid_v7"));
                let uuid_col = result_df.column("uuid_v7").unwrap();
                assert_eq!(uuid_col.dtype(), &DataType::Utf8);
                for i in 0..uuid_col.len() {
                    if let Ok(AnyValue::Utf8(uuid_str)) = uuid_col.get(i) {
                        assert_eq!(uuid_str.len(), 36);
                        assert!(uuid::Uuid::parse_str(uuid_str).is_ok());
                    }
                }
                // Original columns should remain
                assert!(result_df.get_column_names().contains(&"col1"));
                assert!(result_df.get_column_names().contains(&"col2"));
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_generate_uuidv7_with_series() {
        let series = Series::new("test", vec![1, 2, 3]);
        let result = builtin_generate_uuidv7(&[Value::Series(series)]).unwrap();
        match result {
            Value::Series(result_series) => {
                assert_eq!(result_series.len(), 3);
                assert_eq!(result_series.dtype(), &DataType::Utf8);
                for i in 0..result_series.len() {
                    if let Ok(AnyValue::Utf8(uuid_str)) = result_series.get(i) {
                        assert_eq!(uuid_str.len(), 36);
                        assert!(uuid::Uuid::parse_str(uuid_str).is_ok());
                    }
                }
            }
            _ => panic!("Expected Series"),
        }
    }

    #[test]
    fn test_builtin_generate_uuidv7_with_other_value() {
        let result = builtin_generate_uuidv7(&[Value::String("test".to_string())]).unwrap();
        match result {
            Value::String(uuid_str) => {
                assert_eq!(uuid_str.len(), 36);
                assert!(uuid::Uuid::parse_str(&uuid_str).is_ok());
            }
            _ => panic!("Expected String"),
        }
    }

    #[test]
    fn test_builtin_generate_uuidv7_invalid_args() {
        // Too many args
        let result = builtin_generate_uuidv7(&[Value::Int(1), Value::Int(2)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_to_ascii() {
        // Test string
        let result = builtin_to_ascii(&[Value::String("abc".to_string())]).unwrap();
        assert_eq!(result, Value::String("97 98 99".to_string()));

        // Test string with spaces
        let result = builtin_to_ascii(&[Value::String("a b".to_string())]).unwrap();
        assert_eq!(result, Value::String("97 32 98".to_string()));

        // Test empty string
        let result = builtin_to_ascii(&[Value::String("".to_string())]).unwrap();
        assert_eq!(result, Value::String("".to_string()));

        // Test unicode characters
        let result = builtin_to_ascii(&[Value::String("Jos".to_string())]).unwrap();
        assert_eq!(result, Value::String("74 111 115 233".to_string()));

        // Test array of strings
        let arr = vec![
            Value::String("a".to_string()),
            Value::String("bc".to_string()),
        ];
        let result = builtin_to_ascii(&[Value::Array(arr)]).unwrap();
        match result {
            Value::Array(results) => {
                assert_eq!(results.len(), 2);
                assert_eq!(results[0], Value::String("97".to_string()));
                assert_eq!(results[1], Value::String("98 99".to_string()));
            }
            _ => panic!("Expected Array"),
        }

        // Test DataFrame
        let df = DataFrame::new(vec![
            Series::new("name", vec!["Alice", "Bob"]),
            Series::new("age", vec![25, 30]),
        ]).unwrap();
        let result = builtin_to_ascii(&[Value::DataFrame(df)]).unwrap();
        match result {
            Value::DataFrame(result_df) => {
                assert_eq!(result_df.height(), 2);
                let name_col = result_df.column("name").unwrap();
                assert_eq!(name_col.dtype(), &DataType::Utf8);
                // Check first row
                if let Ok(AnyValue::Utf8(s)) = name_col.get(0) {
                    assert_eq!(s, "65 108 105 99 101");
                }
                // age column should remain unchanged
                let age_col = result_df.column("age").unwrap();
                assert_eq!(age_col.dtype(), &DataType::Int32);
            }
            _ => panic!("Expected DataFrame"),
        }

        // Test Series
        let series = Series::new("test", vec!["x", "yz"]);
        let result = builtin_to_ascii(&[Value::Series(series)]).unwrap();
        match result {
            Value::Series(result_series) => {
                assert_eq!(result_series.dtype(), &DataType::Utf8);
                if let Ok(AnyValue::Utf8(s)) = result_series.get(0) {
                    assert_eq!(s, "120");
                }
                if let Ok(AnyValue::Utf8(s)) = result_series.get(1) {
                    assert_eq!(s, "121 122");
                }
            }
            _ => panic!("Expected Series"),
        }

        // Test invalid args
        let result = builtin_to_ascii(&[]);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("to_ascii() expects 1 argument"));

        let result = builtin_to_ascii(&[Value::Int(1), Value::Int(2)]);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("to_ascii() expects 1 argument"));

        // Test array with non-string
        let arr = vec![Value::Int(1)];
        let result = builtin_to_ascii(&[Value::Array(arr)]);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("to_ascii() requires string elements in array"));

        // Test unsupported type
        let result = builtin_to_ascii(&[Value::Int(42)]);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("to_ascii() requires string, array, DataFrame, or Series"));
    }

    #[test]
    fn test_builtin_generate_sequence_basic() {
        // Test basic sequence: 0, 1, 2, 3, 4
        let result = builtin_generate_sequence(&[Value::Int(0), Value::Int(5), Value::Int(1)]).unwrap();
        match result {
            Value::Array(seq) => {
                assert_eq!(seq.len(), 5);
                assert_eq!(seq[0], Value::Int(0));
                assert_eq!(seq[1], Value::Int(1));
                assert_eq!(seq[2], Value::Int(2));
                assert_eq!(seq[3], Value::Int(3));
                assert_eq!(seq[4], Value::Int(4));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_generate_sequence_with_start() {
        // Test sequence: 5, 6, 7, 8, 9
        let result = builtin_generate_sequence(&[Value::Int(5), Value::Int(10), Value::Int(1)]).unwrap();
        match result {
            Value::Array(seq) => {
                assert_eq!(seq.len(), 5);
                assert_eq!(seq[0], Value::Int(5));
                assert_eq!(seq[1], Value::Int(6));
                assert_eq!(seq[2], Value::Int(7));
                assert_eq!(seq[3], Value::Int(8));
                assert_eq!(seq[4], Value::Int(9));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_generate_sequence_with_step() {
        // Test sequence: 0, 2, 4, 6, 8
        let result = builtin_generate_sequence(&[Value::Int(0), Value::Int(10), Value::Int(2)]).unwrap();
        match result {
            Value::Array(seq) => {
                assert_eq!(seq.len(), 5);
                assert_eq!(seq[0], Value::Int(0));
                assert_eq!(seq[1], Value::Int(2));
                assert_eq!(seq[2], Value::Int(4));
                assert_eq!(seq[3], Value::Int(6));
                assert_eq!(seq[4], Value::Int(8));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_generate_sequence_negative_step() {
        // Test sequence: 10, 8, 6, 4, 2
        let result = builtin_generate_sequence(&[Value::Int(10), Value::Int(0), Value::Int(-2)]).unwrap();
        match result {
            Value::Array(seq) => {
                assert_eq!(seq.len(), 5);
                assert_eq!(seq[0], Value::Int(10));
                assert_eq!(seq[1], Value::Int(8));
                assert_eq!(seq[2], Value::Int(6));
                assert_eq!(seq[3], Value::Int(4));
                assert_eq!(seq[4], Value::Int(2));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_generate_sequence_float_values() {
        // Test sequence: 0.0, 0.5, 1.0, 1.5
        let result = builtin_generate_sequence(&[Value::Float(0.0), Value::Float(2.0), Value::Float(0.5)]).unwrap();
        match result {
            Value::Array(seq) => {
                assert_eq!(seq.len(), 4);
                assert_eq!(seq[0], Value::Float(0.0));
                assert_eq!(seq[1], Value::Float(0.5));
                assert_eq!(seq[2], Value::Float(1.0));
                assert_eq!(seq[3], Value::Float(1.5));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_generate_sequence_mixed_int_float() {
        // Test sequence with mixed int/float inputs
        let result = builtin_generate_sequence(&[Value::Int(1), Value::Float(4.0), Value::Int(1)]).unwrap();
        match result {
            Value::Array(seq) => {
                assert_eq!(seq.len(), 3);
                assert_eq!(seq[0], Value::Int(1));
                assert_eq!(seq[1], Value::Int(2));
                assert_eq!(seq[2], Value::Int(3));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_generate_sequence_empty() {
        // Test empty sequence (start >= end with positive step)
        let result = builtin_generate_sequence(&[Value::Int(5), Value::Int(0), Value::Int(1)]).unwrap();
        match result {
            Value::Array(seq) => {
                assert_eq!(seq.len(), 0);
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_generate_sequence_single_element() {
        // Test single element sequence
        let result = builtin_generate_sequence(&[Value::Int(5), Value::Int(6), Value::Int(1)]).unwrap();
        match result {
            Value::Array(seq) => {
                assert_eq!(seq.len(), 1);
                assert_eq!(seq[0], Value::Int(5));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_generate_sequence_invalid_args() {
        // Test wrong number of arguments
        let result = builtin_generate_sequence(&[Value::Int(0), Value::Int(5)]);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("generate_sequence() expects 3 arguments"));

        // Test zero step
        let result = builtin_generate_sequence(&[Value::Int(0), Value::Int(5), Value::Int(0)]);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("step cannot be zero"));

        // Test non-numeric start
        let result = builtin_generate_sequence(&[Value::String("0".to_string()), Value::Int(5), Value::Int(1)]);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("start must be a number"));

        // Test non-numeric end
        let result = builtin_generate_sequence(&[Value::Int(0), Value::String("5".to_string()), Value::Int(1)]);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("end must be a number"));

        // Test non-numeric step
        let result = builtin_generate_sequence(&[Value::Int(0), Value::Int(5), Value::String("1".to_string())]);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("step must be a number"));
    }

    #[test]
    fn test_builtin_day() {
        // Test with timestamp for 2021-01-01 00:00:00 UTC (day = 1)
        let result = builtin_day(&[Value::Int(1609459200)]).unwrap();
        assert_eq!(result, Value::Int(1));

        // Test with float timestamp
        let result = builtin_day(&[Value::Float(1609459200.0)]).unwrap();
        assert_eq!(result, Value::Int(1));

        // Test with string date
        let result = builtin_day(&[Value::String("2021-01-01T00:00:00Z".to_string())]).unwrap();
        assert_eq!(result, Value::Int(1));

        // Test error: no args
        let result = builtin_day(&[]);
        assert!(result.is_err());

        // Test error: too many args
        let result = builtin_day(&[Value::Int(1609459200), Value::Int(1)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_stdev_p() {
        // Test with array of integers
        let arr = vec![Value::Int(1), Value::Int(2), Value::Int(3), Value::Int(4), Value::Int(5)];
        let result = builtin_stdev_p(&[Value::Array(arr)]).unwrap();
        // Population standard deviation of [1,2,3,4,5] is sqrt(2)  1.414213562
        match result {
            Value::Float(val) => assert!((val - 1.414213562).abs() < 1e-6),
            _ => panic!("Expected Float"),
        }

        // Test with empty array
        let result = builtin_stdev_p(&[Value::Array(vec![])]).unwrap();
        assert_eq!(result, Value::Null);

        // Test with single element
        let arr = vec![Value::Int(5)];
        let result = builtin_stdev_p(&[Value::Array(arr)]).unwrap();
        match result {
            Value::Float(val) => assert_eq!(val, 0.0),
            _ => panic!("Expected Float"),
        }

        // Test with floats
        let arr = vec![Value::Float(1.0), Value::Float(2.0), Value::Float(3.0)];
        let result = builtin_stdev_p(&[Value::Array(arr)]).unwrap();
        // Population std of [1,2,3] is sqrt(2/3)  0.816496581
        match result {
            Value::Float(val) => assert!((val - 0.816496581).abs() < 1e-6),
            _ => panic!("Expected Float"),
        }

        // Test error: non-numeric
        let arr = vec![Value::String("a".to_string())];
        let result = builtin_stdev_p(&[Value::Array(arr)]);
        assert!(result.is_err());

        // Test error: no args
        let result = builtin_stdev_p(&[]);
        assert!(result.is_err());

        // Test error: too many args
        let result = builtin_stdev_p(&[Value::Array(vec![Value::Int(1)]), Value::Int(2)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_stdev_s() {
        // Test with array of integers
        let arr = vec![Value::Int(1), Value::Int(2), Value::Int(3), Value::Int(4), Value::Int(5)];
        let result = builtin_stdev_s(&[Value::Array(arr)]).unwrap();
        // Sample standard deviation of [1,2,3,4,5] is sqrt(2.5)  1.58113883
        match result {
            Value::Float(val) => assert!((val - 1.58113883).abs() < 1e-6),
            _ => panic!("Expected Float"),
        }

        // Test with single element (should return null)
        let arr = vec![Value::Int(5)];
        let result = builtin_stdev_s(&[Value::Array(arr)]).unwrap();
        assert_eq!(result, Value::Null);

        // Test with two elements
        let arr = vec![Value::Int(1), Value::Int(3)];
        let result = builtin_stdev_s(&[Value::Array(arr)]).unwrap();
        // Sample std of [1,3] is sqrt(2)  1.414213562
        match result {
            Value::Float(val) => assert!((val - 1.414213562).abs() < 1e-6),
            _ => panic!("Expected Float"),
        }

        // Test with floats
        let arr = vec![Value::Float(1.0), Value::Float(2.0), Value::Float(3.0)];
        let result = builtin_stdev_s(&[Value::Array(arr)]).unwrap();
        // Sample std of [1,2,3] is sqrt(1) = 1.0
        match result {
            Value::Float(val) => assert!((val - 1.0).abs() < 1e-6),
            _ => panic!("Expected Float"),
        }

        // Test error: non-numeric
        let arr = vec![Value::String("a".to_string())];
        let result = builtin_stdev_s(&[Value::Array(arr)]);
        assert!(result.is_err());

        // Test error: no args
        let result = builtin_stdev_s(&[]);
        assert!(result.is_err());

        // Test error: too many args
        let result = builtin_stdev_s(&[Value::Array(vec![Value::Int(1)]), Value::Int(2)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_base32_decode_string() {
        // Test basic decoding
        let encoded = "JBSWY3DP"; // "Hello" in base32
        let result = builtin_base32_decode(&[Value::String(encoded.to_string())]).unwrap();
        assert_eq!(result, Value::String("Hello".to_string()));

        // Test with different string
        let encoded = "MJXW2ZDFEBRHI"; // decodes to "bomde bt"
        let result = builtin_base32_decode(&[Value::String(encoded.to_string())]).unwrap();
        assert_eq!(result, Value::String("bomde bt".to_string()));

        // Test empty string
        let result = builtin_base32_decode(&[Value::String("".to_string())]).unwrap();
        assert_eq!(result, Value::String("".to_string()));
    }

    #[test]
    fn test_builtin_base32_decode_array() {
        let encoded_values = vec![
            Value::String("JBSWY3DP".to_string()), // "Hello"
            Value::String("MJXW2ZDFEBRHI".to_string()), // "bomde bt"
        ];
        let result = builtin_base32_decode(&[Value::Array(encoded_values)]).unwrap();
        match result {
            Value::Array(decoded) => {
                assert_eq!(decoded.len(), 2);
                assert_eq!(decoded[0], Value::String("Hello".to_string()));
                assert_eq!(decoded[1], Value::String("bomde bt".to_string()));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_base32_decode_dataframe() {
        let df = DataFrame::new(vec![
            Series::new("encoded", vec!["JBSWY3DP", "MJXW2ZDFEBRHI"]), // "Hello", "bomde bt"
            Series::new("number", vec![1, 2]),
        ]).unwrap();
        let result = builtin_base32_decode(&[Value::DataFrame(df.clone())]).unwrap();
        match result {
            Value::DataFrame(result_df) => {
                assert_eq!(result_df.height(), 2);
                // encoded column should be decoded
                let encoded_col = result_df.column("encoded").unwrap();
                assert_eq!(encoded_col.dtype(), &DataType::Utf8);
                if let Ok(AnyValue::Utf8(first)) = encoded_col.get(0) {
                    assert_eq!(first, "Hello");
                }
                if let Ok(AnyValue::Utf8(second)) = encoded_col.get(1) {
                    assert_eq!(second, "bomde bt");
                }
                // number column should remain unchanged
                let number_col = result_df.column("number").unwrap();
                assert!(number_col.dtype().is_integer());
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_base32_decode_series() {
        let series = Series::new("encoded", vec!["JBSWY3DP", "MJXW2ZDFEBRHI"]); // "Hello", "bomde bt"
        let result = builtin_base32_decode(&[Value::Series(series)]).unwrap();
        match result {
            Value::Series(result_series) => {
                assert_eq!(result_series.len(), 2);
                assert_eq!(result_series.dtype(), &DataType::Utf8);
                if let Ok(AnyValue::Utf8(first)) = result_series.get(0) {
                    assert_eq!(first, "Hello");
                }
                if let Ok(AnyValue::Utf8(second)) = result_series.get(1) {
                    assert_eq!(second, "bomde bt");
                }
            }
            _ => panic!("Expected Series"),
        }
    }

    #[test]
    fn test_builtin_base32_decode_invalid_base32() {
        // Test invalid base32 string
        let result = builtin_base32_decode(&[Value::String("invalid base32!".to_string())]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_base32_decode_invalid_args() {
        // Test no args
        let result = builtin_base32_decode(&[]);
        assert!(result.is_err());

        // Test too many args
        let result = builtin_base32_decode(&[Value::String("test".to_string()), Value::String("extra".to_string())]);
        assert!(result.is_err());

        // Test invalid type
        let result = builtin_base32_decode(&[Value::Int(123)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_base32_decode_array_with_invalid_elements() {
        let arr = vec![
            Value::String("JBSWY3DP".to_string()), // "Hello"
            Value::Int(123), // Invalid
        ];
        let result = builtin_base32_decode(&[Value::Array(arr)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_ceil_int() {
        let result = builtin_ceil(&[Value::Int(3)]).unwrap();
        assert_eq!(result, Value::Int(3));

        let result = builtin_ceil(&[Value::Int(4)]).unwrap();
        assert_eq!(result, Value::Int(4));
    }

    #[test]
    fn test_builtin_ceil_float() {
        let result = builtin_ceil(&[Value::Float(3.1)]).unwrap();
        assert_eq!(result, Value::Float(4.0));

        let result = builtin_ceil(&[Value::Float(3.9)]).unwrap();
        assert_eq!(result, Value::Float(4.0));

        let result = builtin_ceil(&[Value::Float(-3.1)]).unwrap();
        assert_eq!(result, Value::Float(-3.0));
    }

    #[test]
    fn test_builtin_ceil_bigint() {
        let bi = num_bigint::BigInt::from(5);
        let result = builtin_ceil(&[Value::BigInt(bi)]).unwrap();
        assert_eq!(result, Value::Float(5.0));
    }

    #[test]
    fn test_builtin_ceil_array() {
        let arr = vec![Value::Float(3.1), Value::Float(3.9), Value::Int(5)];
        let result = builtin_ceil(&[Value::Array(arr)]).unwrap();
        match result {
            Value::Array(res) => {
                assert_eq!(res[0], Value::Float(4.0));
                assert_eq!(res[1], Value::Float(4.0));
                assert_eq!(res[2], Value::Int(5));
            }
            _ => panic!("Expected Array"),
        }
    }

    #[test]
    fn test_builtin_ceil_dataframe() {
        let df = DataFrame::new(vec![
            Series::new("values", vec![3.1, 3.9, 5.0]),
            Series::new("text", vec!["a", "b", "c"]),
        ]).unwrap();
        let result = builtin_ceil(&[Value::DataFrame(df.clone())]).unwrap();
        match result {
            Value::DataFrame(result_df) => {
                assert_eq!(result_df.height(), 3);
                let values_col = result_df.column("values").unwrap();
                assert_eq!(values_col.dtype(), &DataType::Float64);
                if let Ok(val0) = values_col.get(0) {
                    if let AnyValue::Float64(v0) = val0 {
                        assert_eq!(v0, 4.0);
                    }
                }
                if let Ok(val1) = values_col.get(1) {
                    if let AnyValue::Float64(v1) = val1 {
                        assert_eq!(v1, 4.0);
                    }
                }
                if let Ok(val2) = values_col.get(2) {
                    if let AnyValue::Float64(v2) = val2 {
                        assert_eq!(v2, 5.0);
                    }
                }
                // text column should remain unchanged
                let text_col = result_df.column("text").unwrap();
                assert_eq!(text_col.dtype(), &DataType::Utf8);
            }
            _ => panic!("Expected DataFrame"),
        }
    }

    #[test]
    fn test_builtin_ceil_series() {
        let series = Series::new("values", vec![3.1, 3.9, 5.0]);
        let result = builtin_ceil(&[Value::Series(series)]).unwrap();
        match result {
            Value::Series(result_series) => {
                assert_eq!(result_series.len(), 3);
                assert_eq!(result_series.dtype(), &DataType::Float64);
                if let Ok(val0) = result_series.get(0) {
                    if let AnyValue::Float64(v0) = val0 {
                        assert_eq!(v0, 4.0);
                    }
                }
                if let Ok(val1) = result_series.get(1) {
                    if let AnyValue::Float64(v1) = val1 {
                        assert_eq!(v1, 4.0);
                    }
                }
                if let Ok(val2) = result_series.get(2) {
                    if let AnyValue::Float64(v2) = val2 {
                        assert_eq!(v2, 5.0);
                    }
                }
            }
            _ => panic!("Expected Series"),
        }
    }

    #[test]
    fn test_builtin_ceil_invalid_args() {
        // No args
        let result = builtin_ceil(&[]);
        assert!(result.is_err());

        // Too many args
        let result = builtin_ceil(&[Value::Int(1), Value::Int(2)]);
        assert!(result.is_err());

        // Invalid type
        let result = builtin_ceil(&[Value::String("test".to_string())]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_select() {
        // Test with truthy condition
        let result = builtin_select(&[Value::Int(42), Value::Bool(true)]).unwrap();
        assert_eq!(result, Value::Int(42));

        // Test with falsy condition
        let result = builtin_select(&[Value::Int(42), Value::Bool(false)]).unwrap();
        assert_eq!(result, Value::Null);

        // Test with null condition
        let result = builtin_select(&[Value::String("test".to_string()), Value::Null]).unwrap();
        assert_eq!(result, Value::Null);

        // Test with invalid args - too many
        let result = builtin_select(&[Value::Int(42), Value::Bool(true), Value::Int(1)]);
        assert!(result.is_err());
    }

    #[test]
    fn test_builtin_filter() {
        // Since filter is handled in compiler, this is same as select
        let result = builtin_filter(&[Value::Int(42), Value::Bool(true)]).unwrap();
        assert_eq!(result, Value::Int(42));

        let result = builtin_filter(&[Value::Int(42), Value::Bool(false)]).unwrap();
        assert_eq!(result, Value::Null);
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}
fn builtin_titlecase(args: &[Value]) -> Result<Value> {
    if args.len() != 1 {
        return Err(dsq_shared::error::operation_error("titlecase() expects 1 argument"));
    }

    match &args[0] {
        Value::String(s) => {
            Ok(Value::String(s.to_title_case()))
        }
        Value::Array(arr) => {
            let titlecased: Vec<Value> = arr.iter().map(|v| {
                match v {
                    Value::String(s) => Value::String(s.to_title_case()),
                    _ => v.clone(), // Leave non-string values unchanged
                }
            }).collect();
            Ok(Value::Array(titlecased))
        }
        Value::DataFrame(df) => {
            let mut new_series = Vec::new();
            for col_name in df.get_column_names() {
                if let Ok(series) = df.column(col_name) {
                    if series.dtype() == &DataType::Utf8 {
                        let titlecase_series = series.utf8().unwrap().apply(|s| {
                            s.map(|s| Cow::Owned(s.to_title_case()))
                        }).into_series();
                        let mut s = titlecase_series;
                        s.rename(col_name);
                        new_series.push(s);
                    } else {
                        let mut s = series.clone();
                        s.rename(col_name);
                        new_series.push(s);
                    }
                }
            }
            match DataFrame::new(new_series) {
                Ok(new_df) => Ok(Value::DataFrame(new_df)),
                Err(e) => Err(dsq_shared::error::operation_error(format!("titlecase() failed on DataFrame: {}", e))),
            }
        }
        Value::Series(series) => {
            if series.dtype() == &DataType::Utf8 {
                let titlecase_series = series.utf8().unwrap().apply(|s| {
                    s.map(|s| Cow::Owned(s.to_title_case()))
                }).into_series();
                Ok(Value::Series(titlecase_series))
            } else {
                Ok(Value::Series(series.clone()))
            }
        }
        _ => Ok(args[0].clone()),
    }
}
